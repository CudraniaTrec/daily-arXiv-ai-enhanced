<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Optimism in Equality Saturation](https://arxiv.org/abs/2511.20782)
*Russel Arbore,Alvin Cheung,Max Willsey*

Main category: cs.PL

TL;DR: 本文提出了一种结合乐观分析与非破坏性重写的抽象解释算法，有效提升了循环程序（如SSA形式）的优化和分析精度，且原型工具在简单程序上优于clang和gcc。


<details>
  <summary>Details</summary>
Motivation: 现有e-class分析方法在处理存在循环结构的程序（如SSA形式）时过于保守，导致分析效果不佳。需开发更精确的分析方法以提升优化能力。

Method: 结合乐观分析与非破坏性重写，设计了一个可以处理循环（如SSA形式）的抽象解释算法，利用新的SSA语义在原型解释器中进行实验。

Result: 新算法可对简单程序实现比clang和gcc更精确的分析效果。原型系统能够突破现有分析工具的限制。

Conclusion: 提出了一种新的抽象解释算法，使得在等价饱和过程中可以对循环程序进行更精确的分析，并成功在原型系统中实现了对SSA程序的精确分析。

Abstract: Equality saturation is a technique for program optimization based on non-destructive rewriting and a form of program analysis called e-class analysis. The current form of e-class analysis is pessimistic and therefore ineffective at analyzing cyclic programs, such as those in SSA form. We propose an abstract interpretation algorithm that can precisely analyze cycles during equality saturation. This results in a unified algorithm for optimistic analysis and non-destructive rewriting. We instantiate this approach on a prototype abstract interpreter for SSA programs using a new semantics of SSA. Our prototype can analyze simple example programs more precisely than clang and gcc.

</details>


### [2] [Towards Computational UIP in Cubical Agda](https://arxiv.org/abs/2511.21209)
*Yee-Jian Tan,Andreas Nuyts,Dominique Devriese*

Main category: cs.PL

TL;DR: 本文研究了Cubical Agda中截断等价层次的问题，证明去除Glue类型并引入UIP后，能够保留商归纳类型与函数外延性，推动了Cubical Type Theory的实用性发展。


<details>
  <summary>Details</summary>
Motivation: 该论文探讨了在Cubical Agda中，将Cubical Type Theory的等价层次截断为仅保留同调集合（h-Set）时，是否仍能保留一些重要特性，如商归纳类型（QITs）与函数外延性。作者关注如何在不牺牲这些特性的前提下，引入唯一性同一性证明（UIP）以取代不可管理的无限等价层次。

Method: 通过分析UIP在Cubical Agda中的不同表达方式，以及与Glue类型的关系，阐述其计算规则并评估其可实现性。同时，作者还实现了一个移除Glue类型的Cubical Agda变体，以适配UIP的引入。

Result: 论文表明，实现仅保留h-Set层次的Cubical Type Theory仍可保留QITs和函数外延性。作者还指出现阶段在Cubical Agda中达成这一目标的方法存在缺陷，并推动了对自动化实现UIP的需求。项目实现了一个去除Glue类型、适配UIP的新变体。

Conclusion: Cubical Type Theory在截断为h-Set后，仍可保持若干关键特性，同时解决无限等价层次带来的复杂度。全面实现UIP仍需要Cubical Agda进一步支持，但本文的分析与实验成果为未来实现奠定了基础。

Abstract: Some advantages of Cubical Type Theory, as implemented by Cubical Agda, over intensional Martin-Löf Type Theory include Quotient Inductive Types (QITs), which exist as instances of Higher Inductive Types, and functional extensionality, which is provable in Cubical Type Theory. However, HoTT features an infinite hierarchy of equalities that may become unwieldy in formalisations. Fortunately, QITs and functional extensionality are both preserved even if the equality levels of Cubical Type Theory are truncated to only homotopical Sets (h-Sets). In other words, removing the univalence axiom from Cubical Type Theory and instead postulating a conflicting axiom: the Uniqueness of Identity Proofs (UIP) postulate. Since univalence is proved in Cubical Type Theory from the so-called Glue Types, therefore, it is known that one can first remove the Glue Types (thus removing univalence) and then set-truncate all equalities (essentially assuming UIP), à la XTT. The result is a "h-Set Cubical Type Theory" that retains features such as functional extensionality and QITs.
  However, in Cubical Agda, there are currently only two unsatisfying ways to achieve h-Set Cubical Type Theory. The first is to give up on the canonicity of the theory and simply postulate the UIP axiom, while the second way is to use a standard result stating "type formers preserve h-levels" to manually prove UIP for every defined type. The latter is, however, laborious work best suited for an automatic implementation by the proof assistant. In this project, we analyse formulations of UIP and detail their computation rules for Cubical Agda, and evaluate their suitability for implementation. We also implement a variant of Cubical Agda without Glue, which is already compatible with postulated UIP, in anticipation of a future implementation of UIP in Cubical Agda.

</details>


### [3] [SV-LIB 1.0: A Standard Exchange Format for Software-Verification Tasks](https://arxiv.org/abs/2511.21509)
*Dirk Beyer,Gidon Ernst,Martin Jonáš,Marian Lingsch-Rosenfeld*

Main category: cs.PL

TL;DR: 本文提出了SV-LIB这一统一的软件验证中间语言和交换格式，使得多编程语言之间能更高效地共享验证技术和工具，并解决了证据验证的一致性问题。SV-LIB v1.0现已发布，后续将加强并发和形式语义支持。


<details>
  <summary>Details</summary>
Motivation: 现有的软件验证工具主要针对特定编程语言（如C、C++和Java），但许多验证技术本质上是语言无关的。因此，若能实现工具和技术的跨语言复用，将极大促进技术转移和效率提升。

Method: 提出SV-LIB，一种面向软件验证任务的中间交换格式与语言，涵盖程序、规范和验证证据。SV-LIB以命令式编程语言的通用概念为基础，并利用SMT-LIB表达程序中的表达式和类型；此外，还规定了正确与不正确程序的证据格式，以及证据验证任务规范。

Result: SV-LIB易于解析，并可无缝集成到现有的验证工具基础设施中，尤其是依赖SMT求解器的工具。它支持独立的证据验证器开发，实现验证工具和验证器的复用。文中发布了SV-LIB v1.0，包括设计目标、语法和非正式语义，未来将扩展形式语义和并发支持。

Conclusion: SV-LIB作为统一的软件验证中间语言格式，促进了不同语言和工具间的技术交流和验证资源复用。该格式的进一步扩展和标准化有望提升整个软件验证领域的效率和拓展性。

Abstract: In the past two decades, significant research and development effort went into the development of verification tools for individual languages, such asC, C++, and Java. Many of the used verification approaches are in fact language-agnostic and it would be beneficial for the technology transfer to allow for using the implementations also for other programming and modeling languages. To address the problem, we propose SV-LIB, an exchange format and intermediate language for software-verification tasks, including programs, specifications, and verification witnesses. SV-LIBis based on well-known concepts from imperative programming languages and uses SMT-LIB to represent expressions and sorts used in the program. This makes it easy to parse and to build into existing infrastructure, since many verification tools are based on SMT solvers already. Furthermore, SV-LIBdefines a witness format for both correct and incorrect SV-LIB programs, together with means for specifying witness-validation tasks. This makes it possible both to implement independent witness validators and to reuse some verifiers also as validators for witnesses. This paper presents version 1.0 of the SV-LIBformat, including its design goals, the syntax, and informal semantics. Formal semantics and further extensions to concurrency are planned for future versions.

</details>

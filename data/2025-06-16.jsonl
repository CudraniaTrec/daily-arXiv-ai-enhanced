{"id": "2506.11017", "categories": ["cs.CL", "cs.AI", "cs.PF"], "pdf": "https://arxiv.org/pdf/2506.11017", "abs": "https://arxiv.org/abs/2506.11017", "authors": ["Yanyan Wang", "Yingying Wang", "Junli Liang", "Yin Xu", "Yunlong Liu", "Yiming Xu", "Zhengwang Jiang", "Zhehe Li", "Fei Li", "Long Zhao", "Kuang Xu", "Qi Song", "Xiangyang Li"], "title": "TeleEval-OS: Performance evaluations of large language models for operations scheduling", "comment": null, "summary": "The rapid advancement of large language models (LLMs) has significantly\npropelled progress in artificial intelligence, demonstrating substantial\napplication potential across multiple specialized domains. Telecommunications\noperation scheduling (OS) is a critical aspect of the telecommunications\nindustry, involving the coordinated management of networks, services, risks,\nand human resources to optimize production scheduling and ensure unified\nservice control. However, the inherent complexity and domain-specific nature of\nOS tasks, coupled with the absence of comprehensive evaluation benchmarks, have\nhindered thorough exploration of LLMs' application potential in this critical\nfield. To address this research gap, we propose the first Telecommunications\nOperation Scheduling Evaluation Benchmark (TeleEval-OS). Specifically, this\nbenchmark comprises 15 datasets across 13 subtasks, comprehensively simulating\nfour key operational stages: intelligent ticket creation, intelligent ticket\nhandling, intelligent ticket closure, and intelligent evaluation. To\nsystematically assess the performance of LLMs on tasks of varying complexity,\nwe categorize their capabilities in telecommunications operation scheduling\ninto four hierarchical levels, arranged in ascending order of difficulty: basic\nNLP, knowledge Q&A, report generation, and report analysis. On TeleEval-OS, we\nleverage zero-shot and few-shot evaluation methods to comprehensively assess 10\nopen-source LLMs (e.g., DeepSeek-V3) and 4 closed-source LLMs (e.g., GPT-4o)\nacross diverse scenarios. Experimental results demonstrate that open-source\nLLMs can outperform closed-source LLMs in specific scenarios, highlighting\ntheir significant potential and value in the field of telecommunications\noperation scheduling."}
{"id": "2506.11063", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11063", "abs": "https://arxiv.org/abs/2506.11063", "authors": ["Jiayu Yao", "Shenghua Liu", "Yiwei Wang", "Lingrui Mei", "Baolong Bi", "Yuyao Ge", "Zhecheng Li", "Xueqi Cheng"], "title": "Who is in the Spotlight: The Hidden Bias Undermining Multimodal Retrieval-Augmented Generation", "comment": null, "summary": "Multimodal Retrieval-Augmented Generation (RAG) systems have become essential\nin knowledge-intensive and open-domain tasks. As retrieval complexity\nincreases, ensuring the robustness of these systems is critical. However,\ncurrent RAG models are highly sensitive to the order in which evidence is\npresented, often resulting in unstable performance and biased reasoning,\nparticularly as the number of retrieved items or modality diversity grows. This\nraises a central question: How does the position of retrieved evidence affect\nmultimodal RAG performance? To answer this, we present the first comprehensive\nstudy of position bias in multimodal RAG systems. Through controlled\nexperiments across text-only, image-only, and mixed-modality tasks, we observe\na consistent U-shaped accuracy curve with respect to evidence position. To\nquantify this bias, we introduce the Position Sensitivity Index ($PSI_p$) and\ndevelop a visualization framework to trace attention allocation patterns across\ndecoder layers. Our results reveal that multimodal interactions intensify\nposition bias compared to unimodal settings, and that this bias increases\nlogarithmically with retrieval range. These findings offer both theoretical and\nempirical foundations for position-aware analysis in RAG, highlighting the need\nfor evidence reordering or debiasing strategies to build more reliable and\nequitable generation systems."}
{"id": "2506.11065", "categories": ["cs.CL", "Primary 68T50, Secondary 68T05, 91F20", "I.2.7; I.2.6; I.5.4"], "pdf": "https://arxiv.org/pdf/2506.11065", "abs": "https://arxiv.org/abs/2506.11065", "authors": ["Alexey Tikhonov", "Sergei Shteiner", "Anna Bykova", "Ivan P. Yamshchikov"], "title": "Smotrom tvoja pa ander drogoj verden! Resurrecting Dead Pidgin with Generative Models: Russenorsk Case Study", "comment": "ACL Findings 2025", "summary": "Russenorsk, a pidgin language historically used in trade interactions between\nRussian and Norwegian speakers, represents a unique linguistic phenomenon. In\nthis paper, we attempt to analyze its lexicon using modern large language\nmodels (LLMs), based on surviving literary sources. We construct a structured\ndictionary of the language, grouped by synonyms and word origins. Subsequently,\nwe use this dictionary to formulate hypotheses about the core principles of\nword formation and grammatical structure in Russenorsk and show which\nhypotheses generated by large language models correspond to the hypotheses\npreviously proposed ones in the academic literature. We also develop a\n\"reconstruction\" translation agent that generates hypothetical Russenorsk\nrenderings of contemporary Russian and Norwegian texts."}
{"id": "2506.11067", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11067", "abs": "https://arxiv.org/abs/2506.11067", "authors": ["Hieu Nghiem", "Hemanth Reddy Singareddy", "Zhuqi Miao", "Jivan Lamichhane", "Abdulaziz Ahmed", "Johnson Thomas", "Dursun Delen", "William Paiva"], "title": "A Large Language Model Based Pipeline for Review of Systems Entity Recognition from Clinical Notes", "comment": null, "summary": "Objective: Develop a cost-effective, large language model (LLM)-based\npipeline for automatically extracting Review of Systems (ROS) entities from\nclinical notes. Materials and Methods: The pipeline extracts ROS sections using\nSecTag, followed by few-shot LLMs to identify ROS entity spans, their\npositive/negative status, and associated body systems. We implemented the\npipeline using open-source LLMs (Mistral, Llama, Gemma) and ChatGPT. The\nevaluation was conducted on 36 general medicine notes containing 341 annotated\nROS entities. Results: When integrating ChatGPT, the pipeline achieved the\nlowest error rates in detecting ROS entity spans and their corresponding\nstatuses/systems (28.2% and 14.5%, respectively). Open-source LLMs enable\nlocal, cost-efficient execution of the pipeline while delivering promising\nperformance with similarly low error rates (span: 30.5-36.7%; status/system:\n24.3-27.3%). Discussion and Conclusion: Our pipeline offers a scalable and\nlocally deployable solution to reduce ROS documentation burden. Open-source\nLLMs present a viable alternative to commercial models in resource-limited\nhealthcare environments."}
{"id": "2506.10984", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.10984", "abs": "https://arxiv.org/abs/2506.10984", "authors": ["Ahilan Ayyachamy Nadar Ponnusamy"], "title": "Application Modernization with LLMs: Addressing Core Challenges in Reliability, Security, and Quality", "comment": null, "summary": "AI-assisted code generation tools have revolutionized software development,\noffering unprecedented efficiency and scalability. However, multiple studies\nhave consistently highlighted challenges such as security vulnerabilities,\nreliability issues, and inconsistencies in the generated code. Addressing these\nconcerns is crucial to unlocking the full potential of this transformative\ntechnology. While advancements in foundational and code-specialized language\nmodels have made notable progress in mitigating some of these issues,\nsignificant gaps remain, particularly in ensuring high-quality, trustworthy\noutputs.\n  This paper builds upon existing research on leveraging large language models\n(LLMs) for application modernization. It explores an opinionated approach that\nemphasizes two core capabilities of LLMs: code reasoning and code generation.\nThe proposed framework integrates these capabilities with human expertise to\ntackle application modernization challenges effectively. It highlights the\nindispensable role of human involvement and guidance in ensuring the success of\nAI-assisted processes.\n  To demonstrate the framework's utility, this paper presents a detailed case\nstudy, walking through its application in a real-world scenario. The analysis\nincludes a step-by-step breakdown, assessing alternative approaches where\napplicable. This work aims to provide actionable insights and a robust\nfoundation for future research in AI-driven application modernization. The\nreference implementation created for this paper is available on GitHub."}
{"id": "2506.11334", "categories": ["cs.FL"], "pdf": "https://arxiv.org/pdf/2506.11334", "abs": "https://arxiv.org/abs/2506.11334", "authors": ["Luc Dartois", "Paul Gastin", "L. Germerie Guizouarn", "Shankaranarayanan Krishna"], "title": "Reversible Pebble Transducers", "comment": null, "summary": "Deterministic two-way transducers with pebbles (aka pebble transducers)\ncapture the class of polyregular functions, which extend the string-to-string\nregular functions allowing polynomial growth instead of linear growth. One of\nthe most fundamental operations on functions is composition, and (poly)regular\nfunctions can be realized as a composition of several simpler functions. In\ngeneral, composition of deterministic two-way transducers incur a doubly\nexponential blow-up in the size of the inputs. A major improvement in this\ndirection comes from the fundamental result of Dartois et al. [10] showing a\npolynomial construction for the composition of reversible two-way transducers.\nA precise complexity analysis for existing composition techniques of pebble\ntransducers is missing. But they rely on the classic composition of two-way\ntransducers and inherit the double exponential complexity. To overcome this\nproblem, we introduce reversible pebble transducers. Our main results are\nefficient uniformization techniques for non-deterministic pebble transducers to\nreversible ones and efficient composition for reversible pebble transducers."}
{"id": "2506.11662", "categories": ["cs.DM"], "pdf": "https://arxiv.org/pdf/2506.11662", "abs": "https://arxiv.org/abs/2506.11662", "authors": ["Artem Kaznatcheev", "Sofia Vazquez Alferez"], "title": "Greed is slow on sparse graphs of oriented valued constraints", "comment": "13 pages, to appear at CP2025", "summary": "Greedy local search is especially popular for solving valued constraint\nsatisfaction problems (VCSPs). Since any method will be slow for some VCSPs, we\nask: what is the simplest VCSP on which greedy local search is slow? We\nconstruct a VCSP on 6n Boolean variables for which greedy local search takes\n7(2^n - 1) steps to find the unique peak. Our VCSP is simple in two ways.\nFirst, it is very sparse: its constraint graph has pathwidth 2 and maximum\ndegree 3. This is the simplest VCSP on which some local search could be slow.\nSecond, it is \"oriented\" - there is an ordering on the variables such that\nlater variables are conditionally-independent of earlier ones. Being oriented\nallows many non-greedy local search methods to find the unique peak in a\nquadratic number of steps. Thus, we conclude that - among local search methods\n- greed is particularly slow."}
{"id": "2506.11517", "categories": ["cs.LO", "68Q85", "F.1.1; D.2.4; F.3.1"], "pdf": "https://arxiv.org/pdf/2506.11517", "abs": "https://arxiv.org/abs/2506.11517", "authors": ["Roberto Gorrieri", "Ivan Lanese"], "title": "Decidable Reversible Equivalences for Finite Petri Nets", "comment": "arXiv admin note: text overlap with arXiv:2305.04222", "summary": "In the setting of Petri nets, we prove that {\\em causal-net bisimilarity}\n\\cite{G15,Gor22,Gor25a}, which is a refinement of history-preserving\nbisimilarity \\cite{RT88,vGG89,DDM89}, and the novel {\\em hereditary} causal-net\nbisimilarity, which is a refinement of hereditary history-preserving\nbisimilarity \\cite{Bed91,JNW96}, do coincide. This means that causal-net\nbisimilarity is a {\\em reversible behavioral equivalence}, as causal-net\nbisimilar markings not only are able to match each other's forward transitions,\nbut also backward transitions by undoing performed events. Causal-net\nbisimilarity can be equivalently formulated as {\\em structure-preserving\nbisimilarity} \\cite{G15,Gor25a}, that is decidable on finite bounded Petri nets\n\\cite{CG21a}. Moreover, place bisimilarity \\cite{ABS91}, that we prove to be\nfiner than causal-net bisimilarity, is also reversible and it was proved\ndecidable for finite Petri nets in \\cite{Gor21decid,Gor25a}. These results\noffer two decidable reversible behavioral equivalences in the true concurrency\nspectrum, which are alternative to the coarser hereditary history-preserving\nbisimilarity \\cite{Bed91,JNW96}, that, unfortunately, is undecidable even for\nsafe Petri nets \\cite{JNS03}."}
{"id": "2506.11068", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11068", "abs": "https://arxiv.org/abs/2506.11068", "authors": ["Bumjin Park", "Jinsil Lee", "Jaesik Choi"], "title": "Deontological Keyword Bias: The Impact of Modal Expressions on Normative Judgments of Language Models", "comment": "20 pages including references and appendix; To appear in ACL 2025\n  main conference", "summary": "Large language models (LLMs) are increasingly engaging in moral and ethical\nreasoning, where criteria for judgment are often unclear, even for humans.\nWhile LLM alignment studies cover many areas, one important yet underexplored\narea is how LLMs make judgments about obligations. This work reveals a strong\ntendency in LLMs to judge non-obligatory contexts as obligations when prompts\nare augmented with modal expressions such as must or ought to. We introduce\nthis phenomenon as Deontological Keyword Bias (DKB). We find that LLMs judge\nover 90\\% of commonsense scenarios as obligations when modal expressions are\npresent. This tendency is consist across various LLM families, question types,\nand answer formats. To mitigate DKB, we propose a judgment strategy that\nintegrates few-shot examples with reasoning prompts. This study sheds light on\nhow modal expressions, as a form of linguistic framing, influence the normative\ndecisions of LLMs and underscores the importance of addressing such biases to\nensure judgment alignment."}
{"id": "2506.10985", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.10985", "abs": "https://arxiv.org/abs/2506.10985", "authors": ["Raman Mohammed Hussein", "Bryar A. Hassan"], "title": "Collaboration Tools and their Role in Agile Software Projects", "comment": "https://www.middleeastconference.org/_files/ugd/614b1f_82fa5f91169a44278723a921b27e2864.pdf\n  ISBN: 979-8-89695-015-8", "summary": "The purpose of this review is to understand the importance of collaboration\ntools which are Slack, Microsoft Teams, Confluence in Agile and software\nprojects. Agile methodologies rely on flexibility, using cycles and integration\nthroughout various levels of developing cycles. However, it is still a great\nproblem for many teams to collaborate and communicate even if staff members and\nteams are working remotely. In terms of collaboration, the applications and\ntechnologies mean better organization of work, increased mutually\nunderstandable openness and fast and efficient inter team and interpersonal\ninteractions to enhance results of projects into productivity. This paper\nexamines how these tools fit the Agile principles, how they facilitate\niterative development, and encouraging effective initiation and tracking of\ntasks in small and large projects. The insights focus on how Slack, Microsoft\nTeams, and Confluence are essential for gaining better task coordination,\nsupporting knowledge sharing, and adopting agile values across cross-functional\ncontexts."}
{"id": "2410.04194", "categories": ["cs.CL", "cs.FL"], "pdf": "https://arxiv.org/pdf/2410.04194", "abs": "https://arxiv.org/abs/2410.04194", "authors": ["Lan Zhang", "Xin Quan", "Andre Freitas"], "title": "Consistent Autoformalization for Constructing Mathematical Libraries", "comment": "EMNLP 2024 camera-ready", "summary": "Autoformalization is the task of automatically translating mathematical\ncontent written in natural language to a formal language expression. The\ngrowing language interpretation capabilities of Large Language Models (LLMs),\nincluding in formal languages, are lowering the barriers for autoformalization.\nHowever, LLMs alone are not capable of consistently and reliably delivering\nautoformalization, in particular as the complexity and specialization of the\ntarget domain grows. As the field evolves into the direction of systematically\napplying autoformalization towards large mathematical libraries, the need to\nimprove syntactic, terminological and semantic control increases. This paper\nproposes the coordinated use of three mechanisms, most-similar retrieval\naugmented generation (MS-RAG), denoising steps, and auto-correction with syntax\nerror feedback (Auto-SEF) to improve autoformalization quality. The empirical\nanalysis, across different models, demonstrates that these mechanisms can\ndeliver autoformalizaton results which are syntactically, terminologically and\nsemantically more consistent. These mechanisms can be applied across different\nLLMs and have shown to deliver improve results across different model types."}
{"id": "2506.11176", "categories": ["cs.SE", "cs.DC", "cs.DM", "cs.ET"], "pdf": "https://arxiv.org/pdf/2506.11176", "abs": "https://arxiv.org/abs/2506.11176", "authors": ["Anatoly A. Krasnovsky", "Alexander Zorkin"], "title": "Model Discovery and Graph Simulation: A Lightweight Alternative to Chaos Engineering", "comment": null, "summary": "Microservice applications are prone to cascading failures because of dense\ninter-service dependencies. Ensuring resilience usually demands fault-injection\nexperiments in production-like setups. We propose \\textit{model discovery} --\nan automated CI/CD step that extracts a live dependency graph from trace data\n-- and show that this lightweight representation is sufficient for accurate\nresilience prediction. Using the DeathStarBench Social Network, we build the\ngraph, simulate failures via Monte-Carlo, and run matching chaos experiments on\nthe real system. The graph model closely matches reality: with no replication,\n16 trials yield an observed resilience of 0.186 versus a predicted 0.161; with\nreplication, both observed and predicted values converge to 0.305 (mean\nabsolute error \\leq 0.0004). These results indicate that even a simple,\nautomatically discovered graph can estimate microservice availability with high\nfidelity, offering rapid design-time insight without full-scale failure\ntesting."}
{"id": "2506.11085", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.IR", "cs.LG", "cs.LO", "I.2.6; H.3.3; I.2.3"], "pdf": "https://arxiv.org/pdf/2506.11085", "abs": "https://arxiv.org/abs/2506.11085", "authors": ["Justin Asher"], "title": "LeanExplore: A search engine for Lean 4 declarations", "comment": "16 pages, 1 figure. Project website: https://www.leanexplore.com/ ,\n  Code: https://github.com/justincasher/lean-explore", "summary": "The expanding Lean 4 ecosystem poses challenges for navigating its vast\nlibraries. This paper introduces LeanExplore, a search engine for Lean 4\ndeclarations. LeanExplore enables users to semantically search for statements,\nboth formally and informally, across select Lean 4 packages (including\nBatteries, Init, Lean, Mathlib, PhysLean, and Std). This search capability is\npowered by a hybrid ranking strategy, integrating scores from a multi-source\nsemantic embedding model (capturing conceptual meaning from formal Lean code,\ndocstrings, AI-generated informal translations, and declaration titles), BM25+\nfor keyword-based lexical relevance, and a PageRank-based score reflecting\ndeclaration importance and interconnectedness. The search engine is accessible\nvia a dedicated website (https://www.leanexplore.com/) and a Python API\n(https://github.com/justincasher/lean-explore). Furthermore, the database can\nbe downloaded, allowing users to self-host the service. LeanExplore integrates\neasily with LLMs via the model context protocol (MCP), enabling users to chat\nwith an AI assistant about Lean declarations or utilize the search engine for\nbuilding theorem-proving agents. This work details LeanExplore's architecture,\ndata processing, functionalities, and its potential to enhance Lean 4 workflows\nand AI-driven mathematical research"}
{"id": "2506.11209", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2506.11209", "abs": "https://arxiv.org/abs/2506.11209", "authors": ["Zhengyang Liu", "Vinod Grover"], "title": "A Performance Model for Warp Specialization Kernels", "comment": null, "summary": "This paper presents a performance model tailored for warp specialization\nkernels, focusing on factors such as warp size, tilling size, input matrix\nsize, memory bandwidth, and thread divergence. Our model offers accurate\npredictions of execution time by leveraging differential equations validated\nthrough simulations and experiments. The insights gained from this model not\nonly enhance our understanding of warp specialization techniques but also have\npractical implications for optimizing GPU-accelerated applications through\ncompiler optimizations, kernel parameter tuning, and algorithm design."}
{"id": "2506.11070", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11070", "abs": "https://arxiv.org/abs/2506.11070", "authors": ["Yu-Zhe Shi", "Mingchen Liu", "Hanlu Ma", "Qiao Xu", "Huamin Qu", "Kun He", "Lecheng Ruan", "Qining Wang"], "title": "Targeted control of fast prototyping through domain-specific interface", "comment": "In International Conference on Machine Learning (ICML'25)", "summary": "Industrial designers have long sought a natural and intuitive way to achieve\nthe targeted control of prototype models -- using simple natural language\ninstructions to configure and adjust the models seamlessly according to their\nintentions, without relying on complex modeling commands. While Large Language\nModels have shown promise in this area, their potential for controlling\nprototype models through language remains partially underutilized. This\nlimitation stems from gaps between designers' languages and modeling languages,\nincluding mismatch in abstraction levels, fluctuation in semantic precision,\nand divergence in lexical scopes. To bridge these gaps, we propose an interface\narchitecture that serves as a medium between the two languages. Grounded in\ndesign principles derived from a systematic investigation of fast prototyping\npractices, we devise the interface's operational mechanism and develop an\nalgorithm for its automated domain specification. Both machine-based\nevaluations and human studies on fast prototyping across various product design\ndomains demonstrate the interface's potential to function as an auxiliary\nmodule for Large Language Models, enabling precise and effective targeted\ncontrol of prototype models."}
{"id": "2506.10986", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.10986", "abs": "https://arxiv.org/abs/2506.10986", "authors": ["Mouna Dhaouadi", "Bentley James Oakes", "Michalis Famelis"], "title": "CoMRAT: Commit Message Rationale Analysis Tool", "comment": null, "summary": "In collaborative open-source development, the rationale for code changes is\noften captured in commit messages, making them a rich source of valuable\ninformation. However, research on rationale in commit messages remains limited.\nIn this paper, we present CoMRAT, a tool for analyzing decision and rationale\nsentences rationale in commit messages. CoMRAT enables a) researchers to\nproduce metrics and analyses on rationale information in any Github module, and\nb) developers to check the amount of rationale in their commit messages. A\npreliminary evaluation suggests the tool's usefulness and usability in both\nthese research and development contexts."}
{"id": "2506.10993", "categories": ["cs.SE", "cs.FL", "68N30, 68Q60", "D.2.4; D.2.1; F.3.1"], "pdf": "https://arxiv.org/pdf/2506.10993", "abs": "https://arxiv.org/abs/2506.10993", "authors": ["Muhammad Naeem", "Cristina Seceleanu"], "title": "Contract-based Verification of Digital Twins", "comment": "Accepted at ICECCS 2025, to appear in Lecture Notes in Computer\n  Science (LNCS), Springer", "summary": "Digital twins are becoming powerful tools in industrial applications,\noffering virtual representations of cyber-physical systems. However,\nverification of these models remains a significant challenge due to the\npotentially large datasets used by the digital twin. This paper introduces an\ninnovative methodology for verifying neural network-based digital twin models,\nin a black-box fashion, by integrating model checking into the process. The\nlatter relies on defining and applying system-level contracts that capture the\nsystem's requirements, to verify the behavior of digital twin models,\nimplemented in Simulink. We develop an automated solution that simulates the\ndigital twin model for certain inputs, and feeds the predicted outputs together\nwith the inputs to the contract model described as a network of timed automata\nin the UPPAAL model checker. The latter verifies whether the predicted outputs\nfulfill the specified contracts. This approach allows us to identify scenarios\nwhere the digital twin's behavior fails to meet the contracts, without\nrequiring the digital twin's design technicalities. We apply our method to a\nboiler system case study for which we identify prediction errors via contract\nverification. Our work demonstrates the effectiveness of integrating model\nchecking with digital twin models for continuous improvement."}
{"id": "2506.11701", "categories": ["cs.PL", "cs.CR"], "pdf": "https://arxiv.org/pdf/2506.11701", "abs": "https://arxiv.org/abs/2506.11701", "authors": ["Lukas Gehring", "Sebastian Rehms", "Florian Tschorsch"], "title": "PermRust: A Token-based Permission System for Rust", "comment": "11 pages", "summary": "Permission systems which restrict access to system resources are a\nwell-established technology in operating systems, especially for smartphones.\nHowever, as such systems are implemented in the operating system they can at\nmost manage access on the process-level. Since moderns software often (re)uses\ncode from third-parties libraries, a permission system for libraries can be\ndesirable to enhance security. In this short-paper, we adapt concepts from\ncapability systems building a novel theoretical foundation for permission\nsystem at the level of the programming language. This leads to PermRust, a\ntoken-based permission system for the Rust programming language as a zero cost\nabstraction on top of its type-system. With it access to system resources can\nbe managed per library."}
{"id": "2506.11073", "categories": ["cs.CL", "cs.AI", "cs.CV"], "pdf": "https://arxiv.org/pdf/2506.11073", "abs": "https://arxiv.org/abs/2506.11073", "authors": ["Zekai Ye", "Qiming Li", "Xiaocheng Feng", "Libo Qin", "Yichong Huang", "Baohang Li", "Kui Jiang", "Yang Xiang", "Zhirui Zhang", "Yunfei Lu", "Duyu Tang", "Dandan Tu", "Bing Qin"], "title": "CLAIM: Mitigating Multilingual Object Hallucination in Large Vision-Language Models with Cross-Lingual Attention Intervention", "comment": "ACL2025 Main", "summary": "Large Vision-Language Models (LVLMs) have demonstrated impressive multimodal\nabilities but remain prone to multilingual object hallucination, with a higher\nlikelihood of generating responses inconsistent with the visual input when\nutilizing queries in non-English languages compared to English. Most existing\napproaches to address these rely on pretraining or fine-tuning, which are\nresource-intensive. In this paper, inspired by observing the disparities in\ncross-modal attention patterns across languages, we propose Cross-Lingual\nAttention Intervention for Mitigating multilingual object hallucination (CLAIM)\nin LVLMs, a novel near training-free method by aligning attention patterns.\nCLAIM first identifies language-specific cross-modal attention heads, then\nestimates language shift vectors from English to the target language, and\nfinally intervenes in the attention outputs during inference to facilitate\ncross-lingual visual perception capability alignment. Extensive experiments\ndemonstrate that CLAIM achieves an average improvement of 13.56% (up to 30% in\nSpanish) on the POPE and 21.75% on the hallucination subsets of the MME\nbenchmark across various languages. Further analysis reveals that multilingual\nattention divergence is most prominent in intermediate layers, highlighting\ntheir critical role in multilingual scenarios."}
{"id": "2506.10987", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.10987", "abs": "https://arxiv.org/abs/2506.10987", "authors": ["Shaoyi Yang"], "title": "Chain of Draft for Software Engineering: Challenges in Applying Concise Reasoning to Code Tasks", "comment": null, "summary": "Large language models (LLMs) have become vital tools for software\ndevelopment, but they often require verbose intermediate reasoning for complex\ncode tasks, leading to high latency and costs. This research extends the Chain\nof Draft (CoD) method to software engineering, designing and evaluating\nmultiple CoD variants tailored for code tasks. Through comprehensive\nexperiments on all 300 samples from the SWE-bench benchmark, we found that all\nCoD variants used significantly fewer tokens than Chain of Thought (CoT), with\nBaseline CoD being most efficient at 55.4% of CoT's tokens. While this\nrepresents substantial efficiency gains - translating to approximately 45%\nreduction in processing time and API costs - it differs from the extreme 7.6%\nreported in the original CoD paper for mathematical reasoning. This difference\nstems from the inherent complexity and context-dependency of software tasks,\nwhich require more detailed reasoning to maintain solution quality. Our\nmulti-dimensional quality assessment revealed that CoD variants maintain over\n90% of CoT's code quality across key metrics including correctness,\ncompatibility, and maintainability, making them practical alternatives for\nreal-world development scenarios where efficiency matters. This research\ndemonstrates how domain-specific characteristics influence prompting strategy\neffectiveness and provides a framework for balancing efficiency with solution\nquality in software engineering applications. Our findings offer practical\nguidance for optimizing LLM-based development workflows through appropriate\nprompting strategy selection based on project requirements."}
{"id": "2506.11794", "categories": ["cs.PL", "math.PR"], "pdf": "https://arxiv.org/pdf/2506.11794", "abs": "https://arxiv.org/abs/2506.11794", "authors": ["Baltasar Trancón y Widemann", "Markus Lepper"], "title": "ALEA IACTA EST: A Declarative Domain-Specific Language for Manually Performable Random Experiments", "comment": null, "summary": "Random experiments that are simple and clear enough to be performed by human\nagents feature prominently in the teaching of elementary stochastics as well as\nin games. We present Alea, a domain-specific language for the specification of\nrandom experiments. Alea code can either be analyzed statically to obtain and\ninspect probability distributions of outcomes, or be executed with a source\npseudo-randomness for simulation or as a game assistant. The language is\nintended for ease of use by non-expert programmers, in particular students of\nelementary stochastics, and players and designers of games of chance, by\nfocusing on concepts common to functional programming and basic mathematics.\nBoth the design of the language and the implementation of runtime environments\nare work in progress."}
{"id": "2506.11077", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11077", "abs": "https://arxiv.org/abs/2506.11077", "authors": ["Chongyu Fan", "Yihua Zhang", "Jinghan Jia", "Alfred Hero", "Sijia Liu"], "title": "CyclicReflex: Improving Large Reasoning Models via Cyclical Reflection Token Scheduling", "comment": null, "summary": "Large reasoning models (LRMs), such as OpenAI's o1 and DeepSeek-R1, harness\ntest-time scaling to perform multi-step reasoning for complex problem-solving.\nThis reasoning process, executed before producing final answers, is often\nguided by special juncture tokens or textual segments that prompt\nself-evaluative reflection. We refer to these transition markers and reflective\ncues as \"reflection tokens\" (e.g., \"wait\", \"but\", \"alternatively\"). In this\nwork, we treat reflection tokens as a \"resource\" and introduce the problem of\nresource allocation, aimed at improving the test-time compute performance of\nLRMs by adaptively regulating the frequency and placement of reflection tokens.\nThrough empirical analysis, we show that both excessive and insufficient use of\nreflection tokens, referred to as over-reflection and under-reflection, can\ndegrade model performance. To better understand and manage this trade-off, we\ndraw an analogy between reflection token usage and learning rate scheduling in\noptimization. Building on this insight, we propose cyclical reflection token\nscheduling (termed CyclicReflex), a decoding strategy that dynamically\nmodulates reflection token logits using a position-dependent triangular\nwaveform. Experiments on MATH500, AIME2024/2025, and AMC2023 demonstrate that\nCyclicReflex consistently improves performance across model sizes (1.5B-8B),\noutperforming standard decoding and more recent approaches such as TIP (thought\nswitching penalty) and S1. Codes are available at\nhttps://github.com/OPTML-Group/CyclicReflex."}
{"id": "2506.10988", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.10988", "abs": "https://arxiv.org/abs/2506.10988", "authors": ["Bowen Tian", "Zhengyang Xu", "Mingqiang Wu", "Songning Lai", "Yutai Yue"], "title": "You Only Train Once: A Flexible Training Framework for Code Vulnerability Detection Driven by Vul-Vector", "comment": "Under Review", "summary": "With the pervasive integration of computer applications across industries,\nthe presence of vulnerabilities within code bases poses significant risks. The\ndiversity of software ecosystems coupled with the intricate nature of modern\nsoftware engineering has led to a shift from manual code vulnerability\nidentification towards the adoption of automated tools. Among these, deep\nlearning-based approaches have risen to prominence due to their superior\naccuracy; however, these methodologies encounter several obstacles. Primarily,\nthey necessitate extensive labeled datasets and prolonged training periods, and\ngiven the rapid emergence of new vulnerabilities, the frequent retraining of\nmodels becomes a resource-intensive endeavor, thereby limiting their\napplicability in cutting-edge scenarios. To mitigate these challenges, this\npaper introduces the \\underline{\\textbf{YOTO}}--\\underline{\\textbf{Y}}ou\n\\underline{\\textbf{O}}nly \\underline{\\textbf{T}}rain \\underline{\\textbf{O}}nce\nframework. This innovative approach facilitates the integration of multiple\ntypes of vulnerability detection models via parameter fusion, eliminating the\nneed for joint training. Consequently, YOTO enables swift adaptation to newly\ndiscovered vulnerabilities, significantly reducing both the time and\ncomputational resources required for model updates."}
{"id": "2506.11078", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11078", "abs": "https://arxiv.org/abs/2506.11078", "authors": ["Yuzhou Yang", "Yangming Zhou", "Zhiying Zhu", "Zhenxing Qian", "Xinpeng Zhang", "Sheng Li"], "title": "RoE-FND: A Case-Based Reasoning Approach with Dual Verification for Fake News Detection via LLMs", "comment": null, "summary": "The proliferation of deceptive content online necessitates robust Fake News\nDetection (FND) systems. While evidence-based approaches leverage external\nknowledge to verify claims, existing methods face critical limitations: noisy\nevidence selection, generalization bottlenecks, and unclear decision-making\nprocesses. Recent efforts to harness Large Language Models (LLMs) for FND\nintroduce new challenges, including hallucinated rationales and conclusion\nbias. To address these issues, we propose \\textbf{RoE-FND}\n(\\textbf{\\underline{R}}eason \\textbf{\\underline{o}}n\n\\textbf{\\underline{E}}xperiences FND), a framework that reframes evidence-based\nFND as a logical deduction task by synergizing LLMs with experiential learning.\nRoE-FND encompasses two stages: (1) \\textit{self-reflective knowledge\nbuilding}, where a knowledge base is curated by analyzing past reasoning\nerrors, namely the exploration stage, and (2) \\textit{dynamic criterion\nretrieval}, which synthesizes task-specific reasoning guidelines from\nhistorical cases as experiences during deployment. It further cross-checks\nrationales against internal experience through a devised dual-channel\nprocedure. Key contributions include: a case-based reasoning framework for FND\nthat addresses multiple existing challenges, a training-free approach enabling\nadaptation to evolving situations, and empirical validation of the framework's\nsuperior generalization and effectiveness over state-of-the-art methods across\nthree datasets."}
{"id": "2506.10989", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.10989", "abs": "https://arxiv.org/abs/2506.10989", "authors": ["Rogelio Cruz", "Jonatan Contreras", "Francisco Guerrero", "Ezequiel Rodriguez", "Carlos Valdez", "Citlali Carrillo"], "title": "Prompt engineering and framework: implementation to increase code reliability based guideline for LLMs", "comment": null, "summary": "In this paper, we propose a novel prompting approach aimed at enhancing the\nability of Large Language Models (LLMs) to generate accurate Python code.\nSpecifically, we introduce a prompt template designed to improve the quality\nand correctness of generated code snippets, enabling them to pass tests and\nproduce reliable results. Through experiments conducted on two state-of-the-art\nLLMs using the HumanEval dataset, we demonstrate that our approach outperforms\nwidely studied zero-shot and Chain-of-Thought (CoT) methods in terms of the\nPass@k metric. Furthermore, our method achieves these improvements with\nsignificantly reduced token usage compared to the CoT approach, making it both\neffective and resource-efficient, thereby lowering the computational demands\nand improving the eco-footprint of LLM capabilities. These findings highlight\nthe potential of tailored prompting strategies to optimize code generation\nperformance, paving the way for broader applications in AI-driven programming\ntasks."}
{"id": "2506.11080", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11080", "abs": "https://arxiv.org/abs/2506.11080", "authors": ["Han Zhou", "Qitong Xu", "Yiheng Dong", "Xin Yang"], "title": "MANBench: Is Your Multimodal Model Smarter than Human?", "comment": "Multimodal Benchmark, Project Url: https://github.com/micdz/MANBench,\n  ACL2025 Findings", "summary": "The rapid advancement of Multimodal Large Language Models (MLLMs) has ignited\ndiscussions regarding their potential to surpass human performance in\nmultimodal tasks. In response, we introduce MANBench (Multimodal Ability Norms\nBenchmark), a bilingual benchmark (English and Chinese) comprising 1,314\nquestions across nine tasks, spanning knowledge-based and non-knowledge-based\ndomains. MANBench emphasizes intuitive reasoning, seamless cross-modal\nintegration, and real-world complexity, providing a rigorous evaluation\nframework.\n  Through extensive human experiments involving diverse participants, we\ncompared human performance against state-of-the-art MLLMs. The results indicate\nthat while MLLMs excel in tasks like Knowledge and Text-Image Understanding,\nthey struggle with deeper cross-modal reasoning tasks such as Transmorphic\nUnderstanding, Image Consistency, and Multi-image Understanding. Moreover, both\nhumans and MLLMs face challenges in highly complex tasks like Puzzles and\nSpatial Imagination.\n  MANBench highlights the strengths and limitations of MLLMs, revealing that\neven advanced models fall short of achieving human-level performance across\nmany domains. We hope MANBench will inspire efforts to bridge the gap between\nMLLMs and human multimodal capabilities. The code and dataset are available at\nhttps://github.com/micdz/MANBench."}
{"id": "2506.10990", "categories": ["cs.SE", "cs.AI", "cs.CE", "cs.DC", "I.2.0"], "pdf": "https://arxiv.org/pdf/2506.10990", "abs": "https://arxiv.org/abs/2506.10990", "authors": ["Roberto Vergallo", "Luís Cruz", "Alessio Errico", "Luca Mainetti"], "title": "On the Effectiveness of the 'Follow-the-Sun' Strategy in Mitigating the Carbon Footprint of AI in Cloud Instances", "comment": "24 pages, 4 figures, 10 tables", "summary": "'Follow-the-Sun' (FtS) is a theoretical computational model aimed at\nminimizing the carbon footprint of computer workloads. It involves dynamically\nmoving workloads to regions with cleaner energy sources as demand increases and\nenergy production relies more on fossil fuels. With the significant power\nconsumption of Artificial Intelligence (AI) being a subject of extensive\ndebate, FtS is proposed as a strategy to mitigate the carbon footprint of\ntraining AI models. However, the literature lacks scientific evidence on the\nadvantages of FtS to mitigate the carbon footprint of AI workloads. In this\npaper, we present the results of an experiment conducted in a partial synthetic\nscenario to address this research gap. We benchmarked four AI algorithms in the\nanomaly detection domain and measured the differences in carbon emissions in\nfour cases: no strategy, FtS, and two strategies previously introduced in the\nstate of the art, namely Flexible Start and Pause and Resume. To conduct our\nexperiment, we utilized historical carbon intensity data from the year 2021 for\nseven European cities. Our results demonstrate that the FtS strategy not only\nachieves average reductions of up to 14.6% in carbon emissions (with peaks of\n16.3%) but also helps in preserving the time needed for training."}
{"id": "2506.11081", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11081", "abs": "https://arxiv.org/abs/2506.11081", "authors": ["Aditi", "Hyunwoo Park", "Sicheol Sung", "Yo-Sub Han", "Sang-Ki Ko"], "title": "SAGE:Specification-Aware Grammar Extraction for Automated Test Case Generation with LLMs", "comment": null, "summary": "Grammar-based test case generation has proven effective for competitive\nprogramming problems, but generating valid and general grammars from natural\nlanguage specifications remains a key challenge, especially under limited\nsupervision. Context-Free Grammars with Counters (CCFGs) have recently been\nintroduced as a formalism to represent such specifications with logical\nconstraints by storing and reusing counter values during derivation. In this\nwork, we explore the use of open-source large language models (LLMs) to induce\nCCFGs from specifications using a small number of labeled examples and\nverifiable reward-guided reinforcement learning. Our approach first fine-tunes\nan open-source LLM to perform specification-to-grammar translation, and further\napplies Group Relative Policy Optimization (GRPO) to enhance grammar validity\nand generality. We also examine the effectiveness of iterative feedback for\nopen and closed-source LLMs in correcting syntactic and semantic errors in\ngenerated grammars.\n  Experimental results show that our approach SAGE achieves stronger\ngeneralization and outperforms 17 open and closed-source LLMs in both grammar\nquality and test effectiveness, improving over the state-of-the-art by 15.92%p\nin grammar validity and 12.34%p in test effectiveness. We provide our\nimplementation and dataset at the following anonymous\nrepository:https://anonymous.4open.science/r/SAGE-5714"}
{"id": "2506.10991", "categories": ["cs.SE", "D.2.9; H.4.1"], "pdf": "https://arxiv.org/pdf/2506.10991", "abs": "https://arxiv.org/abs/2506.10991", "authors": ["Hoang Vu", "Henrik Leopold", "Han van der Aa"], "title": "What is Business Process Automation Anyway?", "comment": "Accepted at HICSS 2023", "summary": "Many organizations strive to increase the level of automation in their\nbusiness processes. While automation historically was mainly concerned with\nautomating physical labor, current automation efforts mostly focus on\nautomation in a digital manner, thus targeting work that is related to the\ninteraction between humans and computers. This type of automation, commonly\nreferred to as business process automation, has many facets. Yet, academic\nliterature mainly focuses on Robotic Process Automation, a specific automation\ncapability. Recognizing that leading vendors offer automation capabilities\ngoing way beyond that, we use this paper to develop a detailed understanding of\nbusiness process automation in industry. To this end, we conduct a structured\nmarket analysis of the 18 predominant vendors of business process automation\nsolutions as identified by Gartner. As a result, we provide a comprehensive\noverview of the business process automation capabilities currently offered by\nindustrial vendors. We show which types and facets of automation exist and\nwhich aspects represent promising directions for the future."}
{"id": "2506.11082", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11082", "abs": "https://arxiv.org/abs/2506.11082", "authors": ["Lionel Levine", "John Santerre", "Alex S. Young", "T. Barry Levine", "Francis Campion", "Majid Sarrafzadeh"], "title": "PRISM: A Transformer-based Language Model of Structured Clinical Event Data", "comment": "15 pages, 4 Figures, 1 Table", "summary": "We introduce PRISM (Predictive Reasoning in Sequential Medicine), a\ntransformer-based architecture designed to model the sequential progression of\nclinical decision-making processes. Unlike traditional approaches that rely on\nisolated diagnostic classification, PRISM frames clinical trajectories as\ntokenized sequences of events - including diagnostic tests, laboratory results,\nand diagnoses - and learns to predict the most probable next steps in the\npatient diagnostic journey. Leveraging a large custom clinical vocabulary and\nan autoregressive training objective, PRISM demonstrates the ability to capture\ncomplex dependencies across longitudinal patient timelines. Experimental\nresults show substantial improvements over random baselines in next-token\nprediction tasks, with generated sequences reflecting realistic diagnostic\npathways, laboratory result progressions, and clinician ordering behaviors.\nThese findings highlight the feasibility of applying generative language\nmodeling techniques to structured medical event data, enabling applications in\nclinical decision support, simulation, and education. PRISM establishes a\nfoundation for future advancements in sequence-based healthcare modeling,\nbridging the gap between machine learning architectures and real-world\ndiagnostic reasoning."}
{"id": "2506.10992", "categories": ["cs.SE", "D.2.9"], "pdf": "https://arxiv.org/pdf/2506.10992", "abs": "https://arxiv.org/abs/2506.10992", "authors": ["Hoang Vu", "Jennifer Haase", "Henrik Leopold", "Jan Mendling"], "title": "Towards a Theory on Process Automation Effects", "comment": "Accepted at HICSS 2023", "summary": "Process automation is a crucial strategy for improving business processes,\nbut little attention has been paid to the effects that automation has once it\nis operational. This paper addresses this research problem by reviewing the\nliterature on human-automation interaction. Although many of the studies in\nthis field have been conducted in different domains, they provide a foundation\nfor developing propositions about process automation effects. Our analysis\nfocuses on how humans perceive automation technology when working within a\nprocess, allowing us to propose an effective engagement model between\ntechnology, process participants, process managers, and software developers.\nThis paper offers insights and recommendations that can help organizations\noptimize their use of process automation. We further derive novel research\nquestions for a discourse within the process automation community."}
{"id": "2506.11083", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11083", "abs": "https://arxiv.org/abs/2506.11083", "authors": ["Ali Asad", "Stephen Obadinma", "Radin Shayanfar", "Xiaodan Zhu"], "title": "RedDebate: Safer Responses through Multi-Agent Red Teaming Debates", "comment": null, "summary": "We propose RedDebate, a novel multi-agent debate framework that leverages\nadversarial argumentation among Large Language Models (LLMs) to proactively\nidentify and mitigate their own unsafe behaviours. Existing AI safety methods\noften depend heavily on costly human evaluations or isolated single-model\nassessment, both subject to scalability constraints and oversight risks.\nRedDebate instead embraces collaborative disagreement, enabling multiple LLMs\nto critically examine one another's reasoning, and systematically uncovering\nunsafe blind spots through automated red-teaming, and iteratively improve their\nresponses. We further integrate distinct types of long-term memory that retain\nlearned safety insights from debate interactions. Evaluating on established\nsafety benchmarks such as HarmBench, we demonstrate the proposed method's\neffectiveness. Debate alone can reduce unsafe behaviours by 17.7%, and when\ncombined with long-term memory modules, achieves reductions exceeding 23.5%. To\nour knowledge, RedDebate constitutes the first fully automated framework that\ncombines multi-agent debates with red-teaming to progressively enhance AI\nsafety without direct human intervention.(Github Repository:\nhttps://github.com/aliasad059/RedDebate)"}
{"id": "2506.10993", "categories": ["cs.SE", "cs.FL", "68N30, 68Q60", "D.2.4; D.2.1; F.3.1"], "pdf": "https://arxiv.org/pdf/2506.10993", "abs": "https://arxiv.org/abs/2506.10993", "authors": ["Muhammad Naeem", "Cristina Seceleanu"], "title": "Contract-based Verification of Digital Twins", "comment": "Accepted at ICECCS 2025, to appear in Lecture Notes in Computer\n  Science (LNCS), Springer", "summary": "Digital twins are becoming powerful tools in industrial applications,\noffering virtual representations of cyber-physical systems. However,\nverification of these models remains a significant challenge due to the\npotentially large datasets used by the digital twin. This paper introduces an\ninnovative methodology for verifying neural network-based digital twin models,\nin a black-box fashion, by integrating model checking into the process. The\nlatter relies on defining and applying system-level contracts that capture the\nsystem's requirements, to verify the behavior of digital twin models,\nimplemented in Simulink. We develop an automated solution that simulates the\ndigital twin model for certain inputs, and feeds the predicted outputs together\nwith the inputs to the contract model described as a network of timed automata\nin the UPPAAL model checker. The latter verifies whether the predicted outputs\nfulfill the specified contracts. This approach allows us to identify scenarios\nwhere the digital twin's behavior fails to meet the contracts, without\nrequiring the digital twin's design technicalities. We apply our method to a\nboiler system case study for which we identify prediction errors via contract\nverification. Our work demonstrates the effectiveness of integrating model\nchecking with digital twin models for continuous improvement."}
{"id": "2506.11088", "categories": ["cs.CL", "cs.AI", "68T50"], "pdf": "https://arxiv.org/pdf/2506.11088", "abs": "https://arxiv.org/abs/2506.11088", "authors": ["Pengbo Wang", "Chaozhuo Li", "Chenxu Wang", "Liwen Zheng", "Litian Zhang", "Xi Zhang"], "title": "Two Birds with One Stone: Improving Factuality and Faithfulness of LLMs via Dynamic Interactive Subspace Editing", "comment": null, "summary": "LLMs have demonstrated unprecedented capabilities in natural language\nprocessing, yet their practical deployment remains hindered by persistent\nfactuality and faithfulness hallucinations. While existing methods address\nthese hallucination types independently, they inadvertently induce performance\ntrade-offs, as interventions targeting one type often exacerbate the other.\nThrough empirical and theoretical analysis of activation space dynamics in\nLLMs, we reveal that these hallucination categories share overlapping subspaces\nwithin neural representations, presenting an opportunity for concurrent\nmitigation. To harness this insight, we propose SPACE, a unified framework that\njointly enhances factuality and faithfulness by editing shared activation\nsubspaces. SPACE establishes a geometric foundation for shared subspace\nexistence through dual-task feature modeling, then identifies and edits these\nsubspaces via a hybrid probe strategy combining spectral clustering and\nattention head saliency scoring. Experimental results across multiple benchmark\ndatasets demonstrate the superiority of our approach."}
{"id": "2506.10994", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.10994", "abs": "https://arxiv.org/abs/2506.10994", "authors": ["April Clarke"], "title": "Improving Software Team Communication Through Social Interventions in Project Management Tools", "comment": "ICSE 2025 Doctoral Track. arXiv admin note: substantial text overlap\n  with arXiv:2502.01923", "summary": "Productive software engineering teams require effective communication and\nbalanced contributions between team members. However, teams are often\nineffective at these skills, which is detrimental to project success.\nProject-based university courses are an opportunity for students to practise\nthese skills, but we have yet to establish how we can guide students towards\nimproving their communication and coordination. We aim to develop project\nmanagement tool features, informed by social network analysis, that nudge\nstudents in software engineering group projects towards beneficial behaviours.\nTo do this, we will first evaluate the suitability of social network analysis\ntechniques for identifying areas of improvement in teams' communication. Then,\nwe will develop features in a project management tool that aid students in\nidentifying and addressing these areas of improvement, and evaluate them in the\ncontext of a software engineering group project."}
{"id": "2506.11091", "categories": ["cs.CL", "cs.SD", "eess.AS"], "pdf": "https://arxiv.org/pdf/2506.11091", "abs": "https://arxiv.org/abs/2506.11091", "authors": ["Shaoshi Ling", "Guoli Ye"], "title": "Customizing Speech Recognition Model with Large Language Model Feedback", "comment": null, "summary": "Automatic speech recognition (ASR) systems have achieved strong performance\non general transcription tasks. However, they continue to struggle with\nrecognizing rare named entities and adapting to domain mismatches. In contrast,\nlarge language models (LLMs), trained on massive internet-scale datasets, are\noften more effective across a wide range of domains. In this work, we propose a\nreinforcement learning based approach for unsupervised domain adaptation,\nleveraging unlabeled data to enhance transcription quality, particularly the\nnamed entities affected by domain mismatch, through feedback from a LLM. Given\ncontextual information, our framework employs a LLM as the reward model to\nscore the hypotheses from the ASR model. These scores serve as reward signals\nto fine-tune the ASR model via reinforcement learning. Our method achieves a\n21\\% improvement on entity word error rate over conventional self-training\nmethods."}
{"id": "2506.10995", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.10995", "abs": "https://arxiv.org/abs/2506.10995", "authors": ["Jorge Martinez-Gil"], "title": "Evaluating Small-Scale Code Models for Code Clone Detection", "comment": "20 pages", "summary": "Detecting code clones is relevant to software maintenance and code\nrefactoring. This challenge still presents unresolved cases, mainly when\nstructural similarity does not reflect functional equivalence, though recent\ncode models show promise. Therefore, this research aims to systematically\nmeasure the performance of several newly introduced small code models in\nclassifying code pairs as clones or non-clones. The evaluation is based on five\ndatasets: BigCloneBench, CodeJam, Karnalim, POJ104, and PoolC, as well as six\ncode models: CodeBERT, GraphCodeBERT, Salesforce T5, UniXCoder, PLBART, and\nPolycoder. Most models performed well across standard metrics, including\naccuracy, precision, recall, and F1-score. However, a marginal fraction of\nclones remains challenging to detect, especially when the code looks similar\nbut performs different operations. The source code that illustrates our\napproach is available at:\nhttps://github.com/jorge-martinez-gil/small-code-models"}
{"id": "2506.11092", "categories": ["cs.CL", "cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2506.11092", "abs": "https://arxiv.org/abs/2506.11092", "authors": ["Jubin Abhishek Soni", "Amit Anand", "Rajesh Kumar Pandey", "Aniket Abhishek Soni"], "title": "Dynamic Context Tuning for Retrieval-Augmented Generation: Enhancing Multi-Turn Planning and Tool Adaptation", "comment": "6 pages, 5 figures, 3 tables. This manuscript has been submitted to\n  IEEE conference. Researchers are welcome to read and build upon this work;\n  please cite it appropriately. For questions or clarifications, feel free to\n  contact me", "summary": "Retrieval-Augmented Generation (RAG) has significantly advanced large\nlanguage models (LLMs) by grounding their outputs in external tools and\nknowledge sources. However, existing RAG systems are typically constrained to\nstatic, single-turn interactions with fixed toolsets, making them ill-suited\nfor dynamic domains such as healthcare and smart homes, where user intent,\navailable tools, and contextual factors evolve over time. We present Dynamic\nContext Tuning (DCT), a lightweight framework that extends RAG to support\nmulti-turn dialogue and evolving tool environments without requiring\nretraining. DCT integrates an attention-based context cache to track relevant\npast information, LoRA-based retrieval to dynamically select domain-specific\ntools, and efficient context compression to maintain inputs within LLM context\nlimits. Experiments on both synthetic and real-world benchmarks show that DCT\nimproves plan accuracy by 14% and reduces hallucinations by 37%, while matching\nGPT-4 performance at significantly lower cost. Furthermore, DCT generalizes to\npreviously unseen tools, enabling scalable and adaptable AI assistants across a\nwide range of dynamic environments."}
{"id": "2506.10996", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.10996", "abs": "https://arxiv.org/abs/2506.10996", "authors": ["Saadiq Rauf Khan", "Vinit Chandak", "Sougata Mukherjea"], "title": "Evaluating LLMs for Visualization Tasks", "comment": null, "summary": "Information Visualization has been utilized to gain insights from complex\ndata. In recent times, Large Language Models (LLMs) have performed very well in\nmany tasks. In this paper, we showcase the capabilities of different popular\nLLMs to generate code for visualization based on simple prompts. We also\nanalyze the power of LLMs to understand some common visualizations by answering\nsimple questions. Our study shows that LLMs could generate code for some\nvisualizations as well as answer questions about them. However, LLMs also have\nseveral limitations. We believe that our insights can be used to improve both\nLLMs and Information Visualization systems."}
{"id": "2506.11094", "categories": ["cs.CL", "cs.AI", "cs.CR"], "pdf": "https://arxiv.org/pdf/2506.11094", "abs": "https://arxiv.org/abs/2506.11094", "authors": ["Songyang Liu", "Chaozhuo Li", "Jiameng Qiu", "Xi Zhang", "Feiran Huang", "Litian Zhang", "Yiming Hei", "Philip S. Yu"], "title": "The Scales of Justitia: A Comprehensive Survey on Safety Evaluation of LLMs", "comment": "21 pages, preprint", "summary": "With the rapid advancement of artificial intelligence technology, Large\nLanguage Models (LLMs) have demonstrated remarkable potential in the field of\nNatural Language Processing (NLP), including areas such as content generation,\nhuman-computer interaction, machine translation, and code generation, among\nothers. However, their widespread deployment has also raised significant safety\nconcerns. In recent years, LLM-generated content has occasionally exhibited\nunsafe elements like toxicity and bias, particularly in adversarial scenarios,\nwhich has garnered extensive attention from both academia and industry. While\nnumerous efforts have been made to evaluate the safety risks associated with\nLLMs, there remains a lack of systematic reviews summarizing these research\nendeavors. This survey aims to provide a comprehensive and systematic overview\nof recent advancements in LLMs safety evaluation, focusing on several key\naspects: (1) \"Why evaluate\" that explores the background of LLMs safety\nevaluation, how they differ from general LLMs evaluation, and the significance\nof such evaluation; (2) \"What to evaluate\" that examines and categorizes\nexisting safety evaluation tasks based on key capabilities, including\ndimensions such as toxicity, robustness, ethics, bias and fairness,\ntruthfulness, and so on; (3) \"Where to evaluate\" that summarizes the evaluation\nmetrics, datasets and benchmarks currently used in safety evaluations; (4) \"How\nto evaluate\" that reviews existing evaluation toolkit, and categorizing\nmainstream evaluation methods based on the roles of the evaluators. Finally, we\nidentify the challenges in LLMs safety evaluation and propose potential\nresearch directions to promote further advancement in this field. We emphasize\nthe importance of prioritizing LLMs safety evaluation to ensure the safe\ndeployment of these models in real-world applications."}
{"id": "2506.10997", "categories": ["cs.SE", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2506.10997", "abs": "https://arxiv.org/abs/2506.10997", "authors": ["Hanumanthrao Kannan", "Alejandro Salado"], "title": "A Theory-driven Interpretation and Elaboration of Verification and Validation", "comment": null, "summary": "This paper presents a formal theory of verification and validation (V&V)\nwithin systems engineering, grounded in the axiom that V&V are fundamentally\nknowledge-building activities. Using dynamic epistemic modal logic, we develop\nprecise definitions of verification and validation, articulating their roles in\nconfirming and contextualizing knowledge about systems. The theory formalizes\nthe interplay between epistemic states, evidence, and reasoning processes,\nallowing for the derivation of theorems that clarify the conceptual\nunderpinnings of V&V. By providing a formal foundation, this work addresses\nambiguities in traditional V&V practices, offering a structured framework to\nenhance precision and consistency in systems engineering methodologies. The\ninsights gained have implications for both academic research and practical\napplications, fostering a deeper understanding of V&V as critical components of\nengineering knowledge generation."}
{"id": "2506.11095", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11095", "abs": "https://arxiv.org/abs/2506.11095", "authors": ["Manuel D. S. Hopp", "Vincent Labatut", "Arthur Amalvy", "Richard Dufour", "Hannah Stone", "Hayley Jach", "Kou Murayama"], "title": "Persistent Homology of Topic Networks for the Prediction of Reader Curiosity", "comment": null, "summary": "Reader curiosity, the drive to seek information, is crucial for textual\nengagement, yet remains relatively underexplored in NLP. Building on\nLoewenstein's Information Gap Theory, we introduce a framework that models\nreader curiosity by quantifying semantic information gaps within a text's\nsemantic structure. Our approach leverages BERTopic-inspired topic modeling and\npersistent homology to analyze the evolving topology (connected components,\ncycles, voids) of a dynamic semantic network derived from text segments,\ntreating these features as proxies for information gaps. To empirically\nevaluate this pipeline, we collect reader curiosity ratings from participants\n(n = 49) as they read S. Collins's ''The Hunger Games'' novel. We then use the\ntopological features from our pipeline as independent variables to predict\nthese ratings, and experimentally show that they significantly improve\ncuriosity prediction compared to a baseline model (73% vs. 30% explained\ndeviance), validating our approach. This pipeline offers a new computational\nmethod for analyzing text structure and its relation to reader engagement."}
{"id": "2506.10998", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.10998", "abs": "https://arxiv.org/abs/2506.10998", "authors": ["Kangping Xu", "Yifan Luo", "Yang Yuan", "Andrew Chi-Chih Yao"], "title": "Towards Automated Formal Verification of Backend Systems with LLMs", "comment": null, "summary": "Software testing plays a critical role in ensuring that systems behave as\nintended. However, existing automated testing approaches struggle to match the\ncapabilities of human engineers due to key limitations such as test locality,\nlack of general reliability, and business logic blindness. In this work, we\npropose a novel framework that leverages functional programming and type\nsystems to translate Scala backend code into formal Lean representations. Our\npipeline automatically generates theorems that specify the intended behavior of\nAPIs and database operations, and uses LLM-based provers to verify them. When a\ntheorem is proved, the corresponding logic is guaranteed to be correct and no\nfurther testing is needed. If the negation of a theorem is proved instead, it\nconfirms a bug. In cases where neither can be proved, human intervention is\nrequired. We evaluate our method on realistic backend systems and find that it\ncan formally verify over 50% of the test requirements, which suggests that half\nof a testing engineer's workload can be automated. Additionally, with an\naverage cost of only $2.19 per API, LLM-based verification is significantly\nmore cost-effective than manual testing and can be scaled easily through\nparallel execution. Our results indicate a promising direction for scalable,\nAI-powered software testing, with the potential to greatly improve engineering\nproductivity as models continue to advance."}
{"id": "2506.11097", "categories": ["cs.CL", "cs.AI", "cs.IR"], "pdf": "https://arxiv.org/pdf/2506.11097", "abs": "https://arxiv.org/abs/2506.11097", "authors": ["Haritz Puerto", "Martin Gubri", "Tommaso Green", "Seong Joon Oh", "Sangdoo Yun"], "title": "C-SEO Bench: Does Conversational SEO Work?", "comment": null, "summary": "Large Language Models (LLMs) are transforming search engines into\nConversational Search Engines (CSE). Consequently, Search Engine Optimization\n(SEO) is being shifted into Conversational Search Engine Optimization (C-SEO).\nWe are beginning to see dedicated C-SEO methods for modifying web documents to\nincrease their visibility in CSE responses. However, they are often tested only\nfor a limited breadth of application domains; we do not understand whether\ncertain C-SEO methods would be effective for a broad range of domains.\nMoreover, existing evaluations consider only a single-actor scenario where only\none web document adopts a C-SEO method; in reality, multiple players are likely\nto competitively adopt the cutting-edge C-SEO techniques, drawing an analogy\nfrom the dynamics we have seen in SEO. We present C-SEO Bench, the first\nbenchmark designed to evaluate C-SEO methods across multiple tasks, domains,\nand number of actors. We consider two search tasks, question answering and\nproduct recommendation, with three domains each. We also formalize a new\nevaluation protocol with varying adoption rates among involved actors. Our\nexperiments reveal that most current C-SEO methods are largely ineffective,\ncontrary to reported results in the literature. Instead, traditional SEO\nstrategies, those aiming to improve the ranking of the source in the LLM\ncontext, are significantly more effective. We also observe that as we increase\nthe number of C-SEO adopters, the overall gains decrease, depicting a congested\nand zero-sum nature of the problem. Our code and data are available at\nhttps://github.com/parameterlab/c-seo-bench and\nhttps://huggingface.co/datasets/parameterlab/c-seo-bench."}
{"id": "2506.10999", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.10999", "abs": "https://arxiv.org/abs/2506.10999", "authors": ["Atul Kumar", "Diptikalyan Saha", "Toshikai Yasue", "Kohichi Ono", "Saravanan Krishnan", "Sandeep Hans", "Fumiko Satoh", "Gerald Mitchell", "Sachin Kumar"], "title": "Automated Validation of COBOL to Java Transformation", "comment": "arXiv admin note: text overlap with arXiv:2504.10548", "summary": "Recent advances in Large Language Model (LLM) based Generative AI techniques\nhave made it feasible to translate enterpriselevel code from legacy languages\nsuch as COBOL to modern languages such as Java or Python. While the results of\nLLM-based automatic transformation are encouraging, the resulting code cannot\nbe trusted to correctly translate the original code. We propose a framework and\na tool to help validate the equivalence of COBOL and translated Java. The\nresults can also help repair the code if there are some issues and provide\nfeedback to the AI model to improve. We have developed a\nsymbolic-execution-based test generation to automatically generate unit tests\nfor the source COBOL programs which also mocks the external resource calls. We\ngenerate equivalent JUnit test cases with equivalent mocking as COBOL and run\nthem to check semantic equivalence between original and translated programs."}
{"id": "2506.11102", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11102", "abs": "https://arxiv.org/abs/2506.11102", "authors": ["Jiachen Zhu", "Menghui Zhu", "Renting Rui", "Rong Shan", "Congmin Zheng", "Bo Chen", "Yunjia Xi", "Jianghao Lin", "Weiwen Liu", "Ruiming Tang", "Yong Yu", "Weinan Zhang"], "title": "Evolutionary Perspectives on the Evaluation of LLM-Based AI Agents: A Comprehensive Survey", "comment": null, "summary": "The advent of large language models (LLMs), such as GPT, Gemini, and\nDeepSeek, has significantly advanced natural language processing, giving rise\nto sophisticated chatbots capable of diverse language-related tasks. The\ntransition from these traditional LLM chatbots to more advanced AI agents\nrepresents a pivotal evolutionary step. However, existing evaluation frameworks\noften blur the distinctions between LLM chatbots and AI agents, leading to\nconfusion among researchers selecting appropriate benchmarks. To bridge this\ngap, this paper introduces a systematic analysis of current evaluation\napproaches, grounded in an evolutionary perspective. We provide a detailed\nanalytical framework that clearly differentiates AI agents from LLM chatbots\nalong five key aspects: complex environment, multi-source instructor, dynamic\nfeedback, multi-modal perception, and advanced capability. Further, we\ncategorize existing evaluation benchmarks based on external environments\ndriving forces, and resulting advanced internal capabilities. For each\ncategory, we delineate relevant evaluation attributes, presented\ncomprehensively in practical reference tables. Finally, we synthesize current\ntrends and outline future evaluation methodologies through four critical\nlenses: environment, agent, evaluator, and metrics. Our findings offer\nactionable guidance for researchers, facilitating the informed selection and\napplication of benchmarks in AI agent evaluation, thus fostering continued\nadvancement in this rapidly evolving research domain."}
{"id": "2506.11000", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11000", "abs": "https://arxiv.org/abs/2506.11000", "authors": ["Ketai Qiu"], "title": "Ever-Improving Test Suite by Leveraging Large Language Models", "comment": "Accepted by 33rd ACM International Conference on the Foundations of\n  Software Engineering (FSE Companion '25), June 23--28, 2025, Trondheim,\n  Norway", "summary": "Augmenting test suites with test cases that reflect the actual usage of the\nsoftware system is extremely important to sustain the quality of long lasting\nsoftware systems. In this paper, we propose E-Test, an approach that\nincrementally augments a test suite with test cases that exercise behaviors\nthat emerge in production and that are not been tested yet. E-Test leverages\nLarge Language Models to identify already-tested, not-yet-tested, and\nerror-prone unit execution scenarios, and augment the test suite accordingly.\nOur experimental evaluation shows that E-Test outperforms the main\nstate-of-the-art approaches to identify inadequately tested behaviors and\noptimize test suites."}
{"id": "2506.11103", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11103", "abs": "https://arxiv.org/abs/2506.11103", "authors": ["Wenchong He", "Liqian Peng", "Zhe Jiang", "Alex Go"], "title": "You Only Fine-tune Once: Many-Shot In-Context Fine-Tuning for Large Language Model", "comment": "16 pages, 6 figures", "summary": "Large language models (LLMs) possess a remarkable ability to perform\nin-context learning (ICL), which enables them to handle multiple downstream\ntasks simultaneously without requiring task-specific fine-tuning. Recent\nstudies have shown that even moderately sized LLMs, such as Mistral 7B, Gemma\n7B and Llama-3 8B, can achieve ICL through few-shot in-context fine-tuning of\nall tasks at once. However, this approach still lags behind dedicated\nfine-tuning, where a separate model is trained for each individual task.\n  In this paper, we propose a novel approach, Many-Shot In-Context Fine-tuning\n(ManyICL), which significantly narrows this performance gap by extending the\nprinciples of ICL to a many-shot setting. To unlock the full potential of\nManyICL and address the inherent inefficiency of processing long sequences with\nnumerous in-context examples, we propose a novel training objective. Instead of\nsolely predicting the final answer, our approach treats every answer within the\ncontext as a supervised training target. This effectively shifts the role of\nmany-shot examples from prompts to targets for autoregressive learning. Through\nextensive experiments on diverse downstream tasks, including classification,\nsummarization, question answering, natural language inference, and math, we\ndemonstrate that ManyICL substantially outperforms zero/few-shot fine-tuning\nand approaches the performance of dedicated fine-tuning. Furthermore, ManyICL\nsignificantly mitigates catastrophic forgetting issues observed in\nzero/few-shot fine-tuning. The code will be made publicly available upon\npublication."}
{"id": "2506.11001", "categories": ["cs.SE", "cs.AI", "cs.CY", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11001", "abs": "https://arxiv.org/abs/2506.11001", "authors": ["S. Tucker Browne", "Mark M. Bailey"], "title": "Rethinking Technological Readiness in the Era of AI Uncertainty", "comment": "12 pages", "summary": "Artificial intelligence (AI) is poised to revolutionize military combat\nsystems, but ensuring these AI-enabled capabilities are truly mission-ready\npresents new challenges. We argue that current technology readiness assessments\nfail to capture critical AI-specific factors, leading to potential risks in\ndeployment. We propose a new AI Readiness Framework to evaluate the maturity\nand trustworthiness of AI components in military systems. The central thesis is\nthat a tailored framework - analogous to traditional Technology Readiness\nLevels (TRL) but expanded for AI - can better gauge an AI system's reliability,\nsafety, and suitability for combat use. Using current data evaluation tools and\ntesting practices, we demonstrate the framework's feasibility for near-term\nimplementation. This structured approach provides military decision-makers with\nclearer insight into whether an AI-enabled system has met the necessary\nstandards of performance, transparency, and human integration to be deployed\nwith confidence, thus advancing the field of defense technology management and\nrisk assessment."}
{"id": "2506.11104", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11104", "abs": "https://arxiv.org/abs/2506.11104", "authors": ["Hanzhi Zhang", "Heng Fan", "Kewei Sha", "Yan Huang", "Yunhe Feng"], "title": "DAM: Dynamic Attention Mask for Long-Context Large Language Model Inference Acceleration", "comment": null, "summary": "Long-context understanding is crucial for many NLP applications, yet\ntransformers struggle with efficiency due to the quadratic complexity of\nself-attention. Sparse attention methods alleviate this cost but often impose\nstatic, predefined masks, failing to capture heterogeneous attention patterns.\nThis results in suboptimal token interactions, limiting adaptability and\nretrieval accuracy in long-sequence tasks. This work introduces a dynamic\nsparse attention mechanism that assigns adaptive masks at the attention-map\nlevel, preserving heterogeneous patterns across layers and heads. Unlike\nexisting approaches, our method eliminates the need for fine-tuning and\npredefined mask structures while maintaining computational efficiency. By\nlearning context-aware attention structures, it achieves high alignment with\nfull-attention models, ensuring minimal performance degradation while reducing\nmemory and compute overhead. This approach provides a scalable alternative to\nfull attention, enabling the practical deployment of large-scale Large Language\nModels (LLMs) without sacrificing retrieval performance. DAM is available at:\nhttps://github.com/HanzhiZhang-Ulrica/DAM."}
{"id": "2506.11002", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11002", "abs": "https://arxiv.org/abs/2506.11002", "authors": ["Roberto Verdecchia", "Justus Bogner"], "title": "Notes On Writing Effective Empirical Software Engineering Papers: An Opinionated Primer", "comment": null, "summary": "While mastered by some, good scientific writing practices within Empirical\nSoftware Engineering (ESE) research appear to be seldom discussed and\ndocumented. Despite this, these practices are implicit or even explicit\nevaluation criteria of typical software engineering conferences and journals.\nIn this pragmatic, educational-first document, we want to provide guidance to\nthose who may feel overwhelmed or confused by writing ESE papers, but also\nthose more experienced who still might find an opinionated collection of\nwriting advice useful. The primary audience we had in mind for this paper were\nour own BSc, MSc, and PhD students, but also students of others. Our documented\nadvice therefore reflects a subjective and personal vision of writing ESE\npapers. By no means do we claim to be fully objective, generalizable, or\nrepresentative of the whole discipline. With that being said, writing papers in\nthis way has worked pretty well for us so far. We hope that this guide can at\nleast partially do the same for others."}
{"id": "2506.11105", "categories": ["cs.CL", "cs.AI", "cs.AR", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2506.11105", "abs": "https://arxiv.org/abs/2506.11105", "authors": ["Uttej Kallakurik", "Edward Humes", "Rithvik Jonna", "Xiaomin Lin", "Tinoosh Mohsenin"], "title": "Enabling On-Device Medical AI Assistants via Input-Driven Saliency Adaptation", "comment": null, "summary": "Large Language Models (LLMs) have significant impact on the healthcare\nscenarios but remain prohibitively large for deployment in real-time,\nresource-constrained environments such as edge devices. In this work, we\nintroduce a novel medical assistant system, optimized through our\ngeneral-purpose compression framework, which tailors Large Language Models\n(LLMs) for deployment in specialized domains. By measuring neuron saliency on\ndomain-specific data, our method can aggressively prune irrelevant neurons,\nreducing model size while preserving performance. Following pruning, we apply\npost-training quantization to further reduce the memory footprint, and evaluate\nthe compressed model across medical benchmarks including MedMCQA, MedQA, and\nPubMedQA. We also deploy the 50\\% compressed Gemma and the 67\\% compressed\nLLaMA3 models on Jetson Orin Nano (18.7W peak) and Raspberry Pi 5 (6.3W peak),\nachieving real-time, energy-efficient inference under hardware constraints."}
{"id": "2506.11003", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11003", "abs": "https://arxiv.org/abs/2506.11003", "authors": ["Ruiyang Xu", "Jialun Cao", "Mingyuan Wu", "Wenliang Zhong", "Yaojie Lu", "Ben He", "Xianpei Han", "Shing-Chi Cheung", "Le Sun"], "title": "EmbedAgent: Benchmarking Large Language Models in Embedded System Development", "comment": "21 pages", "summary": "Large Language Models (LLMs) have shown promise in various tasks, yet few\nbenchmarks assess their capabilities in embedded system development.In this\npaper, we introduce EmbedAgent, a paradigm designed to simulate real-world\nroles in embedded system development, such as Embedded System Programmer,\nArchitect, and Integrator. This paradigm enables LLMs to be tested in tasks\nthat bridge the gap between digital and physical systems, allowing for a more\ncomprehensive assessment of their capabilities. To evaluate LLMs on these\ntasks, we propose Embedbench, the first comprehensive benchmark for embedded\nsystem programming, circuit design, and cross-platform migration.Embedbench\nconsists of 126 cases, covering 9 electronic components across 3 hardware\nplatforms. Through extensive experiments on 10 mainstream LLMs, we uncover\nseveral key findings. Surprisingly, despite the simplicity of the cases,\nDeepSeek-R1 achieves only a 55.6% pass@1 rate when provided with schematic\ninformation, and 50.0% when tasked with generating the schematics itself. In\nthe cross-platform migration tasks, LLMs show relatively strong performance\nwith MicroPython on the Raspberry Pi Pico (with the top model achieving 73.8%\npass@1), but perform poorly on ESP-IDF, where the best model reaches only 29.4%\npass@1.Interestingly, we observe that general-purpose chat LLMs like\nDeepSeek-V3 often fail to utilize relevant pre-trained knowledge in this\ndomain, while reasoning LLMs tend to overthink and overlook efficient knowledge\nduring pretraining. Based on these insights, we propose two strategies:\nretrieval augmented generation and compiler feedback-to enhance LLM\nperformance. These strategies result in significant improvements, with\nDeepseek-R1 reaching a 65.1% pass@1 with correct schematics, and 53.1% without.\nAdditionally, the accuracy of the Arduino to ESP32 migration task improves from\n21.4% to 27.8%."}
{"id": "2506.11106", "categories": ["cs.CL", "cs.AI", "cs.IR"], "pdf": "https://arxiv.org/pdf/2506.11106", "abs": "https://arxiv.org/abs/2506.11106", "authors": ["Ningyuan Li", "Junrui Liu", "Yi Shan", "Minghui Huang", "Tong Li"], "title": "Graph-based RAG Enhancement via Global Query Disambiguation and Dependency-Aware Reranking", "comment": null, "summary": "Contemporary graph-based retrieval-augmented generation (RAG) methods\ntypically begin by extracting entities from user queries and then leverage\npre-constructed knowledge graphs to retrieve related relationships and\nmetadata. However, this pipeline's exclusive reliance on entity-level\nextraction can lead to the misinterpretation or omission of latent yet critical\ninformation and relations. As a result, retrieved content may be irrelevant or\ncontradictory, and essential knowledge may be excluded, exacerbating\nhallucination risks and degrading the fidelity of generated responses. To\naddress these limitations, we introduce PankRAG, a framework that combines a\nglobally aware, hierarchical query-resolution strategy with a novel\ndependency-aware reranking mechanism. PankRAG first constructs a multi-level\nresolution path that captures both parallel and sequential interdependencies\nwithin a query, guiding large language models (LLMs) through structured\nreasoning. It then applies its dependency-aware reranker to exploit the\ndependency structure among resolved sub-questions, enriching and validating\nretrieval results for subsequent sub-questions. Empirical evaluations\ndemonstrate that PankRAG consistently outperforms state-of-the-art approaches\nacross multiple benchmarks, underscoring its robustness and generalizability."}
{"id": "2506.11005", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11005", "abs": "https://arxiv.org/abs/2506.11005", "authors": ["Mouna Dhaouadi", "Bentley Oakes", "Michalis Famelis"], "title": "Automated Extraction and Analysis of Developer's Rationale in Open Source Software", "comment": null, "summary": "Contributors to open source software must deeply understand a project's\nhistory to make coherent decisions which do not conflict with past reasoning.\nHowever, inspecting all related changes to a proposed contribution requires\nintensive manual effort, and previous research has not yet produced an\nautomated mechanism to expose and analyze these conflicts. In this article, we\npropose such an automated approach for rationale analyses, based on an\ninstantiation of Kantara, an existing high-level rationale extraction and\nmanagement architecture. Our implementation leverages pre-trained models and\nLarge Language Models, and includes structure-based mechanisms to detect\nreasoning conflicts and problems which could cause design erosion in a project\nover time. We show the feasibility of our extraction and analysis approach\nusing the OOM-Killer module of the Linux Kernel project, and investigate the\napproach's generalization to five other highly active open source projects. The\nresults confirm that our automated approach can support rationale analyses with\nreasonable performance, by finding interesting relationships and to detect\npotential conflicts and reasoning problems. We also show the effectiveness of\nthe automated extraction of decision and rationale sentences and the prospects\nfor generalizing this to other open source projects. This automated approach\ncould therefore be used by open source software developers to proactively\naddress hidden issues and to ensure that new changes do not conflict with past\ndecisions."}
{"id": "2506.11108", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11108", "abs": "https://arxiv.org/abs/2506.11108", "authors": ["Andrew Kiruluta", "Andreas Lemos", "Priscilla Burity"], "title": "History-Aware Cross-Attention Reinforcement: Self-Supervised Multi Turn and Chain-of-Thought Fine-Tuning with vLLM", "comment": null, "summary": "We present CAGSR-vLLM-MTC, an extension of our Self-Supervised\nCross-Attention-Guided Reinforcement (CAGSR) framework, now implemented on the\nhigh-performance vLLM runtime, to address both multi-turn dialogue and\nchain-of-thought reasoning. Building upon our original single-turn approach, we\nfirst instrumented vLLM's C++/CUDA kernels to asynchronously capture per-layer,\nper-head cross-attention weights during generation. We then generalized our\nself-supervised reward function to accumulate attention signals over entire\nconversation histories and intermediate chain-of-thought steps. We discuss\npractical trade-offs, including an entropy-based clamping mechanism to prevent\nattention collapse on early context, and outline future directions for\nmulti-party dialogues and hierarchical reasoning."}
{"id": "2506.11006", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11006", "abs": "https://arxiv.org/abs/2506.11006", "authors": ["Sai Krishna", "Balvinder Singh", "Sujoy Roychowdhury", "Giriprasad Sridhara", "Sourav Mazumdar", "Magnus Sandelin", "Dimitris Rentas", "Maciej Nalepa", "Karol Sawicki", "Jakub Gajda"], "title": "Test code generation at Ericsson using Program Analysis Augmented Fine Tuned LLMs", "comment": "Accepted at International Conference on Evaluation and Assessment in\n  Software Engineering (EASE), 2025", "summary": "We describe test code generation using Large Language Models (LLMs) in\nEricsson. Our input is a test step in natural language (English) and our output\nis code (Java) which accomplishes the test step. We describe how straight\nforward prompting does not suffice and results in LLM assuming functions and\nsignatures which are not present in the code repository. We then show how we\nalleviate the problem by a combination of Retrieval Augmented Generation (RAG)\nalong with prompt engineering that expanded the simple prompt with additional\ncontextual information using static program analysis. We then describe further\nimprovements that we obtained by fine-tuning the underlying LLM. The fine\ntuning is done based on a custom designed prompt template which has\npre-dependent classes, their public methods as well two exemplar outputs\nobtained from RAG. Our results establish that our fine tuned models help\nimprove the correspondence or conformity with the original developer written\ntest code as measured by the traditional metrics of F1-score based on the\nmethods used in the generated code. Fine tuning of a 8x7b Mixture of Experts\n(MoE) model leads to an average improvement of 8\\% over the base model and is\ncomparable to the scores on a much larger 8x22b MoE model."}
{"id": "2506.11109", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11109", "abs": "https://arxiv.org/abs/2506.11109", "authors": ["Yile Chen", "Yicheng Tao", "Yue Jiang", "Shuai Liu", "Han Yu", "Gao Cong"], "title": "Enhancing Large Language Models for Mobility Analytics with Semantic Location Tokenization", "comment": "Accepted by KDD'25", "summary": "The widespread adoption of location-based services has led to the generation\nof vast amounts of mobility data, providing significant opportunities to model\nuser movement dynamics within urban environments. Recent advancements have\nfocused on adapting Large Language Models (LLMs) for mobility analytics.\nHowever, existing methods face two primary limitations: inadequate semantic\nrepresentation of locations (i.e., discrete IDs) and insufficient modeling of\nmobility signals within LLMs (i.e., single templated instruction fine-tuning).\nTo address these issues, we propose QT-Mob, a novel framework that\nsignificantly enhances LLMs for mobility analytics. QT-Mob introduces a\nlocation tokenization module that learns compact, semantically rich tokens to\nrepresent locations, preserving contextual information while ensuring\ncompatibility with LLMs. Furthermore, QT-Mob incorporates a series of\ncomplementary fine-tuning objectives that align the learned tokens with the\ninternal representations in LLMs, improving the model's comprehension of\nsequential movement patterns and location semantics. The proposed QT-Mob\nframework not only enhances LLMs' ability to interpret mobility data but also\nprovides a more generalizable approach for various mobility analytics tasks.\nExperiments on three real-world dataset demonstrate the superior performance in\nboth next-location prediction and mobility recovery tasks, outperforming\nexisting deep learning and LLM-based methods."}
{"id": "2506.11007", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11007", "abs": "https://arxiv.org/abs/2506.11007", "authors": ["Rock Sabetto", "Emily Escamilla", "Devesh Agarwal", "Sujay Kandwal", "Justin F. Brunelle", "Scott Rosen", "Nitin Naik", "Samruddhi Thaker", "Eric O. Scott", "Jacob Zimmer", "Amit Madan", "Arun Sridharan", "Doug Wendt", "Michael Doyle", "Christopher Glasz", "Jasper Phillips", "William Macke", "Colin Diggs", "Michael Bartholf", "Zachary Robin", "Paul Ursino"], "title": "Impact of Comments on LLM Comprehension of Legacy Code", "comment": null, "summary": "Large language models (LLMs) have been increasingly integrated into software\nengineering and maintenance tasks due to their high performance with software\nengineering tasks and robust understanding of modern programming languages.\nHowever, the ability of LLMs to comprehend code written with legacy languages\nremains a research gap challenged by real-world legacy systems lacking or\ncontaining inaccurate documentation that may impact LLM comprehension. To\nassess LLM comprehension of legacy languages, there is a need for objective LLM\nevaluation. In order to objectively measure LLM comprehension of legacy\nlanguages, we need an efficient, quantitative evaluation method. We leverage\nmultiple-choice question answering (MCQA), an emerging LLM evaluation\nmethodology, to evaluate LLM comprehension of legacy code and the impact of\ncomment prevalence and inaccurate comments. In this work, we present\npreliminary findings on the impact of documentation on LLM comprehension of\nlegacy code and outline strategic objectives for future work."}
{"id": "2506.11110", "categories": ["cs.CL", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11110", "abs": "https://arxiv.org/abs/2506.11110", "authors": ["Jaeho Lee", "Atharv Chowdhary"], "title": "AssertBench: A Benchmark for Evaluating Self-Assertion in Large Language Models", "comment": "15 pages, 4 figures, appendix contains 2 additional figures and 2\n  tables", "summary": "Recent benchmarks have probed factual consistency and rhetorical robustness\nin Large Language Models (LLMs). However, a knowledge gap exists regarding how\ndirectional framing of factually true statements influences model agreement, a\ncommon scenario for LLM users. AssertBench addresses this by sampling\nevidence-supported facts from FEVEROUS, a fact verification dataset. For each\n(evidence-backed) fact, we construct two framing prompts: one where the user\nclaims the statement is factually correct, and another where the user claims it\nis incorrect. We then record the model's agreement and reasoning. The desired\noutcome is that the model asserts itself, maintaining consistent truth\nevaluation across both framings, rather than switching its evaluation to agree\nwith the user. AssertBench isolates framing-induced variability from the\nmodel's underlying factual knowledge by stratifying results based on the\nmodel's accuracy on the same claims when presented neutrally. In doing so, this\nbenchmark aims to measure an LLM's ability to \"stick to its guns\" when\npresented with contradictory user assertions about the same fact. The complete\nsource code is available at https://github.com/achowd32/assert-bench."}
{"id": "2506.11008", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11008", "abs": "https://arxiv.org/abs/2506.11008", "authors": ["David Noever"], "title": "Encoding Software For Perpetuity: A Compact Representation Of Apollo 11 Guidance Code", "comment": null, "summary": "This brief note presents a novel method for encoding historic Apollo 11 Lunar\nModule guidance computer code into a single, compact Quick Response Code (QR\ncode) format, creating an accessible digital artifact for transmission and\narchival purposes. By applying tokenization, selective content preservation,\nand minimal HTML/JavaScript techniques, we successfully compressed key\ncomponents of the original Assembly Language Code (AGC) into a shareable,\npreservable, and scannable 3 kilobyte (KB) image. We evaluate multiple\ncompression strategies and their tradeoffs in terms of size, readability, and\nhistorical significance. This method addresses the challenge of making\nhistorically significant software artifacts available through modern mobile\ndevices without requiring specialized hardware or internet connectivity. While\nnumerous digital preservation methods exist for historic software, this\napproach balances accessibility with historical significance, offering a\ncomplementary method to traditional archival techniques. This work contributes\nto the broader field of computing heritage preservation by demonstrating how\nlandmark software can be made accessible instantly through contemporary mobile\ntechnologies."}
{"id": "2506.11111", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11111", "abs": "https://arxiv.org/abs/2506.11111", "authors": ["Kun Zhang", "Le Wu", "Kui Yu", "Guangyi Lv", "Dacao Zhang"], "title": "Evaluating and Improving Robustness in Large Language Models: A Survey and Future Directions", "comment": "33 pages, 5 figures", "summary": "Large Language Models (LLMs) have gained enormous attention in recent years\ndue to their capability of understanding and generating natural languages. With\nthe rapid development and wild-range applications (e.g., Agents, Embodied\nIntelligence), the robustness of LLMs has received increased attention. As the\ncore brain of many AI applications, the robustness of LLMs requires that models\nshould not only generate consistent contents, but also ensure the correctness\nand stability of generated content when dealing with unexpeted application\nscenarios (e.g., toxic prompts, limited noise domain data, outof-distribution\n(OOD) applications, etc). In this survey paper, we conduct a thorough review of\nthe robustness of LLMs, aiming to provide a comprehensive terminology of\nconcepts and methods around this field and facilitate the community.\nSpecifically, we first give a formal definition of LLM robustness and present\nthe collection protocol of this survey paper. Then, based on the types of\nperturbated inputs, we organize this survey from the following perspectives: 1)\nAdversarial Robustness: tackling the problem that prompts are manipulated\nintentionally, such as noise prompts, long context, data attack, etc; 2) OOD\nRobustness: dealing with the unexpected real-world application scenarios, such\nas OOD detection, zero-shot transferring, hallucinations, etc; 3) Evaluation of\nRobustness: summarizing the new evaluation datasets, metrics, and tools for\nverifying the robustness of LLMs. After reviewing the representative work from\neach perspective, we discuss and highlight future opportunities and research\ndirections in this field. Meanwhile, we also organize related works and provide\nan easy-to-search project\n(https://github.com/zhangkunzk/Awesome-LLM-Robustness-papers) to support the\ncommunity."}
{"id": "2506.11009", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11009", "abs": "https://arxiv.org/abs/2506.11009", "authors": ["Jirat Pasuksmit", "Wannita Takerngsaksiri", "Patanamon Thongtanunam", "Chakkrit Tantithamthavorn", "Ruixiong Zhang", "Shiyan Wang", "Fan Jiang", "Jing Li", "Evan Cook", "Kun Chen", "Ming Wu"], "title": "Human-In-The-Loop Software Development Agents: Challenges and Future Directions", "comment": "The International Conference on Mining Software Repositories (MSR)\n  2025, Industry track", "summary": "Multi-agent LLM-driven systems for software development are rapidly gaining\ntraction, offering new opportunities to enhance productivity. At Atlassian, we\ndeployed Human-in-the-Loop Software Development Agents to resolve Jira work\nitems and evaluated the generated code quality using functional correctness\ntesting and GPT-based similarity scoring. This paper highlights two major\nchallenges: the high computational costs of unit testing and the variability in\nLLM-based evaluations. We also propose future research directions to improve\nevaluation frameworks for Human-In-The-Loop software development tools."}
{"id": "2506.11112", "categories": ["cs.CL", "cs.HC", "cs.IR"], "pdf": "https://arxiv.org/pdf/2506.11112", "abs": "https://arxiv.org/abs/2506.11112", "authors": ["Christine Bauer", "Li Chen", "Nicola Ferro", "Norbert Fuhr", "Avishek Anand", "Timo Breuer", "Guglielmo Faggioli", "Ophir Frieder", "Hideo Joho", "Jussi Karlgren", "Johannes Kiesel", "Bart P. Knijnenburg", "Aldo Lipani", "Lien Michiels", "Andrea Papenmeier", "Maria Soledad Pera", "Mark Sanderson", "Scott Sanner", "Benno Stein", "Johanne R. Trippas", "Karin Verspoor", "Martijn C Willemsen"], "title": "Manifesto from Dagstuhl Perspectives Workshop 24352 -- Conversational Agents: A Framework for Evaluation (CAFE)", "comment": "43 pages; 10 figures; Dagstuhl manifesto", "summary": "During the workshop, we deeply discussed what CONversational Information\nACcess (CONIAC) is and its unique features, proposing a world model abstracting\nit, and defined the Conversational Agents Framework for Evaluation (CAFE) for\nthe evaluation of CONIAC systems, consisting of six major components: 1) goals\nof the system's stakeholders, 2) user tasks to be studied in the evaluation, 3)\naspects of the users carrying out the tasks, 4) evaluation criteria to be\nconsidered, 5) evaluation methodology to be applied, and 6) measures for the\nquantitative criteria chosen."}
{"id": "2506.11011", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11011", "abs": "https://arxiv.org/abs/2506.11011", "authors": ["Abhi Desai"], "title": "Enhancing Inventory Management with Progressive Web Applications (PWAs): A Scalable Solution for Small and Large Enterprises", "comment": null, "summary": "Efficient inventory management is crucial for both small and large\nenterprises to optimize operational workflows and reduce overhead costs. This\npaper explores the development and implementation of a Progressive Web\nApplication (PWA) designed to enhance the inventory management experience. The\napplication integrates key functionalities such as barcode and QR code\nscanning, geolocation-based warehouse identification, and cross-device\naccessibility. By leveraging PWA technology, the solution ensures offline\ncapabilities, responsive user experience, and seamless adaptability across\nvarious platforms. The study discusses the challenges and benefits of\nimplementing PWA in inventory management systems, including its limitations in\nperformance compared to native applications. Insights from the development\nprocess provide a roadmap for future developers looking to integrate PWA\ntechnology into enterprise applications. This research contributes to the\ngrowing domain of web-based inventory solutions, offering a scalable and\ncost-effective alternative to traditional inventory management software."}
{"id": "2506.11113", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11113", "abs": "https://arxiv.org/abs/2506.11113", "authors": ["Tzu-Ling Lin", "Wei-Chih Chen", "Teng-Fang Hsiao", "Hou-I Liu", "Ya-Hsin Yeh", "Yu Kai Chan", "Wen-Sheng Lien", "Po-Yen Kuo", "Philip S. Yu", "Hong-Han Shuai"], "title": "Breaking the Reviewer: Assessing the Vulnerability of Large Language Models in Automated Peer Review Under Textual Adversarial Attacks", "comment": null, "summary": "Peer review is essential for maintaining academic quality, but the increasing\nvolume of submissions places a significant burden on reviewers. Large language\nmodels (LLMs) offer potential assistance in this process, yet their\nsusceptibility to textual adversarial attacks raises reliability concerns. This\npaper investigates the robustness of LLMs used as automated reviewers in the\npresence of such attacks. We focus on three key questions: (1) The\neffectiveness of LLMs in generating reviews compared to human reviewers. (2)\nThe impact of adversarial attacks on the reliability of LLM-generated reviews.\n(3) Challenges and potential mitigation strategies for LLM-based review. Our\nevaluation reveals significant vulnerabilities, as text manipulations can\ndistort LLM assessments. We offer a comprehensive evaluation of LLM performance\nin automated peer reviewing and analyze its robustness against adversarial\nattacks. Our findings emphasize the importance of addressing adversarial risks\nto ensure AI strengthens, rather than compromises, the integrity of scholarly\ncommunication."}
{"id": "2506.11013", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11013", "abs": "https://arxiv.org/abs/2506.11013", "authors": ["Filipe Fernandes", "Cláudia Werner"], "title": "Toward a Brazilian Research Agenda in Quantum Software Engineering: A Systematic Mapping Study", "comment": "11 pages, 13 figures", "summary": "Context: Quantum Software Engineering (QSE) has emerged as a key field to\nsupport the development of reliable, maintainable, and scalable quantum\napplications, bridging advances in quantum computing with established practices\nin software engineering. Problem: Despite its growth, the field still suffers\nfrom fragmented knowledge, with a lack of standardized methodologies, tools,\nand guidelines tailored to the unique features of the quantum paradigm.\nAdditionally, countries like Brazil have had limited participation in the\ndevelopment of this emerging domain. Objective: This study aims to map the\nstate of the art in QSE by identifying current research trends, recurring\ncontributions, and existing gaps that can guide future investigations and\nstrategic initiatives. Methodology: A systematic mapping study was conducted\nanalyzing selected publications based on inclusion and exclusion criteria.\nArticles were categorized by study type, research type, and alignment with the\nSWEBOK knowledge areas. Results: Most of the reviewed studies are primary\nresearch articles written in English, with a strong focus on Software\nEngineering Models and Methods, Software Architecture, and Software Testing.\nConceptual proposals and technical solutions predominate, while empirical\nvalidations remain limited. Conclusions: Findings confirm that QSE is a\npromising but still maturing field. The standardization of practices, expansion\nof empirical studies, and inclusion of researchers from developing countries\nare crucial for advancing the discipline. Additionally, Brazilian contributions\nare still scarce, highlighting the urgent need to establish a national research\nagenda. As a main contribution, this study proposes a Brazilian Research Agenda\nin QSE, outlining priority areas and opportunities to foster a local scientific\ncommunity and accelerate progress in this emerging field."}
{"id": "2506.11114", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11114", "abs": "https://arxiv.org/abs/2506.11114", "authors": ["Junyu Liu", "Kaiqi Yan", "Tianyang Wang", "Qian Niu", "Momoko Nagai-Tanima", "Tomoki Aoyama"], "title": "KokushiMD-10: Benchmark for Evaluating Large Language Models on Ten Japanese National Healthcare Licensing Examinations", "comment": "9pages, 3 figures", "summary": "Recent advances in large language models (LLMs) have demonstrated notable\nperformance in medical licensing exams. However, comprehensive evaluation of\nLLMs across various healthcare roles, particularly in high-stakes clinical\nscenarios, remains a challenge. Existing benchmarks are typically text-based,\nEnglish-centric, and focus primarily on medicines, which limits their ability\nto assess broader healthcare knowledge and multimodal reasoning. To address\nthese gaps, we introduce KokushiMD-10, the first multimodal benchmark\nconstructed from ten Japanese national healthcare licensing exams. This\nbenchmark spans multiple fields, including Medicine, Dentistry, Nursing,\nPharmacy, and allied health professions. It contains over 11588 real exam\nquestions, incorporating clinical images and expert-annotated rationales to\nevaluate both textual and visual reasoning. We benchmark over 30\nstate-of-the-art LLMs, including GPT-4o, Claude 3.5, and Gemini, across both\ntext and image-based settings. Despite promising results, no model consistently\nmeets passing thresholds across domains, highlighting the ongoing challenges in\nmedical AI. KokushiMD-10 provides a comprehensive and linguistically grounded\nresource for evaluating and advancing reasoning-centric medical AI across\nmultilingual and multimodal clinical tasks."}
{"id": "2506.11014", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11014", "abs": "https://arxiv.org/abs/2506.11014", "authors": ["Benedetta Donato", "Leonardo Mariani", "Daniela Micucci", "Oliviero Riganelli", "Marco Somaschini"], "title": "MultiMind: A Plug-in for the Implementation of Development Tasks Aided by AI Assistants", "comment": null, "summary": "The integration of AI assistants into software development workflows is\nrapidly evolving, shifting from automation-assisted tasks to collaborative\ninteractions between developers and AI. Large Language Models (LLMs) have\ndemonstrated their effectiveness in several development activities, including\ncode completion, test case generation, and documentation production. However,\nembedding AI-assisted tasks within Integrated Development Environments (IDEs)\npresents significant challenges. It requires designing mechanisms to invoke AI\nassistants at the appropriate time, coordinate interactions with multiple\nassistants, process the generated outputs, and present feedback in a way that\nseamlessly integrates with the development workflow. To address these issues,\nwe introduce MultiMind, a Visual Studio Code plug-in that streamlines the\ncreation of AI-assisted development tasks. MultiMind provides a modular and\nextensible framework, enabling developers to cost-effectively implement and\nexperiment with new AI-powered interactions without the need for complex IDE\ncustomizations. MultiMind has been tested in two use cases: one for the\nautomatic generation of code comments and the other about the definition of\nAI-powered chat."}
{"id": "2506.11115", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11115", "abs": "https://arxiv.org/abs/2506.11115", "authors": ["Yerim Oh", "Jun-Hyung Park", "Junho Kim", "SungHo Kim", "SangKeun Lee"], "title": "Incorporating Domain Knowledge into Materials Tokenization", "comment": null, "summary": "While language models are increasingly utilized in materials science, typical\nmodels rely on frequency-centric tokenization methods originally developed for\nnatural language processing. However, these methods frequently produce\nexcessive fragmentation and semantic loss, failing to maintain the structural\nand semantic integrity of material concepts. To address this issue, we propose\nMATTER, a novel tokenization approach that integrates material knowledge into\ntokenization. Based on MatDetector trained on our materials knowledge base and\na re-ranking method prioritizing material concepts in token merging, MATTER\nmaintains the structural integrity of identified material concepts and prevents\nfragmentation during tokenization, ensuring their semantic meaning remains\nintact. The experimental results demonstrate that MATTER outperforms existing\ntokenization methods, achieving an average performance gain of $4\\%$ and $2\\%$\nin the generation and classification tasks, respectively. These results\nunderscore the importance of domain knowledge for tokenization strategies in\nscientific text processing. Our code is available at\nhttps://github.com/yerimoh/MATTER"}
{"id": "2506.11016", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11016", "abs": "https://arxiv.org/abs/2506.11016", "authors": ["Lelanthran Manickum"], "title": "ZjsComponent: A Pragmatic Approach to Modular, Reusable UI Fragments for Web Development", "comment": "12 pages, 7 figures", "summary": "In this paper, I present ZjsComponent, a lightweight and framework-agnostic\nweb component designed for creating modular, reusable UI elements with minimal\ndeveloper overhead. ZjsComponent is an example implementation of an approach to\ncreating components and object instances that can be used purely from HTML.\nUnlike traditional approaches to components, the approach implemented by\nZjsComponent does not require build-steps, transpiling, pre-compilation, any\nspecific ecosystem or any other dependency. All that is required is that the\nbrowser can load and execute Javascript as needed by Web Components.\nZjsComponent allows dynamic loading and isolation of HTML+JS fragments,\noffering developers a simple way to build reusable interfaces with ease. This\napproach is dependency-free, provides significant DOM and code isolation, and\nsupports simple lifecycle hooks as well as traditional methods expected of an\ninstance of a class."}
{"id": "2506.11116", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11116", "abs": "https://arxiv.org/abs/2506.11116", "authors": ["Jijie Li", "Li Du", "Hanyu Zhao", "Bo-wen Zhang", "Liangdong Wang", "Boyan Gao", "Guang Liu", "Yonghua Lin"], "title": "Infinity Instruct: Scaling Instruction Selection and Synthesis to Enhance Language Models", "comment": null, "summary": "Large Language Models (LLMs) demonstrate strong performance in real-world\napplications, yet existing open-source instruction datasets often concentrate\non narrow domains, such as mathematics or coding, limiting generalization and\nwidening the gap with proprietary models. To bridge this gap, we introduce\nInfinity-Instruct, a high-quality instruction dataset designed to enhance both\nfoundational and chat capabilities of LLMs through a two-phase pipeline. In\nPhase 1, we curate 7.4M high-quality foundational instructions\n(InfInstruct-F-7.4M) from over 100M samples using hybrid data selection\ntechniques. In Phase 2, we synthesize 1.5M high-quality chat instructions\n(InfInstruct-G-1.5M) through a two-stage process involving instruction\nselection, evolution, and diagnostic filtering. We empirically evaluate\nInfinity-Instruct by fine-tuning several open-source models, including Mistral,\nLLaMA, Qwen, and Yi, and observe substantial performance gains across both\nfoundational and instruction following benchmarks, consistently surpassing\nofficial instruction-tuned counterparts. Notably, InfInstruct-LLaMA3.1-70B\noutperforms GPT-4-0314 by 8.6\\% on instruction following tasks while achieving\ncomparable foundational performance. These results underscore the synergy\nbetween foundational and chat training and offer new insights into holistic LLM\ndevelopment. Our\ndataset\\footnote{https://huggingface.co/datasets/BAAI/Infinity-Instruct} and\ncodes\\footnote{https://gitee.com/li-touch/infinity-instruct} have been publicly\nreleased."}
{"id": "2506.11018", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11018", "abs": "https://arxiv.org/abs/2506.11018", "authors": ["Grigory Tsiperman"], "title": "Formation of requirements traceability in the process of information systems design", "comment": "12 pages, 4 figures, 2025 the 8th International Conference on\n  Information Management", "summary": "The traceability of requirements in the information system design process is\nconsidered an essential property of the project, one of its quality\ncharacteristics. The point here is that traceability provides the methods of\nvalidation and verification of software systems, and that the system model\nbased on requirements traceability reduces the system's dependence on\ndevelopers and, in general, makes it as straightforward as possible. One of the\nchallenges of the traceability process, dubbed \"The grand challenge of\ntraceability\" among traceability researchers, is its integration into the\ndesign process. In this paper, to achieve this goal, we propose the application\nof the Adaptive Clustering Method (ACM) of Information Systems developed by the\nauthor, which is based on the idea of a seamless system architecture that\nprovides explicit interconnection of project artifacts of different levels of\nabstraction."}
{"id": "2506.11117", "categories": ["cs.CL", "cs.AI", "cs.IR"], "pdf": "https://arxiv.org/pdf/2506.11117", "abs": "https://arxiv.org/abs/2506.11117", "authors": ["Junyong Lin", "Lu Dai", "Ruiqian Han", "Yijie Sui", "Ruilin Wang", "Xingliang Sun", "Qinglin Wu", "Min Feng", "Hao Liu", "Hui Xiong"], "title": "ScIRGen: Synthesize Realistic and Large-Scale RAG Dataset for Scientific Research", "comment": "KDD 2025 Accepted", "summary": "Scientific researchers need intensive information about datasets to\neffectively evaluate and develop theories and methodologies. The information\nneeds regarding datasets are implicitly embedded in particular research tasks,\nrather than explicitly expressed in search queries. However, existing\nscientific retrieval and question-answering (QA) datasets typically address\nstraightforward questions, which do not align with the distribution of\nreal-world research inquiries. To bridge this gap, we developed ScIRGen, a\ndataset generation framework for scientific QA \\& retrieval that more\naccurately reflects the information needs of professional science researchers,\nand uses it to create a large-scale scientific retrieval-augmented generation\n(RAG) dataset with realistic queries, datasets and papers. Technically, we\ndesigned a dataset-oriented information extraction method that leverages\nacademic papers to augment the dataset representation. We then proposed a\nquestion generation framework by employing cognitive taxonomy to ensure the\nquality of synthesized questions. We also design a method to automatically\nfilter synthetic answers based on the perplexity shift of LLMs, which is highly\naligned with human judgment of answers' validity. Collectively, these\nmethodologies culminated in the creation of the 61k QA dataset, ScIRGen-Geo. We\nbenchmarked representative methods on the ScIRGen-Geo dataset for their\nquestion-answering and retrieval capabilities, finding out that current methods\nstill suffer from reasoning from complex questions. This work advances the\ndevelopment of more sophisticated tools to support the intricate information\nneeds of the scientific community."}
{"id": "2506.11019", "categories": ["cs.SE", "68T01, 68N30", "I.2.6; D.2.7"], "pdf": "https://arxiv.org/pdf/2506.11019", "abs": "https://arxiv.org/abs/2506.11019", "authors": ["Vincent Koc", "Jacques Verre", "Douglas Blank", "Abigail Morgan"], "title": "Mind the Metrics: Patterns for Telemetry-Aware In-IDE AI Application Development using the Model Context Protocol (MCP)", "comment": "16 pages, 5 figures, conference preprint submission. Conceptual\n  systems architecture paper on telemetry-driven prompt optimization and IDE\n  design patterns for AI development. Builds on Opik MCP open-source\n  architecture and Comet trace infrastructure", "summary": "AI development environments are evolving into observability first platforms\nthat integrate real time telemetry, prompt traces, and evaluation feedback into\nthe developer workflow. This paper introduces telemetry aware integrated\ndevelopment environments (IDEs) enabled by the Model Context Protocol (MCP), a\nsystem that connects IDEs with prompt metrics, trace logs, and versioned\ncontrol for real time refinement. We present design patterns for local prompt\niteration, CI based optimization, and autonomous agents that adapt behavior\nusing telemetry. Rather than focusing on a single algorithm, we describe an\narchitecture that supports integration with frameworks like DSPy, PromptWizard,\nand Prompts as Programs. We demonstrate this through Opik, an open source MCP\nserver for LLM telemetry, and position our approach within the emerging LLMOps\necosystem. This work lays a foundation for future research on prompt\noptimization, IDE agent tooling, and empirical benchmarking in telemetry rich\nAI development workflows."}
{"id": "2506.11119", "categories": ["cs.CL", "cs.SD", "eess.AS", "68T10 (Primary), 68U99 (Secondary)", "I.2.1; J.3"], "pdf": "https://arxiv.org/pdf/2506.11119", "abs": "https://arxiv.org/abs/2506.11119", "authors": ["Jingyu Li", "Lingchao Mao", "Hairong Wang", "Zhendong Wang", "Xi Mao", "Xuelei Sherry Ni"], "title": "Benchmarking Foundation Speech and Language Models for Alzheimer's Disease and Related Dementia Detection from Spontaneous Speech", "comment": null, "summary": "Background: Alzheimer's disease and related dementias (ADRD) are progressive\nneurodegenerative conditions where early detection is vital for timely\nintervention and care. Spontaneous speech contains rich acoustic and linguistic\nmarkers that may serve as non-invasive biomarkers for cognitive decline.\nFoundation models, pre-trained on large-scale audio or text data, produce\nhigh-dimensional embeddings encoding contextual and acoustic features.\n  Methods: We used the PREPARE Challenge dataset, which includes audio\nrecordings from over 1,600 participants with three cognitive statuses: healthy\ncontrol (HC), mild cognitive impairment (MCI), and Alzheimer's Disease (AD). We\nexcluded non-English, non-spontaneous, or poor-quality recordings. The final\ndataset included 703 (59.13%) HC, 81 (6.81%) MCI, and 405 (34.06%) AD cases. We\nbenchmarked a range of open-source foundation speech and language models to\nclassify cognitive status into the three categories.\n  Results: The Whisper-medium model achieved the highest performance among\nspeech models (accuracy = 0.731, AUC = 0.802). Among language models, BERT with\npause annotation performed best (accuracy = 0.662, AUC = 0.744). ADRD detection\nusing state-of-the-art automatic speech recognition (ASR) model-generated audio\nembeddings outperformed others. Including non-semantic features like pause\npatterns consistently improved text-based classification.\n  Conclusion: This study introduces a benchmarking framework using foundation\nmodels and a clinically relevant dataset. Acoustic-based approaches --\nparticularly ASR-derived embeddings -- demonstrate strong potential for\nscalable, non-invasive, and cost-effective early detection of ADRD."}
{"id": "2506.11020", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11020", "abs": "https://arxiv.org/abs/2506.11020", "authors": ["Thayná Camargo da Silva"], "title": "Extracting Knowledge Graphs from User Stories using LangChain", "comment": "Master thesis work", "summary": "This thesis introduces a novel methodology for the automated generation of\nknowledge graphs from user stories by leveraging the advanced capabilities of\nLarge Language Models. Utilizing the LangChain framework as a basis, the User\nStory Graph Transformer module was developed to extract nodes and relationships\nfrom user stories using an LLM to construct accurate knowledge graphs.This\ninnovative technique was implemented in a script to fully automate the\nknowledge graph extraction process. Additionally, the evaluation was automated\nthrough a dedicated evaluation script, utilizing an annotated dataset for\nassessment. By enhancing the visualization and understanding of user\nrequirements and domain concepts, this method fosters better alignment between\nsoftware functionalities and user expectations, ultimately contributing to more\neffective and user-centric software development processes."}
{"id": "2506.11120", "categories": ["cs.CL", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11120", "abs": "https://arxiv.org/abs/2506.11120", "authors": ["Hourun Zhu", "Chengchao Shen"], "title": "SDMPrune: Self-Distillation MLP Pruning for Efficient Large Language Models", "comment": null, "summary": "In spite of strong performance achieved by LLMs, the costs of their\ndeployment are unaffordable. For the compression of LLMs, gradient-based\npruning methods present promising effectiveness. However, in these methods, the\ngradient computation with one-hot labels ignore the potential predictions on\nother words, thus missing key information for generative capability of the\noriginal model. To address this issue, we introduce a self-distillation loss\nduring the pruning phase (rather than post-training) to fully exploit the\npredictions of the original model, thereby obtaining more accurate gradient\ninformation for pruning. Moreover, we find that, compared to attention modules,\nthe predictions of LLM are less sensitive to multilayer perceptron (MLP)\nmodules, which take up more than $5 \\times$ parameters (LLaMA3.2-1.2B). To this\nend, we focus on the pruning of MLP modules, to significantly compress LLM\nwithout obvious performance degradation. Experimental results on extensive\nzero-shot benchmarks demonstrate that our method significantly outperforms\nexisting pruning methods. Furthermore, our method achieves very competitive\nperformance among 1B-scale open source LLMs. The source code and trained\nweights are available at https://github.com/visresearch/SDMPrune."}
{"id": "2506.11021", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11021", "abs": "https://arxiv.org/abs/2506.11021", "authors": ["Chaitanya Ravuri", "Saman Amarasinghe"], "title": "Eliminating Hallucination-Induced Errors in LLM Code Generation with Functional Clustering", "comment": "9 pages, 1 figure", "summary": "Modern code-generation LLMs can already solve a large fraction of programming\nproblems, yet they still hallucinate subtle bugs that make their outputs unsafe\nfor autonomous deployment. We present functional clustering, a black-box\nwrapper that eliminates nearly all hallucination-induced errors while providing\na tunable confidence score. The wrapper samples many candidate programs,\nexecutes each on a self-generated test suite, and clusters candidates whose I/O\nbehavior is identical; the empirical mass of the largest cluster serves as an\nexact confidence estimate. A single scalar threshold on this estimate lets\nusers trade coverage for reliability with exponential guarantees. On\nLiveCodeBench our verifier preserves baseline pass@1 on solvable tasks yet\nslashes the error rate of returned answers from ~65% to 2%, and drives it to 0%\nat a conservative threshold while still answering 15.6% of prompts. Manual\naudits show that the few residual mistakes stem from prompt misinterpretation,\nnot random generation noise, narrowing future work to specification clarity.\nBecause the method requires only sampling and sandbox execution, it applies\nunchanged to closed-source APIs and future models, offering a practical path\ntoward dependable, autonomous code generation. Our code is available on Github\n(https://github.com/20ChaituR/functional-clustering)."}
{"id": "2506.11121", "categories": ["cs.CL", "cs.AI", "cs.SD", "eess.AS"], "pdf": "https://arxiv.org/pdf/2506.11121", "abs": "https://arxiv.org/abs/2506.11121", "authors": ["Wei-Ping Huang", "Guan-Ting Lin", "Hung-yi Lee"], "title": "SUTA-LM: Bridging Test-Time Adaptation and Language Model Rescoring for Robust ASR", "comment": null, "summary": "Despite progress in end-to-end ASR, real-world domain mismatches still cause\nperformance drops, which Test-Time Adaptation (TTA) aims to mitigate by\nadjusting models during inference. Recent work explores combining TTA with\nexternal language models, using techniques like beam search rescoring or\ngenerative error correction. In this work, we identify a previously overlooked\nchallenge: TTA can interfere with language model rescoring, revealing the\nnontrivial nature of effectively combining the two methods. Based on this\ninsight, we propose SUTA-LM, a simple yet effective extension of SUTA, an\nentropy-minimization-based TTA approach, with language model rescoring. SUTA-LM\nfirst applies a controlled adaptation process guided by an auto-step selection\nmechanism leveraging both acoustic and linguistic information, followed by\nlanguage model rescoring to refine the outputs. Experiments on 18 diverse ASR\ndatasets show that SUTA-LM achieves robust results across a wide range of\ndomains."}
{"id": "2506.11022", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11022", "abs": "https://arxiv.org/abs/2506.11022", "authors": ["Shivani Shukla", "Himanshu Joshi", "Romilla Syed"], "title": "Security Degradation in Iterative AI Code Generation -- A Systematic Analysis of the Paradox", "comment": "Keywords - Large Language Models, Security Vulnerabilities,\n  AI-Generated Code, Iterative Feedback, Software Security, Secure Coding\n  Practices, Feedback Loops, LLM Prompting Strategies", "summary": "The rapid adoption of Large Language Models(LLMs) for code generation has\ntransformed software development, yet little attention has been given to how\nsecurity vulnerabilities evolve through iterative LLM feedback. This paper\nanalyzes security degradation in AI-generated code through a controlled\nexperiment with 400 code samples across 40 rounds of \"improvements\" using four\ndistinct prompting strategies. Our findings show a 37.6% increase in critical\nvulnerabilities after just five iterations, with distinct vulnerability\npatterns emerging across different prompting approaches. This evidence\nchallenges the assumption that iterative LLM refinement improves code security\nand highlights the essential role of human expertise in the loop. We propose\npractical guidelines for developers to mitigate these risks, emphasizing the\nneed for robust human validation between LLM iterations to prevent the\nparadoxical introduction of new security issues during supposedly beneficial\ncode \"improvements\"."}
{"id": "2506.11125", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11125", "abs": "https://arxiv.org/abs/2506.11125", "authors": ["Freddie Grabovski", "Gilad Gressel", "Yisroel Mirsky"], "title": "ASRJam: Human-Friendly AI Speech Jamming to Prevent Automated Phone Scams", "comment": null, "summary": "Large Language Models (LLMs), combined with Text-to-Speech (TTS) and\nAutomatic Speech Recognition (ASR), are increasingly used to automate voice\nphishing (vishing) scams. These systems are scalable and convincing, posing a\nsignificant security threat. We identify the ASR transcription step as the most\nvulnerable link in the scam pipeline and introduce ASRJam, a proactive defence\nframework that injects adversarial perturbations into the victim's audio to\ndisrupt the attacker's ASR. This breaks the scam's feedback loop without\naffecting human callers, who can still understand the conversation. While prior\nadversarial audio techniques are often unpleasant and impractical for real-time\nuse, we also propose EchoGuard, a novel jammer that leverages natural\ndistortions, such as reverberation and echo, that are disruptive to ASR but\ntolerable to humans. To evaluate EchoGuard's effectiveness and usability, we\nconducted a 39-person user study comparing it with three state-of-the-art\nattacks. Results show that EchoGuard achieved the highest overall utility,\noffering the best combination of ASR disruption and human listening experience."}
{"id": "2506.11051", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11051", "abs": "https://arxiv.org/abs/2506.11051", "authors": ["Sung Une Lee", "Liming Dong", "Zhenchang Xing", "Muhammad Ejaz Ahmed", "Stefan Avgoustakis"], "title": "Software Security Mapping Framework: Operationalization of Security Requirements", "comment": "28 pages, 13 figures, 6 tables", "summary": "The escalating complexity of modern software development environments has\nheightened concerns around supply chain security. However, existing frameworks\noften fall short in translating abstract security principles into concrete,\nactionable practices. This paper introduces the Software Security Mapping\nFramework, a structured solution designed to operationalize security\nrequirements across hierarchical levels -- from high-level regulatory standards\n(e.g., ISM, Australia cybersecurity standard published by the Australian\nSignals Directorate), through mid-level frameworks (e.g., NIST SSDF, the U.S.\nSecure Software Development Framework), to fine-grained technical activities\n(e.g., SLSA, a software supply chain security framework). Developed through\ncollaborative research with academic experts and industry practitioners, the\nframework systematically maps 131 refined security requirements to over 400\nactionable operational steps spanning the software development lifecycle. It is\ngrounded in four core security goals: Secure Software Environment, Secure\nSoftware Development, Software Traceability, and Vulnerability Management. Our\napproach leverages the KAOS goal modeling methodology to establish traceable\nlinkages between strategic goals and tactical operations, enhancing clarity,\naccountability, and practical implementation. To facilitate adoption, we\nprovide a web-based navigation tool for interactive exploration of the\nframework. A real-world case study based on the Log4j vulnerability illustrates\nthe framework's utility by generating a tailored checklist aligned with\nindustry best practices. Additionally, we offer a structured, machine-readable\nOSCAL Catalog Model of the Software Security Mapping Framework, enabling\norganizations to automate implementation, streamline compliance processes, and\nrespond effectively to evolving security risks."}
{"id": "2506.11127", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11127", "abs": "https://arxiv.org/abs/2506.11127", "authors": ["Wenkang Han", "Zhixiong Zeng", "Jing Huang", "Shu Jiang", "Liming Zheng", "Longrong Yang", "Haibo Qiu", "Chang Yao", "Jingyuan Chen", "Lin Ma"], "title": "GUIRoboTron-Speech: Towards Automated GUI Agents Based on Speech Instructions", "comment": null, "summary": "Autonomous agents for Graphical User Interfaces (GUIs) are revolutionizing\nhuman-computer interaction, yet their reliance on text-based instructions\nimposes limitations on accessibility and convenience, particularly in\nhands-free scenarios. To address this gap, we propose GUIRoboTron-Speech, the\nfirst end-to-end autonomous GUI agent that directly accepts speech instructions\nand on-device screenshots to predict actions. Confronted with the scarcity of\nspeech-based GUI agent datasets, we initially generated high-quality speech\ninstructions for training by leveraging a random timbre text-to-speech (TTS)\nmodel to convert existing text instructions. We then develop\nGUIRoboTron-Speech's capabilities through progressive grounding and planning\ntraining stages. A key contribution is a heuristic mixed-instruction training\nstrategy designed to mitigate the modality imbalance inherent in pre-trained\nfoundation models. Comprehensive experiments on several benchmark datasets\nvalidate the robust and superior performance of GUIRoboTron-Speech,\ndemonstrating the significant potential and widespread applicability of speech\nas an effective instruction modality for driving GUI agents. Our code and\ndatasets are available at https://github.com/GUIRoboTron/GUIRoboTron-Speech."}
{"id": "2506.11058", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11058", "abs": "https://arxiv.org/abs/2506.11058", "authors": ["Ziga Kovacic", "Celine Lee", "Justin Chiu", "Wenting Zhao", "Kevin Ellis"], "title": "Refactoring Codebases through Library Design", "comment": "26 pages", "summary": "Maintainable and general software allows developers to build robust\napplications efficiently, yet achieving these qualities often requires\nrefactoring specialized solutions into reusable components. This challenge\nbecomes particularly relevant as code agents become increasingly accurate at\nsolving isolated programming problems. We investigate code agents' capacity to\nrefactor code in ways supporting growth and reusability. We present both a\nmethod and a benchmark for refactoring: Librarian, a sample-and-rerank method\nfor generating reusable libraries, and Minicode, a benchmark where code agents\nmust minimize and refactor multiple independent solutions into a joint library.\nCompared to state-of-the-art code agents, Librarian achieves strong results on\nboth compression and correctness on Minicode, obtaining compression rates\n1.6-2x better than coding agents while also improving correctness. We\nopen-source our code and benchmark at https://code-refactor.github.io/."}
{"id": "2506.11128", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11128", "abs": "https://arxiv.org/abs/2506.11128", "authors": ["Andrew Keenan Richardson", "Ryan Othniel Kearns", "Sean Moss", "Vincent Wang-Mascianica", "Philipp Koralus"], "title": "Stronger Language Models Produce More Human-Like Errors", "comment": null, "summary": "Do language models converge toward human-like reasoning patterns as they\nimprove? We provide surprising evidence that while overall reasoning\ncapabilities increase with model sophistication, the nature of errors\nincreasingly mirrors predictable human reasoning fallacies: a previously\nunobserved inverse scaling phenomenon. To investigate this question, we apply\nthe Erotetic Theory of Reasoning (ETR), a formal cognitive framework with\nempirical support for predicting human reasoning outcomes. Using the\nopen-source package PyETR, we generate logical reasoning problems where humans\npredictably err, evaluating responses from 38 language models across 383\nreasoning tasks. Our analysis indicates that as models advance in general\ncapability (as measured by Chatbot Arena scores), the proportion of their\nincorrect answers that align with ETR-predicted human fallacies tends to\nincrease ($\\rho = 0.360, p = 0.0265$). Notably, as we observe no correlation\nbetween model sophistication and logical correctness on these tasks, this shift\nin error patterns toward human-likeness occurs independently of error rate.\nThese findings challenge the prevailing view that scaling language models\nnaturally obtains normative rationality, suggesting instead a convergence\ntoward human-like cognition inclusive of our characteristic biases and\nlimitations, as we further confirm by demonstrating order-effects in language\nmodel reasoning."}
{"id": "2506.11059", "categories": ["cs.SE", "cs.CL", "cs.CY", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11059", "abs": "https://arxiv.org/abs/2506.11059", "authors": ["Hanxi Guo", "Siyuan Cheng", "Kaiyuan Zhang", "Guangyu Shen", "Xiangyu Zhang"], "title": "CodeMirage: A Multi-Lingual Benchmark for Detecting AI-Generated and Paraphrased Source Code from Production-Level LLMs", "comment": null, "summary": "Large language models (LLMs) have become integral to modern software\ndevelopment, producing vast amounts of AI-generated source code. While these\nmodels boost programming productivity, their misuse introduces critical risks,\nincluding code plagiarism, license violations, and the propagation of insecure\nprograms. As a result, robust detection of AI-generated code is essential. To\nsupport the development of such detectors, a comprehensive benchmark that\nreflects real-world conditions is crucial. However, existing benchmarks fall\nshort -- most cover only a limited set of programming languages and rely on\nless capable generative models. In this paper, we present CodeMirage, a\ncomprehensive benchmark that addresses these limitations through three major\nadvancements: (1) it spans ten widely used programming languages, (2) includes\nboth original and paraphrased code samples, and (3) incorporates outputs from\nten state-of-the-art production-level LLMs, including both reasoning and\nnon-reasoning models from six major providers. Using CodeMirage, we evaluate\nten representative detectors across four methodological paradigms under four\nrealistic evaluation configurations, reporting results using three\ncomplementary metrics. Our analysis reveals nine key findings that uncover the\nstrengths and weaknesses of current detectors, and identify critical challenges\nfor future work. We believe CodeMirage offers a rigorous and practical testbed\nto advance the development of robust and generalizable AI-generated code\ndetectors."}
{"id": "2506.11129", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11129", "abs": "https://arxiv.org/abs/2506.11129", "authors": ["Carlos Garcia-Fernandez", "Luis Felipe", "Monique Shotande", "Muntasir Zitu", "Aakash Tripathi", "Ghulam Rasool", "Issam El Naqa", "Vivek Rudrapatna", "Gilmer Valdes"], "title": "Trustworthy AI for Medicine: Continuous Hallucination Detection and Elimination with CHECK", "comment": null, "summary": "Large language models (LLMs) show promise in healthcare, but hallucinations\nremain a major barrier to clinical use. We present CHECK, a continuous-learning\nframework that integrates structured clinical databases with a classifier\ngrounded in information theory to detect both factual and reasoning-based\nhallucinations. Evaluated on 1500 questions from 100 pivotal clinical trials,\nCHECK reduced LLama3.3-70B-Instruct hallucination rates from 31% to 0.3% -\nmaking an open source model state of the art. Its classifier generalized across\nmedical benchmarks, achieving AUCs of 0.95-0.96, including on the MedQA (USMLE)\nbenchmark and HealthBench realistic multi-turn medical questioning. By\nleveraging hallucination probabilities to guide GPT-4o's refinement and\njudiciously escalate compute, CHECK boosted its USMLE passing rate by 5\npercentage points, achieving a state-of-the-art 92.1%. By suppressing\nhallucinations below accepted clinical error thresholds, CHECK offers a\nscalable foundation for safe LLM deployment in medicine and other high-stakes\ndomains."}
{"id": "2506.11060", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11060", "abs": "https://arxiv.org/abs/2506.11060", "authors": ["Ramneet Singh", "Sathvik Joel", "Abhav Mehrotra", "Nalin Wadhwa", "Ramakrishna B Bairi", "Aditya Kanade", "Nagarajan Natarajan"], "title": "Code Researcher: Deep Research Agent for Large Systems Code and Commit History", "comment": null, "summary": "Large Language Model (LLM)-based coding agents have shown promising results\non coding benchmarks, but their effectiveness on systems code remains\nunderexplored. Due to the size and complexities of systems code, making changes\nto a systems codebase is a daunting task, even for humans. It requires\nresearching about many pieces of context, derived from the large codebase and\nits massive commit history, before making changes. Inspired by the recent\nprogress on deep research agents, we design the first deep research agent for\ncode, called Code Researcher, and apply it to the problem of generating patches\nfor mitigating crashes reported in systems code. Code Researcher performs\nmulti-step reasoning about semantics, patterns, and commit history of code to\ngather sufficient context. The context is stored in a structured memory which\nis used for synthesizing a patch. We evaluate Code Researcher on kBenchSyz, a\nbenchmark of Linux kernel crashes, and show that it significantly outperforms\nstrong baselines, achieving a crash-resolution rate of 58%, compared to 37.5%\nby SWE-agent. On an average, Code Researcher explores 10 files in each\ntrajectory whereas SWE-agent explores only 1.33 files, highlighting Code\nResearcher's ability to deeply explore the codebase. Through another experiment\non an open-source multimedia software, we show the generalizability of Code\nResearcher. Our experiments highlight the importance of global context\ngathering and multi-faceted reasoning for large codebases."}
{"id": "2506.11130", "categories": ["cs.CL", "cs.AI", "cs.SD", "eess.AS"], "pdf": "https://arxiv.org/pdf/2506.11130", "abs": "https://arxiv.org/abs/2506.11130", "authors": ["Cheng Kang Chou", "Chan-Jan Hsu", "Ho-Lam Chung", "Liang-Hsuan Tseng", "Hsi-Chun Cheng", "Yu-Kuan Fu", "Kuan Po Huang", "Hung-Yi Lee"], "title": "A Self-Refining Framework for Enhancing ASR Using TTS-Synthesized Data", "comment": null, "summary": "We propose a self-refining framework that enhances ASR performance with only\nunlabeled datasets. The process starts with an existing ASR model generating\npseudo-labels on unannotated speech, which are then used to train a\nhigh-fidelity text-to-speech (TTS) system. Then, synthesized speech text pairs\nare bootstrapped into the original ASR system, completing the closed-loop\nself-improvement cycle. We demonstrated the effectiveness of the framework on\nTaiwanese Mandarin speech. Leveraging 6,000 hours of unlabeled speech, a\nmoderate amount of text data, and synthetic content from the AI models, we\nadapt Whisper-large-v2 into a specialized model, Twister. Twister reduces error\nrates by up to 20% on Mandarin and 50% on Mandarin-English code-switching\nbenchmarks compared to Whisper. Results highlight the framework as a compelling\nalternative to pseudo-labeling self-distillation approaches and provides a\npractical pathway for improving ASR performance in low-resource or\ndomain-specific settings."}
{"id": "2506.11066", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11066", "abs": "https://arxiv.org/abs/2506.11066", "authors": ["Jiahui Geng", "Fengyu Cai", "Shaobo Cui", "Qing Li", "Liangwei Chen", "Chenyang Lyu", "Haonan Li", "Derui Zhu", "Walter Pretschner", "Heinz Koeppl", "Fakhri Karray"], "title": "CoQuIR: A Comprehensive Benchmark for Code Quality-Aware Information Retrieval", "comment": null, "summary": "Code retrieval is essential in modern software development, as it boosts code\nreuse and accelerates debugging. However, current benchmarks primarily\nemphasize functional relevance while neglecting critical dimensions of software\nquality. Motivated by this gap, we introduce CoQuIR, the first large-scale,\nmultilingual benchmark specifically designed to evaluate quality-aware code\nretrieval across four key dimensions: correctness, efficiency, security, and\nmaintainability. CoQuIR provides fine-grained quality annotations for 42,725\nqueries and 134,907 code snippets in 11 programming languages, and is\naccompanied by two quality-centric evaluation metrics: Pairwise Preference\nAccuracy and Margin-based Ranking Score. Using CoQuIR, we benchmark 23\nretrieval models, covering both open-source and proprietary systems, and find\nthat even top-performing models frequently fail to distinguish buggy or\ninsecure code from their more robust counterparts. Furthermore, we conduct\npreliminary investigations into training methods that explicitly encourage\nretrievers to recognize code quality. Using synthetic datasets, we demonstrate\npromising improvements in quality-aware metrics across various models, without\nsacrificing semantic relevance. Downstream code generation experiments further\nvalidate the effectiveness of our approach. Overall, our work highlights the\nimportance of integrating quality signals into code retrieval systems, laying\nthe groundwork for more trustworthy and robust software development tools."}
{"id": "2506.11135", "categories": ["cs.CL", "cs.AI", "cs.LG", "cs.NE"], "pdf": "https://arxiv.org/pdf/2506.11135", "abs": "https://arxiv.org/abs/2506.11135", "authors": ["David C. Krakauer", "John W. Krakauer", "Melanie Mitchell"], "title": "Large Language Models and Emergence: A Complex Systems Perspective", "comment": null, "summary": "Emergence is a concept in complexity science that describes how many-body\nsystems manifest novel higher-level properties, properties that can be\ndescribed by replacing high-dimensional mechanisms with lower-dimensional\neffective variables and theories. This is captured by the idea \"more is\ndifferent\". Intelligence is a consummate emergent property manifesting\nincreasingly efficient -- cheaper and faster -- uses of emergent capabilities\nto solve problems. This is captured by the idea \"less is more\". In this paper,\nwe first examine claims that Large Language Models exhibit emergent\ncapabilities, reviewing several approaches to quantifying emergence, and\nsecondly ask whether LLMs possess emergent intelligence."}
{"id": "2506.11076", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11076", "abs": "https://arxiv.org/abs/2506.11076", "authors": ["Minyu Chen", "Guoqiang Li", "Ling-I Wu", "Ruibang Liu"], "title": "DCE-LLM: Dead Code Elimination with Large Language Models", "comment": "Accepted by regular paper in NAACL 2025, with 13 pages, 5 figures", "summary": "Dead code introduces several challenges in software development, such as\nincreased binary size and maintenance difficulties. It can also obscure logical\nerrors and be exploited for obfuscation in malware. For LLM-based code-related\ntasks, dead code introduces vulnerabilities that can mislead these models,\nraising security concerns. Although modern compilers and IDEs offer dead code\nelimination, sophisticated patterns can bypass these tools. A universal\napproach that includes classification, location, explanation, and correction is\nneeded, yet current tools often require significant manual effort. We present\nDCE-LLM, a framework for automated dead code elimination using a small CodeBERT\nmodel with an attribution-based line selector to efficiently locate suspect\ncode. LLMs then generate judgments and explanations, fine-tuned on a\nlarge-scale, annotated dead code dataset to provide detailed explanations and\npatches. DCE-LLM outperforms existing tools, with advanced unreachability\ndetection, automated correction, and support for multiple programming\nlanguages. Experimental results show DCE-LLM achieves over 94% F1 scores for\nunused and unreachable code, significantly surpassing GPT-4o by 30%."}
{"id": "2506.11137", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11137", "abs": "https://arxiv.org/abs/2506.11137", "authors": ["Chong Shao", "Douglas Snyder", "Chiran Li", "Bowen Gu", "Kerry Ngan", "Chun-Ting Yang", "Jiageng Wu", "Richard Wyss", "Kueiyu Joshua Lin", "Jie Yang"], "title": "Scalable Medication Extraction and Discontinuation Identification from Electronic Health Records Using Large Language Models", "comment": "preprint, under review", "summary": "Identifying medication discontinuations in electronic health records (EHRs)\nis vital for patient safety but is often hindered by information being buried\nin unstructured notes. This study aims to evaluate the capabilities of advanced\nopen-sourced and proprietary large language models (LLMs) in extracting\nmedications and classifying their medication status from EHR notes, focusing on\ntheir scalability on medication information extraction without human\nannotation. We collected three EHR datasets from diverse sources to build the\nevaluation benchmark. We evaluated 12 advanced LLMs and explored multiple LLM\nprompting strategies. Performance on medication extraction, medication status\nclassification, and their joint task (extraction then classification) was\nsystematically compared across all experiments. We found that LLMs showed\npromising performance on the medication extraction and discontinuation\nclassification from EHR notes. GPT-4o consistently achieved the highest average\nF1 scores in all tasks under zero-shot setting - 94.0% for medication\nextraction, 78.1% for discontinuation classification, and 72.7% for the joint\ntask. Open-sourced models followed closely, Llama-3.1-70B-Instruct achieved the\nhighest performance in medication status classification on the MIV-Med dataset\n(68.7%) and in the joint task on both the Re-CASI (76.2%) and MIV-Med (60.2%)\ndatasets. Medical-specific LLMs demonstrated lower performance compared to\nadvanced general-domain LLMs. Few-shot learning generally improved performance,\nwhile CoT reasoning showed inconsistent gains. LLMs demonstrate strong\npotential for medication extraction and discontinuation identification on EHR\nnotes, with open-sourced models offering scalable alternatives to proprietary\nsystems and few-shot can further improve LLMs' capability."}
{"id": "2506.11084", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11084", "abs": "https://arxiv.org/abs/2506.11084", "authors": ["Yordan Kalmukov"], "title": "Research and Analysis of Employers' Opinion on the Necessary Skills that Students in the Field of Web Programming Should Possess", "comment": null, "summary": "In the era of artificial intelligence (AI) and chatbots, based on large\nlanguage models that can generate programming code in any language, write texts\nand summarize information, it is obvious that the requirements of employers for\ngraduating students have already changed. The modern IT world offers\nsignificant automation of programming through software frameworks and a huge\nset of third-party libraries and application programming interfaces (APIs). All\nthese tools provide most of the necessary functionality out of the box (already\nimplemented), and quite naturally the question arises as to what is more useful\nfor students - to teach how to use these ready-made tools or the basic\nprinciples of working and development of web applications from scratch. This\npaper analyzes the results of a survey conducted among IT employers, aimed to\nidentify what, in their opinion, are the necessary technical skills that\ngraduating students in the field of Web Programming should possess in order to\njoin the company's work as quickly and effectively as possible."}
{"id": "2506.11243", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11243", "abs": "https://arxiv.org/abs/2506.11243", "authors": ["Santiago Góngora", "Ignacio Sastre", "Santiago Robaina", "Ignacio Remersaro", "Luis Chiruzzo", "Aiala Rosá"], "title": "RETUYT-INCO at BEA 2025 Shared Task: How Far Can Lightweight Models Go in AI-powered Tutor Evaluation?", "comment": "This paper will be presented at the 20th BEA Workshop (Innovative Use\n  of NLP for Building Educational Applications) at ACL 2025", "summary": "In this paper, we present the RETUYT-INCO participation at the BEA 2025\nshared task. Our participation was characterized by the decision of using\nrelatively small models, with fewer than 1B parameters. This self-imposed\nrestriction tries to represent the conditions in which many research labs or\ninstitutions are in the Global South, where computational power is not easily\naccessible due to its prohibitive cost. Even under this restrictive\nself-imposed setting, our models managed to stay competitive with the rest of\nteams that participated in the shared task. According to the $exact\\ F_1$\nscores published by the organizers, the performance gaps between our models and\nthe winners were as follows: $6.46$ in Track 1; $10.24$ in Track 2; $7.85$ in\nTrack 3; $9.56$ in Track 4; and $13.13$ in Track 5. Considering that the\nminimum difference with a winner team is $6.46$ points -- and the maximum\ndifference is $13.13$ -- according to the $exact\\ F_1$ score, we find that\nmodels with a size smaller than 1B parameters are competitive for these tasks,\nall of which can be run on computers with a low-budget GPU or even without a\nGPU."}
{"id": "2506.11085", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.IR", "cs.LG", "cs.LO", "I.2.6; H.3.3; I.2.3"], "pdf": "https://arxiv.org/pdf/2506.11085", "abs": "https://arxiv.org/abs/2506.11085", "authors": ["Justin Asher"], "title": "LeanExplore: A search engine for Lean 4 declarations", "comment": "16 pages, 1 figure. Project website: https://www.leanexplore.com/ ,\n  Code: https://github.com/justincasher/lean-explore", "summary": "The expanding Lean 4 ecosystem poses challenges for navigating its vast\nlibraries. This paper introduces LeanExplore, a search engine for Lean 4\ndeclarations. LeanExplore enables users to semantically search for statements,\nboth formally and informally, across select Lean 4 packages (including\nBatteries, Init, Lean, Mathlib, PhysLean, and Std). This search capability is\npowered by a hybrid ranking strategy, integrating scores from a multi-source\nsemantic embedding model (capturing conceptual meaning from formal Lean code,\ndocstrings, AI-generated informal translations, and declaration titles), BM25+\nfor keyword-based lexical relevance, and a PageRank-based score reflecting\ndeclaration importance and interconnectedness. The search engine is accessible\nvia a dedicated website (https://www.leanexplore.com/) and a Python API\n(https://github.com/justincasher/lean-explore). Furthermore, the database can\nbe downloaded, allowing users to self-host the service. LeanExplore integrates\neasily with LLMs via the model context protocol (MCP), enabling users to chat\nwith an AI assistant about Lean declarations or utilize the search engine for\nbuilding theorem-proving agents. This work details LeanExplore's architecture,\ndata processing, functionalities, and its potential to enhance Lean 4 workflows\nand AI-driven mathematical research"}
{"id": "2506.11244", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11244", "abs": "https://arxiv.org/abs/2506.11244", "authors": ["Shun Shao", "Yftah Ziser", "Zheng Zhao", "Yifu Qiu", "Shay B. Cohen", "Anna Korhonen"], "title": "Iterative Multilingual Spectral Attribute Erasure", "comment": "8 pages, 3 figures", "summary": "Multilingual representations embed words with similar meanings to share a\ncommon semantic space across languages, creating opportunities to transfer\ndebiasing effects between languages. However, existing methods for debiasing\nare unable to exploit this opportunity because they operate on individual\nlanguages. We present Iterative Multilingual Spectral Attribute Erasure\n(IMSAE), which identifies and mitigates joint bias subspaces across multiple\nlanguages through iterative SVD-based truncation. Evaluating IMSAE across eight\nlanguages and five demographic dimensions, we demonstrate its effectiveness in\nboth standard and zero-shot settings, where target language data is\nunavailable, but linguistically similar languages can be used for debiasing.\nOur comprehensive experiments across diverse language models (BERT, LLaMA,\nMistral) show that IMSAE outperforms traditional monolingual and cross-lingual\napproaches while maintaining model utility."}
{"id": "2506.11107", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11107", "abs": "https://arxiv.org/abs/2506.11107", "authors": ["Weibo Gao", "Qi Liu", "Rui Li", "Yuze Zhao", "Hao Wang", "Linan Yre", "Fangzhou Yao", "Zheng Zhang"], "title": "Denoising Programming Knowledge Tracing with a Code Graph-based Tuning Adaptor", "comment": "Accepted by KDD August 2025", "summary": "Programming Knowledge Tracking (PKT) aims to dynamically diagnose learners'\nmastery levels of programming knowledge based on their coding activities,\nfacilitating more effective and personalized programming education. However,\ncurrent PKT studies primarily focus on the implicit relationship between code\ncontent and knowledge assessment, often overlooking two types of noise signals\nin long-term programming activities: unwanted signals from unrelated\nsubmissions and weak signals from minor modifications. This practical challenge\nsignificantly limits model performance and application. To address this issue,\nwe propose Coda, a Code graph-based tuning adaptor designed to enhance existing\nPKT models by identifying and mitigating the impact of noise. Specifically,\nCoda first transforms the loose code sequences submitted by each learner into a\ncompact code graph. By leveraging this code graph, unwanted signals can be\nidentified from a semantic similarity perspective. We then apply a\ncluster-aware GCN to the code graph, which improves the discrimination of weak\nsignals and enables their clustering for identification. Finally, a lightweight\nyet effective adaptor is incorporated into the PKT task through optimization\nwith two noise feature-based constraints and a navigational regularization\nterm, to correct knowledge states affected by noise. It is worth mentioning\nthat the Coda framework is model-agnostic and can be adapted to most existing\nPKT solutions. Extensive experimental results on four real-world datasets\ndemonstrate that Coda effectively performs the PKT task in the presence of\nnoisy programming records, outperforming typical baselines."}
{"id": "2506.11246", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11246", "abs": "https://arxiv.org/abs/2506.11246", "authors": ["Kushagra Dixit", "Abhishek Rajgaria", "Harshavardhan Kalalbandi", "Dan Roth", "Vivek Gupta"], "title": "No Universal Prompt: Unifying Reasoning through Adaptive Prompting for Temporal Table Reasoning", "comment": "21 pages, 19 Tables, 9 Figures", "summary": "Temporal Table Reasoning is a critical challenge for Large Language Models\n(LLMs), requiring effective prompting techniques to extract relevant insights.\nDespite existence of multiple prompting methods, their impact on table\nreasoning remains largely unexplored. Furthermore, the performance of these\nmodels varies drastically across different table and context structures, making\nit difficult to determine an optimal approach. This work investigates multiple\nprompting technique across diverse table types to determine optimal approaches\nfor different scenarios. We find that performance varies based on entity type,\ntable structure, requirement of additional context and question complexity,\nwith NO single method consistently outperforming others. To mitigate these\nchallenges, we introduce SEAR, an adaptive prompting framework inspired by\nhuman reasoning that dynamically adjusts based on context characteristics and\nintegrates a structured reasoning. Our results demonstrate that SEAR achieves\nsuperior performance across all table types compared to other baseline\nprompting techniques. Additionally, we explore the impact of table structure\nrefactoring, finding that a unified representation enhances model's reasoning."}
{"id": "2506.11141", "categories": ["cs.SE", "cs.ET"], "pdf": "https://arxiv.org/pdf/2506.11141", "abs": "https://arxiv.org/abs/2506.11141", "authors": ["Philippe J. Giabbanelli", "John Beverley", "Istvan David", "Andreas Tolk"], "title": "From over-reliance to smart integration: using Large-Language Models as translators between specialized modeling and simulation tools", "comment": "Accepted at the Winter Simulation conference 2025, December, Seattle\n  USA", "summary": "Large Language Models (LLMs) offer transformative potential for Modeling &\nSimulation (M&S) through natural language interfaces that simplify workflows.\nHowever, over-reliance risks compromising quality due to ambiguities, logical\nshortcuts, and hallucinations. This paper advocates integrating LLMs as\nmiddleware or translators between specialized tools to mitigate complexity in\nM&S tasks. Acting as translators, LLMs can enhance interoperability across\nmulti-formalism, multi-semantics, and multi-paradigm systems. We address two\nkey challenges: identifying appropriate languages and tools for modeling and\nsimulation tasks, and developing efficient software architectures that\nintegrate LLMs without performance bottlenecks. To this end, the paper explores\nLLM-mediated workflows, emphasizes structured tool integration, and recommends\nLow-Rank Adaptation-based architectures for efficient task-specific\nadaptations. This approach ensures LLMs complement rather than replace\nspecialized tools, fostering high-quality, reliable M&S processes."}
{"id": "2506.11274", "categories": ["cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11274", "abs": "https://arxiv.org/abs/2506.11274", "authors": ["Liran Ringel", "Elad Tolochinsky", "Yaniv Romano"], "title": "Learning a Continue-Thinking Token for Enhanced Test-Time Scaling", "comment": null, "summary": "Test-time scaling has emerged as an effective approach for improving language\nmodel performance by utilizing additional compute at inference time. Recent\nstudies have shown that overriding end-of-thinking tokens (e.g., replacing\n\"</think>\" with \"Wait\") can extend reasoning steps and improve accuracy. In\nthis work, we explore whether a dedicated continue-thinking token can be\nlearned to trigger extended reasoning. We augment a distilled version of\nDeepSeek-R1 with a single learned \"<|continue-thinking|>\" token, training only\nits embedding via reinforcement learning while keeping the model weights\nfrozen. Our experiments show that this learned token achieves improved accuracy\non standard math benchmarks compared to both the baseline model and a test-time\nscaling approach that uses a fixed token (e.g., \"Wait\") for budget forcing. In\nparticular, we observe that in cases where the fixed-token approach enhances\nthe base model's accuracy, our method achieves a markedly greater improvement.\nFor example, on the GSM8K benchmark, the fixed-token approach yields a 1.3%\nabsolute improvement in accuracy, whereas our learned-token method achieves a\n4.2% improvement over the base model that does not use budget forcing."}
{"id": "2506.11153", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11153", "abs": "https://arxiv.org/abs/2506.11153", "authors": ["Changxin Ke", "Rui Zhang", "Shuo Wang", "Li Ding", "Guangli Li", "Yuanbo Wen", "Shuoming Zhang", "Ruiyuan Xu", "Jin Qin", "Jiaming Guo", "Chenxi Wang", "Ling Li", "Qi Guo", "Yunji Chen"], "title": "Mutual-Supervised Learning for Sequential-to-Parallel Code Translation", "comment": "28 pages", "summary": "The rise of GPU-based high-performance computing (HPC) has driven the\nwidespread adoption of parallel programming models such as CUDA. Yet, the\ninherent complexity of parallel programming creates a demand for the automated\nsequential-to-parallel approaches. However, data scarcity poses a significant\nchallenge for machine learning-based sequential-to-parallel code translation.\nAlthough recent back-translation methods show promise, they still fail to\nensure functional equivalence in the translated code. In this paper, we propose\na novel Mutual-Supervised Learning (MSL) framework for sequential-to-parallel\ncode translation to address the functional equivalence issue. MSL consists of\ntwo models, a Translator and a Tester. Through an iterative loop consisting of\nCo-verify and Co-evolve steps, the Translator and the Tester mutually generate\ndata for each other and improve collectively. The Tester generates unit tests\nto verify and filter functionally equivalent translated code, thereby evolving\nthe Translator, while the Translator generates translated code as augmented\ninput to evolve the Tester. Experimental results demonstrate that MuSL\nsignificantly enhances the performance of the base model: when applied to\nQwen2.5-Coder, it not only improves Pass@1 by up to 28.91% and boosts Tester\nperformance by 68.90%, but also outperforms the previous state-of-the-art\nmethod CodeRosetta by 1.56 and 6.92 in BLEU and CodeBLEU scores, while\nachieving performance comparable to DeepSeek-R1 and GPT-4.1. Our code is\navailable at https://github.com/kcxain/musl."}
{"id": "2506.11300", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11300", "abs": "https://arxiv.org/abs/2506.11300", "authors": ["Yang Zhang", "Amr Mohamed", "Hadi Abdine", "Guokan Shang", "Michalis Vazirgiannis"], "title": "Beyond Random Sampling: Efficient Language Model Pretraining via Curriculum Learning", "comment": null, "summary": "Curriculum learning has shown promise in improving training efficiency and\ngeneralization in various machine learning domains, yet its potential in\npretraining language models remains underexplored, prompting our work as the\nfirst systematic investigation in this area. We experimented with different\nsettings, including vanilla curriculum learning, pacing-based sampling, and\ninterleaved curricula-guided by six difficulty metrics spanning linguistic and\ninformation-theoretic perspectives. We train models under these settings and\nevaluate their performance on eight diverse benchmarks. Our experiments reveal\nthat curriculum learning consistently improves convergence in early and\nmid-training phases, and can yield lasting gains when used as a warmup strategy\nwith up to $3.5\\%$ improvement. Notably, we identify compression ratio, lexical\ndiversity, and readability as effective difficulty signals across settings. Our\nfindings highlight the importance of data ordering in large-scale pretraining\nand provide actionable insights for scalable, data-efficient model development\nunder realistic training scenarios."}
{"id": "2506.11176", "categories": ["cs.SE", "cs.DC", "cs.DM", "cs.ET"], "pdf": "https://arxiv.org/pdf/2506.11176", "abs": "https://arxiv.org/abs/2506.11176", "authors": ["Anatoly A. Krasnovsky", "Alexander Zorkin"], "title": "Model Discovery and Graph Simulation: A Lightweight Alternative to Chaos Engineering", "comment": null, "summary": "Microservice applications are prone to cascading failures because of dense\ninter-service dependencies. Ensuring resilience usually demands fault-injection\nexperiments in production-like setups. We propose \\textit{model discovery} --\nan automated CI/CD step that extracts a live dependency graph from trace data\n-- and show that this lightweight representation is sufficient for accurate\nresilience prediction. Using the DeathStarBench Social Network, we build the\ngraph, simulate failures via Monte-Carlo, and run matching chaos experiments on\nthe real system. The graph model closely matches reality: with no replication,\n16 trials yield an observed resilience of 0.186 versus a predicted 0.161; with\nreplication, both observed and predicted values converge to 0.305 (mean\nabsolute error \\leq 0.0004). These results indicate that even a simple,\nautomatically discovered graph can estimate microservice availability with high\nfidelity, offering rapid design-time insight without full-scale failure\ntesting."}
{"id": "2506.11305", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11305", "abs": "https://arxiv.org/abs/2506.11305", "authors": ["Mohammad Hammoud", "Devang Acharya"], "title": "Don't Pay Attention", "comment": null, "summary": "The Transformer has become the de facto standard for large language models\nand a wide range of downstream tasks across various domains. Despite its\nnumerous advantages like inherent training parallelism, the Transformer still\nfaces key challenges due to its inability to effectively process sequences\nbeyond a fixed context window and the quadratic complexity of its attention\nmechanism. These challenges have renewed interest in RNN-like architectures,\nwhich offer linear scaling with sequence length and improved handling of\nlong-range dependencies, albeit with limited parallelism due to their\ninherently recurrent nature. In this paper, we propose Avey, a new neural\nfoundational architecture that breaks away from both attention and recurrence.\nAvey comprises a ranker and an autoregressive neural processor, which\ncollaboratively identify and contextualize only the most relevant tokens for\nany given token, regardless of their positions in the sequence. Specifically,\nAvey decouples sequence length from context width, thus enabling effective\nprocessing of arbitrarily long sequences. Experimental results show that Avey\ncompares favorably to the Transformer across a variety of standard short-range\nNLP benchmarks, while notably excelling at capturing long-range dependencies."}
{"id": "2506.11180", "categories": ["cs.SE", "cs.AI", "cs.ET", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2506.11180", "abs": "https://arxiv.org/abs/2506.11180", "authors": ["Luis Miguel Vieira da Silva", "Aljosha Köcher", "Felix Gehlhoff"], "title": "Beyond Formal Semantics for Capabilities and Skills: Model Context Protocol in Manufacturing", "comment": null, "summary": "Explicit modeling of capabilities and skills -- whether based on ontologies,\nAsset Administration Shells, or other technologies -- requires considerable\nmanual effort and often results in representations that are not easily\naccessible to Large Language Models (LLMs). In this work-in-progress paper, we\npresent an alternative approach based on the recently introduced Model Context\nProtocol (MCP). MCP allows systems to expose functionality through a\nstandardized interface that is directly consumable by LLM-based agents. We\nconduct a prototypical evaluation on a laboratory-scale manufacturing system,\nwhere resource functions are made available via MCP. A general-purpose LLM is\nthen tasked with planning and executing a multi-step process, including\nconstraint handling and the invocation of resource functions via MCP. The\nresults indicate that such an approach can enable flexible industrial\nautomation without relying on explicit semantic models. This work lays the\nbasis for further exploration of external tool integration in LLM-driven\nproduction systems."}
{"id": "2506.11338", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11338", "abs": "https://arxiv.org/abs/2506.11338", "authors": ["Yi-Chien Lin", "William Schuler"], "title": "Surprisal from Larger Transformer-based Language Models Predicts fMRI Data More Poorly", "comment": null, "summary": "As Transformers become more widely incorporated into natural language\nprocessing tasks, there has been considerable interest in using surprisal from\nthese models as predictors of human sentence processing difficulty. Recent work\nhas observed a positive relationship between Transformer-based models'\nperplexity and the predictive power of their surprisal estimates on reading\ntimes, showing that language models with more parameters and trained on more\ndata are less predictive of human reading times. However, these studies focus\non predicting latency-based measures (i.e., self-paced reading times and\neye-gaze durations) with surprisal estimates from Transformer-based language\nmodels. This trend has not been tested on brain imaging data. This study\ntherefore evaluates the predictive power of surprisal estimates from 17\npre-trained Transformer-based models across three different language families\non two functional magnetic resonance imaging datasets. Results show that the\npositive relationship between model perplexity and model fit still obtains,\nsuggesting that this trend is not specific to latency-based measures and can be\ngeneralized to neural measures."}
{"id": "2506.11237", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11237", "abs": "https://arxiv.org/abs/2506.11237", "authors": ["Ngoc Phuoc An Vo", "Brent Paulovicks", "Vadim Sheinin"], "title": "LLM-as-a-Judge for Reference-less Automatic Code Validation and Refinement for Natural Language to Bash in IT Automation", "comment": "10 pages", "summary": "In an effort to automatically evaluate and select the best model and improve\ncode quality for automatic incident remediation in IT Automation, it is crucial\nto verify if the generated code for remediation action is syntactically and\nsemantically correct and whether it can be executed correctly as intended.\nThere are three approaches: 1) conventional methods use surface form similarity\nmetrics (token match, exact match, etc.) which have numerous limitations, 2)\nexecution-based evaluation focuses more on code functionality based on\npass/fail judgments for given test-cases, and 3) LLM-as-a-Judge employs LLMs\nfor automated evaluation to judge if it is a correct answer for a given problem\nbased on pre-defined metrics. In this work, we focused on enhancing\nLLM-as-a-Judge using bidirectional functionality matching and logic\nrepresentation for reference-less automatic validation and refinement for Bash\ncode generation to select the best model for automatic incident remediation in\nIT Automation. We used execution-based evaluation as ground-truth to evaluate\nour LLM-as-a-Judge metrics. Results show high accuracy and agreement with\nexecution-based evaluation (and up to 8% over baseline). Finally, we built\nReflection code agents to utilize judgments and feedback from our evaluation\nmetrics which achieved significant improvement (up to 24% increase in accuracy)\nfor automatic code refinement."}
{"id": "2506.11343", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11343", "abs": "https://arxiv.org/abs/2506.11343", "authors": ["Yaohui Zhang", "Haijing Zhang", "Wenlong Ji", "Tianyu Hua", "Nick Haber", "Hancheng Cao", "Weixin Liang"], "title": "From Replication to Redesign: Exploring Pairwise Comparisons for LLM-Based Peer Review", "comment": null, "summary": "The advent of large language models (LLMs) offers unprecedented opportunities\nto reimagine peer review beyond the constraints of traditional workflows.\nDespite these opportunities, prior efforts have largely focused on replicating\ntraditional review workflows with LLMs serving as direct substitutes for human\nreviewers, while limited attention has been given to exploring new paradigms\nthat fundamentally rethink how LLMs can participate in the academic review\nprocess. In this paper, we introduce and explore a novel mechanism that employs\nLLM agents to perform pairwise comparisons among manuscripts instead of\nindividual scoring. By aggregating outcomes from substantial pairwise\nevaluations, this approach enables a more accurate and robust measure of\nrelative manuscript quality. Our experiments demonstrate that this comparative\napproach significantly outperforms traditional rating-based methods in\nidentifying high-impact papers. However, our analysis also reveals emergent\nbiases in the selection process, notably a reduced novelty in research topics\nand an increased institutional imbalance. These findings highlight both the\ntransformative potential of rethinking peer review with LLMs and critical\nchallenges that future systems must address to ensure equity and diversity."}
{"id": "2506.11266", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11266", "abs": "https://arxiv.org/abs/2506.11266", "authors": ["Benjamin Elder", "Anupama Murthi", "Jungkoo Kang", "Ankita Rajaram Naik", "Kiran Kate", "Kinjal Basu", "Danish Contractor"], "title": "Invocable APIs derived from NL2SQL datasets for LLM Tool-Calling Evaluation", "comment": "10+32 pages, 5 figures", "summary": "Large language models (LLMs) are routinely deployed as agentic systems, with\naccess to tools that interact with live environments to accomplish tasks. In\nenterprise deployments these systems need to interact with API collections that\ncan be extremely large and complex, often backed by databases. In order to\ncreate datasets with such characteristics, we explore how existing NL2SQL\n(Natural Language to SQL query) datasets can be used to automatically create\nNL2API datasets. Specifically, this work describes a novel data generation\npipeline that exploits the syntax of SQL queries to construct a functionally\nequivalent sequence of API calls. We apply this pipeline to one of the largest\nNL2SQL datasets, BIRD-SQL to create a collection of over 2500 APIs that can be\nserved as invocable tools or REST-endpoints. We pair natural language queries\nfrom BIRD-SQL to ground-truth API sequences based on this API pool. We use this\ncollection to study the performance of 10 public LLMs and find that all models\nstruggle to determine the right set of tools (consisting of tasks of intent\ndetection, sequencing with nested function calls, and slot-filling). We find\nthat models have extremely low task completion rates (7-47 percent - depending\non the dataset) which marginally improves to 50 percent when models are\nemployed as ReACT agents that interact with the live API environment. The best\ntask completion rates are far below what may be required for effective\ngeneral-use tool-calling agents, suggesting substantial scope for improvement\nin current state-of-the-art tool-calling LLMs. We also conduct detailed\nablation studies, such as assessing the impact of the number of tools available\nas well as the impact of tool and slot-name obfuscation. We compare the\nperformance of models on the original SQL generation tasks and find that\ncurrent models are sometimes able to exploit SQL better than APIs."}
{"id": "2506.11344", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11344", "abs": "https://arxiv.org/abs/2506.11344", "authors": ["Peilin Wu", "Jinho D. Choi"], "title": "Do We Still Need Audio? Rethinking Speaker Diarization with a Text-Based Approach Using Multiple Prediction Models", "comment": null, "summary": "We present a novel approach to Speaker Diarization (SD) by leveraging\ntext-based methods focused on Sentence-level Speaker Change Detection within\ndialogues. Unlike audio-based SD systems, which are often challenged by audio\nquality and speaker similarity, our approach utilizes the dialogue transcript\nalone. Two models are developed: the Single Prediction Model (SPM) and the\nMultiple Prediction Model (MPM), both of which demonstrate significant\nimprovements in identifying speaker changes, particularly in short\nconversations. Our findings, based on a curated dataset encompassing diverse\nconversational scenarios, reveal that the text-based SD approach, especially\nthe MPM, performs competitively against state-of-the-art audio-based SD\nsystems, with superior performance in short conversational contexts. This paper\nnot only showcases the potential of leveraging linguistic features for SD but\nalso highlights the importance of integrating semantic understanding into SD\nsystems, opening avenues for future research in multimodal and semantic\nfeature-based diarization."}
{"id": "2506.11295", "categories": ["cs.SE", "cs.AI", "cs.LG", "D.2.11; D.2.8; I.2.0"], "pdf": "https://arxiv.org/pdf/2506.11295", "abs": "https://arxiv.org/abs/2506.11295", "authors": ["Renato Cordeiro Ferreira"], "title": "A Tale of Two Systems: Characterizing Architectural Complexity on Machine Learning-Enabled Systems", "comment": "8 pages, 3 figures (3 diagrams), submitted to the ECSA2025. arXiv\n  admin note: substantial text overlap with arXiv:2506.08153", "summary": "How can the complexity of ML-enabled systems be managed effectively? The goal\nof this research is to investigate how complexity affects ML-Enabled Systems\n(MLES). To address this question, this research aims to introduce a\nmetrics-based architectural model to characterize the complexity of MLES. The\ngoal is to support architectural decisions, providing a guideline for the\ninception and growth of these systems. This paper brings, side-by-side, the\narchitecture representation of two systems that can be used as case studies for\ncreating the metrics-based architectural model: the SPIRA and the Ocean Guard\nMLES."}
{"id": "2506.11361", "categories": ["cs.CL", "cs.CY"], "pdf": "https://arxiv.org/pdf/2506.11361", "abs": "https://arxiv.org/abs/2506.11361", "authors": ["Jack H Fagan", "Ruhaan Juyaal", "Amy Yue-Ming Yu", "Siya Pun"], "title": "The Biased Samaritan: LLM biases in Perceived Kindness", "comment": null, "summary": "While Large Language Models (LLMs) have become ubiquitous in many fields,\nunderstanding and mitigating LLM biases is an ongoing issue. This paper\nprovides a novel method for evaluating the demographic biases of various\ngenerative AI models. By prompting models to assess a moral patient's\nwillingness to intervene constructively, we aim to quantitatively evaluate\ndifferent LLMs' biases towards various genders, races, and ages. Our work\ndiffers from existing work by aiming to determine the baseline demographic\nidentities for various commercial models and the relationship between the\nbaseline and other demographics. We strive to understand if these biases are\npositive, neutral, or negative, and the strength of these biases. This paper\ncan contribute to the objective assessment of bias in Large Language Models and\ngive the user or developer the power to account for these biases in LLM output\nor in training future LLMs. Our analysis suggested two key findings: that\nmodels view the baseline demographic as a white middle-aged or young adult\nmale; however, a general trend across models suggested that non-baseline\ndemographics are more willing to help than the baseline. These methodologies\nallowed us to distinguish these two biases that are often tangled together."}
{"id": "2506.11400", "categories": ["cs.SE", "cs.RO"], "pdf": "https://arxiv.org/pdf/2506.11400", "abs": "https://arxiv.org/abs/2506.11400", "authors": ["Yupeng Jiang", "Yao Deng", "Sebastian Schroder", "Linfeng Liang", "Suhaas Gambhir", "Alice James", "Avishkar Seth", "James Pirrie", "Yihao Zhang", "Xi Zheng"], "title": "A Step-by-Step Guide to Creating a Robust Autonomous Drone Testing Pipeline", "comment": null, "summary": "Autonomous drones are rapidly reshaping industries ranging from aerial\ndelivery and infrastructure inspection to environmental monitoring and disaster\nresponse. Ensuring the safety, reliability, and efficiency of these systems is\nparamount as they transition from research prototypes to mission-critical\nplatforms. This paper presents a step-by-step guide to establishing a robust\nautonomous drone testing pipeline, covering each critical stage:\nSoftware-in-the-Loop (SIL) Simulation Testing, Hardware-in-the-Loop (HIL)\nTesting, Controlled Real-World Testing, and In-Field Testing. Using practical\nexamples, including the marker-based autonomous landing system, we demonstrate\nhow to systematically verify drone system behaviors, identify integration\nissues, and optimize performance. Furthermore, we highlight emerging trends\nshaping the future of drone testing, including the integration of Neurosymbolic\nand LLMs, creating co-simulation environments, and Digital Twin-enabled\nsimulation-based testing techniques. By following this pipeline, developers and\nresearchers can achieve comprehensive validation, minimize deployment risks,\nand prepare autonomous drones for safe and reliable real-world operations."}
{"id": "2506.11381", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11381", "abs": "https://arxiv.org/abs/2506.11381", "authors": ["Samuel Mensah", "Elena Kochkina", "Jabez Magomere", "Joy Prakash Sain", "Simerjot Kaur", "Charese Smiley"], "title": "A Variational Approach for Mitigating Entity Bias in Relation Extraction", "comment": "Accepted at ACL 2025 Main", "summary": "Mitigating entity bias is a critical challenge in Relation Extraction (RE),\nwhere models often rely excessively on entities, resulting in poor\ngeneralization. This paper presents a novel approach to address this issue by\nadapting a Variational Information Bottleneck (VIB) framework. Our method\ncompresses entity-specific information while preserving task-relevant features.\nIt achieves state-of-the-art performance on relation extraction datasets across\ngeneral, financial, and biomedical domains, in both indomain (original test\nsets) and out-of-domain (modified test sets with type-constrained entity\nreplacements) settings. Our approach offers a robust, interpretable, and\ntheoretically grounded methodology."}
{"id": "2506.11442", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11442", "abs": "https://arxiv.org/abs/2506.11442", "authors": ["Yiyang Jin", "Kunzhao Xu", "Hang Li", "Xueting Han", "Yanmin Zhou", "Cheng Li", "Jing Bai"], "title": "ReVeal: Self-Evolving Code Agents via Iterative Generation-Verification", "comment": null, "summary": "Recent advances in reinforcement learning (RL) with verifiable outcome\nrewards have significantly improved the reasoning capabilities of large\nlanguage models (LLMs), especially when combined with multi-turn tool\ninteractions. However, existing methods lack both meaningful verification\nsignals from realistic environments and explicit optimization for verification,\nleading to unreliable self-verification. To address these limitations, we\npropose ReVeal, a multi-turn reinforcement learning framework that interleaves\ncode generation with explicit self-verification and tool-based evaluation.\nReVeal enables LLMs to autonomously generate test cases, invoke external tools\nfor precise feedback, and improves performance via a customized RL algorithm\nwith dense, per-turn rewards. As a result, ReVeal fosters the co-evolution of a\nmodel's generation and verification capabilities through RL training, expanding\nthe reasoning boundaries of the base model, demonstrated by significant gains\nin Pass@k on LiveCodeBench. It also enables test-time scaling into deeper\ninference regimes, with code consistently evolving as the number of turns\nincreases during inference, ultimately surpassing DeepSeek-R1-Zero-Qwen-32B.\nThese findings highlight the promise of ReVeal as a scalable and effective\nparadigm for building more robust and autonomous AI agents."}
{"id": "2506.11389", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11389", "abs": "https://arxiv.org/abs/2506.11389", "authors": ["Karanpartap Singh", "Neil Band", "Ehsan Adeli"], "title": "Curriculum-Guided Layer Scaling for Language Model Pretraining", "comment": null, "summary": "As the cost of pretraining large language models grows, there is continued\ninterest in strategies to improve learning efficiency during this core training\nstage. Motivated by cognitive development, where humans gradually build\nknowledge as their brains mature, we propose Curriculum-Guided Layer Scaling\n(CGLS), a framework for compute-efficient pretraining that synchronizes\nincreasing data difficulty with model growth through progressive layer stacking\n(i.e. gradually adding layers during training). At the 100M parameter scale,\nusing a curriculum transitioning from synthetic short stories to general web\ndata, CGLS outperforms baseline methods on the question-answering benchmarks\nPIQA and ARC. Pretraining at the 1.2B scale, we stratify the DataComp-LM corpus\nwith a DistilBERT-based classifier and progress from general text to highly\ntechnical or specialized content. Our results show that progressively\nincreasing model depth alongside sample difficulty leads to better\ngeneralization and zero-shot performance on various downstream benchmarks.\nAltogether, our findings demonstrate that CGLS unlocks the potential of\nprogressive stacking, offering a simple yet effective strategy for improving\ngeneralization on knowledge-intensive and reasoning tasks."}
{"id": "2506.11451", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11451", "abs": "https://arxiv.org/abs/2506.11451", "authors": ["Md Nahidul Islam Opu", "Md Shahidul Islam", "Sara Rouhani", "Shaiful Chowdhury"], "title": "Understanding the Issue Types in Open Source Blockchain-based Software Projects with the Transformer-based BERTopic", "comment": null, "summary": "Blockchain-based software systems are increasingly deployed across diverse\ndomains, yet a systematic understanding of their development challenges remains\nlimited. This paper presents a large-scale empirical study of 497,742 issues\nmined from 1,209 open-source blockchain projects hosted on GitHub. Employing\nBERTopic, a transformer-based topic modeling technique, we identify 49 distinct\nissue topics and organize them hierarchically into 11 major subcategories. Our\nanalysis reveals that both general software development issues and\nblockchain-specific concerns are nearly equally represented, with Wallet\nManagement and UI Enhancement emerging as the most prominent topics. We further\nexamine the temporal evolution of issue categories and resolution times,\nfinding that Wallet issues not only dominate in frequency but also exhibit the\nlongest resolution time. Conversely, Mechanisms issues are resolved\nsignificantly faster. Issue frequency surged after 2016 with the rise of\nEthereum and decentralized applications, but declined after 2022. These\nfindings enhance our understanding of blockchain software maintenance,\ninforming the development of specialized tools and practices to improve\nrobustness and maintainability."}
{"id": "2506.11410", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11410", "abs": "https://arxiv.org/abs/2506.11410", "authors": ["Wilson Lau", "Youngwon Kim", "Sravanthi Parasa", "Md Enamul Haque", "Anand Oka", "Jay Nanduri"], "title": "Predicting Early-Onset Colorectal Cancer with Large Language Models", "comment": "Paper accepted for the proceedings of the 2025 American Medical\n  Informatics Association Annual Symposium (AMIA)", "summary": "The incidence rate of early-onset colorectal cancer (EoCRC, age < 45) has\nincreased every year, but this population is younger than the recommended age\nestablished by national guidelines for cancer screening. In this paper, we\napplied 10 different machine learning models to predict EoCRC, and compared\ntheir performance with advanced large language models (LLM), using patient\nconditions, lab results, and observations within 6 months of patient journey\nprior to the CRC diagnoses. We retrospectively identified 1,953 CRC patients\nfrom multiple health systems across the United States. The results demonstrated\nthat the fine-tuned LLM achieved an average of 73% sensitivity and 91%\nspecificity."}
{"id": "2506.11484", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11484", "abs": "https://arxiv.org/abs/2506.11484", "authors": ["Haoshen", "Ming Hu", "Xiaofei Xie", "Jiaye Li", "Mingsong Chen"], "title": "VulStamp: Vulnerability Assessment using Large Language Model", "comment": null, "summary": "Although modern vulnerability detection tools enable developers to\nefficiently identify numerous security flaws, indiscriminate remediation\nefforts often lead to superfluous development expenses. This is particularly\ntrue given that a substantial portion of detected vulnerabilities either\npossess low exploitability or would incur negligible impact in practical\noperational environments. Consequently, vulnerability severity assessment has\nemerged as a critical component in optimizing software development efficiency.\nExisting vulnerability assessment methods typically rely on manually crafted\ndescriptions associated with source code artifacts. However, due to variability\nin description quality and subjectivity in intention interpretation, the\nperformance of these methods is seriously limited. To address this issue, this\npaper introduces VulStamp, a novel intention-guided framework, to facilitate\ndescription-free vulnerability assessment. Specifically, VulStamp adopts static\nanalysis together with Large Language Model (LLM) to extract the intention\ninformation of vulnerable code. Based on the intention information, VulStamp\nuses a prompt-tuned model for vulnerability assessment. Furthermore, to\nmitigate the problem of imbalanced data associated with vulnerability types,\nVulStamp integrates a Reinforcement Learning (RL)-based prompt-tuning method to\ntrain the assessment model."}
{"id": "2506.11418", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11418", "abs": "https://arxiv.org/abs/2506.11418", "authors": ["Jie Hu", "Shengnan Wang", "Yutong He", "Ping Gong", "Jiawei Yi", "Juncheng Zhang", "Youhui Bai", "Renhai Chen", "Gong Zhang", "Cheng Li", "Kun Yuan"], "title": "Efficient Long-Context LLM Inference via KV Cache Clustering", "comment": null, "summary": "Large language models (LLMs) with extended context windows have become\nincreasingly prevalent for tackling complex tasks. However, the substantial\nKey-Value (KV) cache required for long-context LLMs poses significant\ndeployment challenges. Existing approaches either discard potentially critical\ninformation needed for future generations or offer limited efficiency gains due\nto high computational overhead. In this paper, we introduce Chelsea, a simple\nyet effective framework for online KV cache clustering. Our approach is based\non the observation that key states exhibit high similarity along the sequence\ndimension. To enable efficient clustering, we divide the sequence into chunks\nand propose Chunked Soft Matching, which employs an alternating partition\nstrategy within each chunk and identifies clusters based on similarity. Chelsea\nthen merges the KV cache within each cluster into a single centroid.\nAdditionally, we provide a theoretical analysis of the computational complexity\nand the optimality of the intra-chunk partitioning strategy. Extensive\nexperiments across various models and long-context benchmarks demonstrate that\nChelsea achieves up to 80% reduction in KV cache memory usage while maintaining\ncomparable model performance. Moreover, with minimal computational overhead,\nChelsea accelerates the decoding stage of inference by up to 3.19$\\times$ and\nreduces end-to-end latency by up to 2.72$\\times$."}
{"id": "2506.11525", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11525", "abs": "https://arxiv.org/abs/2506.11525", "authors": ["Michael Grohs", "Nadine Cordes", "Jana-Rebecca Rehse"], "title": "A Procedural Framework for Assessing the Desirability of Process Deviations", "comment": null, "summary": "Conformance checking techniques help process analysts to identify where and\nhow process executions deviate from a process model. However, they cannot\ndetermine the desirability of these deviations, i.e., whether they are\nproblematic, acceptable or even beneficial for the process. Such desirability\nassessments are crucial to derive actions, but process analysts typically\nconduct them in a manual, ad-hoc way, which can be time-consuming, subjective,\nand irreplicable. To address this problem, this paper presents a procedural\nframework to guide process analysts in systematically assessing deviation\ndesirability. It provides a step-by-step approach for identifying which input\nfactors to consider in what order to categorize deviations into mutually\nexclusive desirability categories, each linked to action recommendations. The\nframework is based on a review and conceptualization of existing literature on\ndeviation desirability, which is complemented by empirical insights from\ninterviews with process analysis practitioners and researchers. We evaluate the\nframework through a desirability assessment task conducted with practitioners,\nindicating that the framework effectively enables them to streamline the\nassessment for a thorough yet concise evaluation."}
{"id": "2506.11425", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11425", "abs": "https://arxiv.org/abs/2506.11425", "authors": ["Jeff Da", "Clinton Wang", "Xiang Deng", "Yuntao Ma", "Nikhil Barhate", "Sean Hendryx"], "title": "Agent-RLVR: Training Software Engineering Agents via Guidance and Environment Rewards", "comment": null, "summary": "Reinforcement Learning from Verifiable Rewards (RLVR) has been widely adopted\nas the de facto method for enhancing the reasoning capabilities of large\nlanguage models and has demonstrated notable success in verifiable domains like\nmath and competitive programming tasks. However, the efficacy of RLVR\ndiminishes significantly when applied to agentic environments. These settings,\ncharacterized by multi-step, complex problem solving, lead to high failure\nrates even for frontier LLMs, as the reward landscape is too sparse for\neffective model training via conventional RLVR. In this work, we introduce\nAgent-RLVR, a framework that makes RLVR effective in challenging agentic\nsettings, with an initial focus on software engineering tasks. Inspired by\nhuman pedagogy, Agent-RLVR introduces agent guidance, a mechanism that actively\nsteers the agent towards successful trajectories by leveraging diverse\ninformational cues. These cues, ranging from high-level strategic plans to\ndynamic feedback on the agent's errors and environmental interactions, emulate\na teacher's guidance, enabling the agent to navigate difficult solution spaces\nand promotes active self-improvement via additional environment exploration. In\nthe Agent-RLVR training loop, agents first attempt to solve tasks to produce\ninitial trajectories, which are then validated by unit tests and supplemented\nwith agent guidance. Agents then reattempt with guidance, and the agent policy\nis updated with RLVR based on the rewards of these guided trajectories.\nAgent-RLVR elevates the pass@1 performance of Qwen-2.5-72B-Instruct from 9.4%\nto 22.4% on SWE-Bench Verified. We find that our guidance-augmented RLVR data\nis additionally useful for test-time reward model training, shown by further\nboosting pass@1 to 27.8%. Agent-RLVR lays the groundwork for training agents\nwith RLVR in complex, real-world environments where conventional RL methods\nstruggle."}
{"id": "2506.11548", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11548", "abs": "https://arxiv.org/abs/2506.11548", "authors": ["Fabian C. Peña"], "title": "Augmenting the Generality and Performance of Large Language Models for Software Engineering", "comment": null, "summary": "Large Language Models (LLMs) are revolutionizing software engineering (SE),\nwith special emphasis on code generation and analysis. However, their\napplications to broader SE practices including conceptualization, design, and\nother non-code tasks, remain partially underexplored. This research aims to\naugment the generality and performance of LLMs for SE by (1) advancing the\nunderstanding of how LLMs with different characteristics perform on various\nnon-code tasks, (2) evaluating them as sources of foundational knowledge in SE,\nand (3) effectively detecting hallucinations on SE statements. The expected\ncontributions include a variety of LLMs trained and evaluated on\ndomain-specific datasets, new benchmarks on foundational knowledge in SE, and\nmethods for detecting hallucinations. Initial results in terms of performance\nimprovements on various non-code tasks are promising."}
{"id": "2506.11432", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11432", "abs": "https://arxiv.org/abs/2506.11432", "authors": ["Taeeun Kim", "Semin Jeong", "Youngsook Song"], "title": "KoGEC : Korean Grammatical Error Correction with Pre-trained Translation Models", "comment": "11 pages, 2 figures", "summary": "This research introduces KoGEC, a Korean Grammatical Error Correction system\nusing pre\\--trained translation models. We fine-tuned NLLB (No Language Left\nBehind) models for Korean GEC, comparing their performance against large\nlanguage models like GPT-4 and HCX-3. The study used two social media\nconversation datasets for training and testing. The NLLB models were fine-tuned\nusing special language tokens to distinguish between original and corrected\nKorean sentences. Evaluation was done using BLEU scores and an \"LLM as judge\"\nmethod to classify error types. Results showed that the fine-tuned NLLB (KoGEC)\nmodels outperformed GPT-4o and HCX-3 in Korean GEC tasks. KoGEC demonstrated a\nmore balanced error correction profile across various error types, whereas the\nlarger LLMs tended to focus less on punctuation errors. We also developed a\nChrome extension to make the KoGEC system accessible to users. Finally, we\nexplored token vocabulary expansion to further improve the model but found it\nto decrease model performance. This research contributes to the field of NLP by\nproviding an efficient, specialized Korean GEC system and a new evaluation\nmethod. It also highlights the potential of compact, task-specific models to\ncompete with larger, general-purpose language models in specialized NLP tasks."}
{"id": "2506.11559", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11559", "abs": "https://arxiv.org/abs/2506.11559", "authors": ["Gábor Antal", "Dénes Bán", "Martin Isztin", "Rudolf Ferenc", "Péter Hegedűs"], "title": "Leveraging GPT-4 for Vulnerability-Witnessing Unit Test Generation", "comment": null, "summary": "In the life-cycle of software development, testing plays a crucial role in\nquality assurance. Proper testing not only increases code coverage and prevents\nregressions but it can also ensure that any potential vulnerabilities in the\nsoftware are identified and effectively fixed. However, creating such tests is\na complex, resource-consuming manual process. To help developers and security\nexperts, this paper explores the automatic unit test generation capability of\none of the most widely used large language models, GPT-4, from the perspective\nof vulnerabilities. We examine a subset of the VUL4J dataset containing real\nvulnerabilities and their corresponding fixes to determine whether GPT-4 can\ngenerate syntactically and/or semantically correct unit tests based on the code\nbefore and after the fixes as evidence of vulnerability mitigation. We focus on\nthe impact of code contexts, the effectiveness of GPT-4's self-correction\nability, and the subjective usability of the generated test cases. Our results\nindicate that GPT-4 can generate syntactically correct test cases 66.5\\% of the\ntime without domain-specific pre-training. Although the semantic correctness of\nthe fixes could be automatically validated in only 7. 5\\% of the cases, our\nsubjective evaluation shows that GPT-4 generally produces test templates that\ncan be further developed into fully functional vulnerability-witnessing tests\nwith relatively minimal manual effort.\n  Therefore, despite the limited data, our initial findings suggest that GPT-4\ncan be effectively used in the generation of vulnerability-witnessing tests. It\nmay not operate entirely autonomously, but it certainly plays a significant\nrole in a partially automated process."}
{"id": "2506.11440", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11440", "abs": "https://arxiv.org/abs/2506.11440", "authors": ["Harvey Yiyun Fu", "Aryan Shrivastava", "Jared Moore", "Peter West", "Chenhao Tan", "Ari Holtzman"], "title": "AbsenceBench: Language Models Can't Tell What's Missing", "comment": "23 pages, 8 figures. Code and data are publicly available at\n  https://github.com/harvey-fin/absence-bench", "summary": "Large language models (LLMs) are increasingly capable of processing long\ninputs and locating specific information within them, as evidenced by their\nperformance on the Needle in a Haystack (NIAH) test. However, while models\nexcel at recalling surprising information, they still struggle to identify\nclearly omitted information. We introduce AbsenceBench to assesses LLMs'\ncapacity to detect missing information across three domains: numerical\nsequences, poetry, and GitHub pull requests. AbsenceBench asks models to\nidentify which pieces of a document were deliberately removed, given access to\nboth the original and edited contexts. Despite the apparent straightforwardness\nof these tasks, our experiments reveal that even state-of-the-art models like\nClaude-3.7-Sonnet achieve only 69.6% F1-score with a modest average context\nlength of 5K tokens. Our analysis suggests this poor performance stems from a\nfundamental limitation: Transformer attention mechanisms cannot easily attend\nto \"gaps\" in documents since these absences don't correspond to any specific\nkeys that can be attended to. Overall, our results and analysis provide a case\nstudy of the close proximity of tasks where models are already superhuman\n(NIAH) and tasks where models breakdown unexpectedly (AbsenceBench)."}
{"id": "2506.11561", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11561", "abs": "https://arxiv.org/abs/2506.11561", "authors": ["Gábor Antal", "Bence Bogenfürst", "Rudolf Ferenc", "Péter Hegedűs"], "title": "Identifying Helpful Context for LLM-based Vulnerability Repair: A Preliminary Study", "comment": null, "summary": "Recent advancements in large language models (LLMs) have shown promise for\nautomated vulnerability detection and repair in software systems. This paper\ninvestigates the performance of GPT-4o in repairing Java vulnerabilities from a\nwidely used dataset (Vul4J), exploring how different contextual information\naffects automated vulnerability repair (AVR) capabilities. We compare the\nlatest GPT-4o's performance against previous results with GPT-4 using identical\nprompts. We evaluated nine additional prompts crafted by us that contain\nvarious contextual information such as CWE or CVE information, and manually\nextracted code contexts. Each prompt was executed three times on 42\nvulnerabilities, and the resulting fix candidates were validated using Vul4J's\nautomated testing framework.\n  Our results show that GPT-4o performed 11.9\\% worse on average than GPT-4\nwith the same prompt, but was able to fix 10.5\\% more distinct vulnerabilities\nin the three runs together. CVE information significantly improved repair\nrates, while the length of the task description had minimal impact. Combining\nCVE guidance with manually extracted code context resulted in the best\nperformance. Using our \\textsc{Top}-3 prompts together, GPT-4o repaired 26\n(62\\%) vulnerabilities at least once, outperforming both the original baseline\n(40\\%) and its reproduction (45\\%), suggesting that ensemble prompt strategies\ncould improve vulnerability repair in zero-shot settings."}
{"id": "2506.11467", "categories": ["cs.CL", "cs.SI", "F.2.2, I.2.7"], "pdf": "https://arxiv.org/pdf/2506.11467", "abs": "https://arxiv.org/abs/2506.11467", "authors": ["Carlos Rafael Catalan"], "title": "A Gamified Evaluation and Recruitment Platform for Low Resource Language Machine Translation Systems", "comment": "7 pages, 7 figures, presented at the HEAL Workshop at CHI", "summary": "Human evaluators provide necessary contributions in evaluating large language\nmodels. In the context of Machine Translation (MT) systems for low-resource\nlanguages (LRLs), this is made even more apparent since popular automated\nmetrics tend to be string-based, and therefore do not provide a full picture of\nthe nuances of the behavior of the system. Human evaluators, when equipped with\nthe necessary expertise of the language, will be able to test for adequacy,\nfluency, and other important metrics. However, the low resource nature of the\nlanguage means that both datasets and evaluators are in short supply. This\npresents the following conundrum: How can developers of MT systems for these\nLRLs find adequate human evaluators and datasets? This paper first presents a\ncomprehensive review of existing evaluation procedures, with the objective of\nproducing a design proposal for a platform that addresses the resource gap in\nterms of datasets and evaluators in developing MT systems. The result is a\ndesign for a recruitment and gamified evaluation platform for developers of MT\nsystems. Challenges are also discussed in terms of evaluating this platform, as\nwell as its possible applications in the wider scope of Natural Language\nProcessing (NLP) research."}
{"id": "2506.11588", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11588", "abs": "https://arxiv.org/abs/2506.11588", "authors": ["Simone Romano", "Alberto Conforti", "Gloria Guidetti", "Sara Viotti", "Rachele Ceschin", "Giuseppe Scanniello"], "title": "MBSR at Work: Perspectives from an Instructor and Software Developers", "comment": null, "summary": "In this paper, we present the preliminary findings from a qualitative study\n(i.e., semi-structured interviews) on how a Mindfulness-Based Stress Reduction\n(MBSR) program, carried out in the Software Development (SD) working context,\nis perceived by the software developers of a multinational company who\nparticipated in the MBSR program and by the instructor who led it. MBSR is a\ndeeply personal and experiential practice in helping individuals manage stress,\nparticularly in high-pressure environments such as workplaces, healthcare\nsettings, education, and other demanding professional or personal situations.\nAlthough MBSR has been experimented in different working contexts;\nsurprisingly, it has never been studied in the SD working context where there\nare several stress factors that developers experience (e.g., time pressure and\nuncertainty about the content of a particular task and its outcome). In this\nrespect, qualitative research can generate valuable insights into the\napplication of MBSR in the SD working context that cannot be captured by\nstandardized quantitative measures. Being MBSR instructors and software\ndevelopers the key stakeholders in delivering an MBSR program in the SD working\ncontext, understanding their first-hand experiences can provide a more detailed\npicture of the investigated phenomenon. The most important takeaway result of\nour research can be summarized as follows: despite initial skepticism, the\ndevelopers recognized personal improvements due to the MBSR practice, though\nthe integration of MBSR techniques in the working context remained challenging."}
{"id": "2506.11474", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11474", "abs": "https://arxiv.org/abs/2506.11474", "authors": ["Jaehoon Yun", "Jiwoong Sohn", "Jungwoo Park", "Hyunjae Kim", "Xiangru Tang", "Yanjun Shao", "Yonghoe Koo", "Minhyeok Ko", "Qingyu Chen", "Mark Gerstein", "Michael Moor", "Jaewoo Kang"], "title": "Med-PRM: Medical Reasoning Models with Stepwise, Guideline-verified Process Rewards", "comment": null, "summary": "Large language models have shown promise in clinical decision making, but\ncurrent approaches struggle to localize and correct errors at specific steps of\nthe reasoning process. This limitation is critical in medicine, where\nidentifying and addressing reasoning errors is essential for accurate diagnosis\nand effective patient care. We introduce Med-PRM, a process reward modeling\nframework that leverages retrieval-augmented generation to verify each\nreasoning step against established medical knowledge bases. By verifying\nintermediate reasoning steps with evidence retrieved from clinical guidelines\nand literature, our model can precisely assess the reasoning quality in a\nfine-grained manner. Evaluations on five medical QA benchmarks and two\nopen-ended diagnostic tasks demonstrate that Med-PRM achieves state-of-the-art\nperformance, with improving the performance of base models by up to 13.50%\nusing Med-PRM. Moreover, we demonstrate the generality of Med-PRM by\nintegrating it in a plug-and-play fashion with strong policy models such as\nMeerkat, achieving over 80\\% accuracy on MedQA for the first time using\nsmall-scale models of 8 billion parameters. Our code and data are available at:\nhttps://med-prm.github.io/"}
{"id": "2506.11591", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11591", "abs": "https://arxiv.org/abs/2506.11591", "authors": ["Hyunsun Hong", "Jongmoon Baik"], "title": "Retrieval-Augmented Code Review Comment Generation", "comment": null, "summary": "Automated code review comment generation (RCG) aims to assist developers by\nautomatically producing natural language feedback for code changes. Existing\napproaches are primarily either generation-based, using pretrained language\nmodels, or information retrieval-based (IR), reusing comments from similar past\nexamples. While generation-based methods leverage code-specific pretraining on\nlarge code-natural language corpora to learn semantic relationships between\ncode and natural language, they often struggle to generate low-frequency but\nsemantically important tokens due to their probabilistic nature. In contrast,\nIR-based methods excel at recovering such rare tokens by copying from existing\nexamples but lack flexibility in adapting to new code contexts-for example,\nwhen input code contains identifiers or structures not found in the retrieval\ndatabase. To bridge the gap between generation-based and IR-based methods, this\nwork proposes to leverage retrieval-augmented generation (RAG) for RCG by\nconditioning pretrained language models on retrieved code-review exemplars. By\nproviding relevant examples that illustrate how similar code has been\npreviously reviewed, the model is better guided to generate accurate review\ncomments. Our evaluation on the Tufano et al. benchmark shows that RAG-based\nRCG outperforms both generation-based and IR-based RCG. It achieves up to\n+1.67% higher exact match and +4.25% higher BLEU scores compared to\ngeneration-based RCG. It also improves the generation of low-frequency\nground-truth tokens by up to 24.01%. We additionally find that performance\nimproves as the number of retrieved exemplars increases."}
{"id": "2506.11478", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11478", "abs": "https://arxiv.org/abs/2506.11478", "authors": ["Aman Sinha", "Bogdan-Valentin Popescu", "Xavier Coubez", "Marianne Clausel", "Mathieu Constant"], "title": "ImmunoFOMO: Are Language Models missing what oncologists see?", "comment": null, "summary": "Language models (LMs) capabilities have grown with a fast pace over the past\ndecade leading researchers in various disciplines, such as biomedical research,\nto increasingly explore the utility of LMs in their day-to-day applications.\nDomain specific language models have already been in use for biomedical natural\nlanguage processing (NLP) applications. Recently however, the interest has\ngrown towards medical language models and their understanding capabilities. In\nthis paper, we investigate the medical conceptual grounding of various language\nmodels against expert clinicians for identification of hallmarks of\nimmunotherapy in breast cancer abstracts. Our results show that pre-trained\nlanguage models have potential to outperform large language models in\nidentifying very specific (low-level) concepts."}
{"id": "2506.11597", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11597", "abs": "https://arxiv.org/abs/2506.11597", "authors": ["Simone Romano", "Francesco Paolo Sferratore", "Giuseppe Scanniello"], "title": "Further Evidence on a Controversial Topic about Human-Based Experiments: Professionals vs. Students", "comment": null, "summary": "Most Software Engineering (SE) human-based controlled experiments rely on\nstudents as participants, raising concerns about their external validity.\nSpecifically, the realism of results obtained from students and their\napplicability to the software industry remains in question. In this short\npaper, we bring further evidence on this controversial point. To do so, we\ncompare 62 students and 42 software professionals on a bug-fixing task on the\nsame Java program. The students were enrolled in a Bachelor's program in\nComputer Science, while the professionals were employed by two multinational\ncompanies (for one of them, the professionals were from two offices). Some\nvariations in the experimental settings of the two groups (students and\nprofessionals) were present. For instance, the experimental environment of the\nexperiment with professionals was more realistic; i.e., they faced some stress\nfactors such as interruptions during the bug-fixing task. Considering the\ndifferences between the two groups of participants, the gathered data show that\nthe students outperformed the professionals in fixing bugs. This diverges to\nsome extent from past empirical evidence. Rather than presenting definitive\nconclusions, our results aim to catalyze the discussion on the use of students\nin experiments and pave the way for future investigations. Specifically, our\nresults encourage us to examine the complex factors influencing SE tasks,\nmaking experiments as more realistic as possible."}
{"id": "2506.11485", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11485", "abs": "https://arxiv.org/abs/2506.11485", "authors": ["Cole Gawin"], "title": "Relational Schemata in BERT Are Inducible, Not Emergent: A Study of Performance vs. Competence in Language Models", "comment": "15 pages, 4 figures, 3 tables", "summary": "While large language models like BERT demonstrate strong empirical\nperformance on semantic tasks, whether this reflects true conceptual competence\nor surface-level statistical association remains unclear. I investigate whether\nBERT encodes abstract relational schemata by examining internal representations\nof concept pairs across taxonomic, mereological, and functional relations. I\ncompare BERT's relational classification performance with representational\nstructure in [CLS] token embeddings. Results reveal that pretrained BERT\nenables high classification accuracy, indicating latent relational signals.\nHowever, concept pairs organize by relation type in high-dimensional embedding\nspace only after fine-tuning on supervised relation classification tasks. This\nindicates relational schemata are not emergent from pretraining alone but can\nbe induced via task scaffolding. These findings demonstrate that behavioral\nperformance does not necessarily imply structured conceptual understanding,\nthough models can acquire inductive biases for grounded relational abstraction\nthrough appropriate training."}
{"id": "2506.11598", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11598", "abs": "https://arxiv.org/abs/2506.11598", "authors": ["Ahmed Zaki", "Cristian Cadar"], "title": "Understanding API Usage and Testing: An Empirical Study of C Libraries", "comment": "The 29th International Conference on Evaluation and Assessment in\n  Software Engineering, 17 to 20 June, 2025, Istanbul, Turkey", "summary": "For library developers, understanding how their Application Programming\nInterfaces (APIs) are used in the field can be invaluable. Knowing how clients\nare using their APIs allows for data-driven decisions on prioritising bug\nreports, feature requests, and testing activities. For example, the priority of\na bug report concerning an API can be partly determined by how widely that API\nis used.\n  In this paper, we present an empirical study in which we analyse API usage\nacross 21 popular open-source C libraries, such as OpenSSL and SQLite, with a\ncombined total of 3,061 C/C++ clients. We compare API usage by clients with how\nwell library test suites exercise the APIs to offer actionable insights for\nlibrary developers. To our knowledge, this is the first study that compares API\nusage and API testing at scale for the C/C++ ecosystem. Our study shows that\nlibrary developers do not prioritise their effort based on how clients use\ntheir API, with popular APIs often poorly tested. For example, in LMDB, a\npopular key-value store, 45% of the APIs are used by clients but not tested by\nthe library test suite. We further show that client test suites can be\nleveraged to improve library testing e.g., improving coverage in LMDB by 14.7%\nwith the important advantage that those tests are representative of how the\nAPIs are used in the field.\n  For our empirical study, we have developed LibProbe, a framework that can be\nused to analyse a large corpus of clients for a given library and produce\nvarious metrics useful to library developers."}
{"id": "2506.11498", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11498", "abs": "https://arxiv.org/abs/2506.11498", "authors": ["Manlai Liang", "Wanyi Huang", "Mandi Liu", "Huaijun Li", "Jinlong Li"], "title": "Lag-Relative Sparse Attention In Long Context Training", "comment": null, "summary": "Large Language Models (LLMs) have made significant strides in natural\nlanguage processing and generation, yet their ability to handle long-context\ninput remains constrained by the quadratic complexity of attention computation\nand linear-increasing key-value memory footprint. To reduce computational costs\nand memory, key-value cache compression techniques are commonly applied at\ninference time, but this often leads to severe performance degradation, as\nmodels are not trained to handle compressed context. Although there are more\nsophisticated compression methods, they are typically unsuitable for\npost-training because of their incompatibility with gradient-based optimization\nor high computation overhead. To fill this gap with no additional parameter and\nlittle computation overhead, we propose Lag-Relative Sparse Attention(LRSA)\nanchored by the LagKV compression method for long context post-training. Our\nmethod performs chunk-by-chunk prefilling, which selects the top K most\nrelevant key-value pairs in a fixed-size lagging window, allowing the model to\nfocus on salient historical context while maintaining efficiency. Experimental\nresults show that our approach significantly enhances the robustness of the LLM\nwith key-value compression and achieves better fine-tuned results in the\nquestion-answer tuning task."}
{"id": "2506.11614", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11614", "abs": "https://arxiv.org/abs/2506.11614", "authors": ["Yonggang Tao", "Jingling Xue"], "title": "Accelerating Delta Debugging through Probabilistic Monotonicity Assessment", "comment": "Accepted by EASE 2025 (The 29th International Conference on\n  Evaluation and Assessment in Software Engineering), 17-20 June 2025,\n  Istanbul, Turkey. 11 pages", "summary": "Delta debugging assumes search space monotonicity: if a program causes a\nfailure, any supersets of that program will also induce the same failure,\npermitting the exclusion of subsets of non-failure-inducing programs. However,\nthis assumption does not always hold in practice. This paper introduces\nProbabilistic Monotonicity Assessment (PMA), enhancing the efficiency of\nDDMIN-style algorithms without sacrificing effectiveness. PMA dynamically\nmodels and assesses the search space's monotonicity based on prior tests tried\nduring the debugging process and uses a confidence function to quantify\nmonotonicity, thereby enabling the probabilistic exclusion of subsets of\nnon-failure-inducing programs. Our approach significantly reduces redundant\ntests that would otherwise be performed, without compromising the quality of\nthe reduction.\n  We evaluated PMA against two leading DDMIN-style tools, CHISEL and ProbDD.\nOur findings indicate that PMA cuts processing time by 59.2% compared to\nCHISEL, accelerates the reduction process (i.e., the number of tokens deleted\nper second) by 3.32x, and decreases the sizes of the final reduced programs by\n6.7%. Against ProbDD, PMA reduces processing time by 22.0%, achieves a 1.34x\nspeedup in the reduction process, and further decreases the sizes of the final\nreduced programs by 3.0%. These findings affirm PMA's role in significantly\nimproving delta debugging's efficiency while maintaining or enhancing its\neffectiveness."}
{"id": "2506.11499", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11499", "abs": "https://arxiv.org/abs/2506.11499", "authors": ["Seongbo Jang", "Seonghyeon Lee", "Dongha Lee", "Hwanjo Yu"], "title": "On the Effectiveness of Integration Methods for Multimodal Dialogue Response Retrieval", "comment": "9 pages, 1 figure", "summary": "Multimodal chatbots have become one of the major topics for dialogue systems\nin both research community and industry. Recently, researchers have shed light\non the multimodality of responses as well as dialogue contexts. This work\nexplores how a dialogue system can output responses in various modalities such\nas text and image. To this end, we first formulate a multimodal dialogue\nresponse retrieval task for retrieval-based systems as the combination of three\nsubtasks. We then propose three integration methods based on a two-step\napproach and an end-to-end approach, and compare the merits and demerits of\neach method. Experimental results on two datasets demonstrate that the\nend-to-end approach achieves comparable performance without an intermediate\nstep in the two-step approach. In addition, a parameter sharing strategy not\nonly reduces the number of parameters but also boosts performance by\ntransferring knowledge across the subtasks and the modalities."}
{"id": "2506.11659", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11659", "abs": "https://arxiv.org/abs/2506.11659", "authors": ["Simin Sun", "Yuchuan Jin", "Miroslaw Staron"], "title": "An Empirical study on LLM-based Log Retrieval for Software Engineering Metadata Management", "comment": null, "summary": "Developing autonomous driving systems (ADSs) involves generating and storing\nextensive log data from test drives, which is essential for verification,\nresearch, and simulation. However, these high-frequency logs, recorded over\nvarying durations, pose challenges for developers attempting to locate specific\ndriving scenarios. This difficulty arises due to the wide range of signals\nrepresenting various vehicle components and driving conditions, as well as\nunfamiliarity of some developers' with the detailed meaning of these signals.\nTraditional SQL-based querying exacerbates this challenge by demanding both\ndomain expertise and database knowledge, often yielding results that are\ndifficult to verify for accuracy.\n  This paper introduces a Large Language Model (LLM)-supported approach that\ncombines signal log data with video recordings from test drives, enabling\nnatural language based scenario searches while reducing the need for\nspecialized knowledge. By leveraging scenario distance graphs and relative gap\nindicators, it provides quantifiable metrics to evaluate the reliability of\nquery results. The method is implemented as an API for efficient database\nquerying and retrieval of relevant records, paired with video frames for\nintuitive visualization. Evaluation on an open industrial dataset demonstrates\nimproved efficiency and reliability in scenario retrieval, eliminating\ndependency on a single data source and conventional SQL."}
{"id": "2506.11557", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11557", "abs": "https://arxiv.org/abs/2506.11557", "authors": ["Chih-Hao Hsu", "Ying-Jia Lin", "Hung-Yu Kao"], "title": "From Persona to Person: Enhancing the Naturalness with Multiple Discourse Relations Graph Learning in Personalized Dialogue Generation", "comment": "Accepted by PAKDD 2025", "summary": "In dialogue generation, the naturalness of responses is crucial for effective\nhuman-machine interaction. Personalized response generation poses even greater\nchallenges, as the responses must remain coherent and consistent with the\nuser's personal traits or persona descriptions. We propose MUDI\n($\\textbf{Mu}$ltiple $\\textbf{Di}$scourse Relations Graph Learning) for\npersonalized dialogue generation. We utilize a Large Language Model to assist\nin annotating discourse relations and to transform dialogue data into\nstructured dialogue graphs. Our graph encoder, the proposed DialogueGAT model,\nthen captures implicit discourse relations within this structure, along with\npersona descriptions. During the personalized response generation phase, novel\ncoherence-aware attention strategies are implemented to enhance the decoder's\nconsideration of discourse relations. Our experiments demonstrate significant\nimprovements in the quality of personalized responses, thus resembling\nhuman-like dialogue exchanges."}
{"id": "2506.11697", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11697", "abs": "https://arxiv.org/abs/2506.11697", "authors": ["Yiwei Hu", "Zhen Li", "Kedie Shu", "Shenghua Guan", "Deqing Zou", "Shouhuai Xu", "Bin Yuan", "Hai Jin"], "title": "SoK: Automated Vulnerability Repair: Methods, Tools, and Assessments", "comment": "The full version of \"SoK: Automated Vulnerability Repair: Methods,\n  Tools, and Assessments\" accepted by the 34th USENIX Security Symposium\n  (USENIX Security 2025)", "summary": "The increasing complexity of software has led to the steady growth of\nvulnerabilities. Vulnerability repair investigates how to fix software\nvulnerabilities. Manual vulnerability repair is labor-intensive and\ntime-consuming because it relies on human experts, highlighting the importance\nof Automated Vulnerability Repair (AVR). In this SoK, we present the\nsystematization of AVR methods through the three steps of AVR workflow:\nvulnerability analysis, patch generation, and patch validation. We assess AVR\ntools for C/C++ and Java programs as they have been widely studied by the\ncommunity. Since existing AVR tools for C/C++ programs are evaluated with\ndifferent datasets, which often consist of a few vulnerabilities, we construct\nthe first C/C++ vulnerability repair benchmark dataset, dubbed Vul4C, which\ncontains 144 vulnerabilities as well as their exploits and patches. We use\nVul4C to evaluate seven AVR tools for C/C++ programs and use the third-party\nVul4J dataset to evaluate two AVR tools for Java programs. We also discuss\nfuture research directions."}
{"id": "2506.11602", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11602", "abs": "https://arxiv.org/abs/2506.11602", "authors": ["Hawau Olamide Toyin", "Samar M. Magdy", "Hanan Aldarmaki"], "title": "Are LLMs Good Text Diacritizers? An Arabic and Yorùbá Case Study", "comment": null, "summary": "We investigate the effectiveness of large language models (LLMs) for text\ndiacritization in two typologically distinct languages: Arabic and Yoruba. To\nenable a rigorous evaluation, we introduce a novel multilingual dataset\nMultiDiac, with diverse samples that capture a range of diacritic ambiguities.\nWe evaluate 14 LLMs varying in size, accessibility, and language coverage, and\nbenchmark them against 6 specialized diacritization models. Additionally, we\nfine-tune four small open-source models using LoRA for Yoruba. Our results show\nthat many off-the-shelf LLMs outperform specialized diacritization models for\nboth Arabic and Yoruba, but smaller models suffer from hallucinations.\nFine-tuning on a small dataset can help improve diacritization performance and\nreduce hallucination rates."}
{"id": "2506.11722", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.11722", "abs": "https://arxiv.org/abs/2506.11722", "authors": ["Eduard C. Groen", "Fabiano Dalpiaz", "Martijn van Vliet", "Boris Winter", "Joerg Doerr", "Sjaak Brinkkemper"], "title": "Classification of Quality Characteristics in Online User Feedback using Linguistic Analysis, Crowdsourcing and LLMs", "comment": "Accepted at the Journal of Systems and Software (JSS); online\n  appendix and supplementary material available at\n  https://doi.org/10.5281/zenodo.15604749", "summary": "Software qualities such as usability or reliability are among the strongest\ndeterminants of mobile app user satisfaction and constitute a significant\nportion of online user feedback on software products, making it a valuable\nsource of quality-related feedback to guide the development process. The\nabundance of online user feedback warrants the automated identification of\nquality characteristics, but the online user feedback's heterogeneity and the\nlack of appropriate training corpora limit the applicability of supervised\nmachine learning. We therefore investigate the viability of three approaches\nthat could be effective in low-data settings: language patterns (LPs) based on\nquality-related keywords, instructions for crowdsourced micro-tasks, and large\nlanguage model (LLM) prompts. We determined the feasibility of each approach\nand then compared their accuracy. For the complex multiclass classification of\nquality characteristics, the LP-based approach achieved a varied precision\n(0.38-0.92) depending on the quality characteristic, and low recall;\ncrowdsourcing achieved the best average accuracy in two consecutive phases\n(0.63, 0.72), which could be matched by the best-performing LLM condition\n(0.66) and a prediction based on the LLMs' majority vote (0.68). Our findings\nshow that in this low-data setting, the two approaches that use crowdsourcing\nor LLMs instead of involving experts achieve accurate classifications, while\nthe LP-based approach has only limited potential. The promise of crowdsourcing\nand LLMs in this context might even extend to building training corpora."}
{"id": "2506.11631", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11631", "abs": "https://arxiv.org/abs/2506.11631", "authors": ["Simeon Junker", "Sina Zarrieß"], "title": "SceneGram: Conceptualizing and Describing Tangrams in Scene Context", "comment": "To appear in ACL Findings 2025", "summary": "Research on reference and naming suggests that humans can come up with very\ndifferent ways of conceptualizing and referring to the same object, e.g. the\nsame abstract tangram shape can be a \"crab\", \"sink\" or \"space ship\". Another\ncommon assumption in cognitive science is that scene context fundamentally\nshapes our visual perception of objects and conceptual expectations. This paper\ncontributes SceneGram, a dataset of human references to tangram shapes placed\nin different scene contexts, allowing for systematic analyses of the effect of\nscene context on conceptualization. Based on this data, we analyze references\nto tangram shapes generated by multimodal LLMs, showing that these models do\nnot account for the richness and variability of conceptualizations found in\nhuman references."}
{"id": "2506.11874", "categories": ["cs.SE", "D.2.1; D.2.4; D.2.10; F.4.1; F.4.3"], "pdf": "https://arxiv.org/pdf/2506.11874", "abs": "https://arxiv.org/abs/2506.11874", "authors": ["Arshad Beg", "Diarmuid O'Donoghue", "Rosemary Monahan"], "title": "A Short Survey on Formalising Software Requirements using Large Language Models", "comment": "Submitted to SAIV 2025 as extended abstract and received valuable\n  comments improving our draft. This version is the improved one after\n  addressing suggestions from reviewers for improving the draft", "summary": "This paper presents a focused literature survey on the use of large language\nmodels (LLM) to assist in writing formal specifications for software. A summary\nof thirty-five key papers is presented, including examples for specifying\nprograms written in Dafny, C and Java. This paper arose from the project\nVERIFAI - Traceability and verification of natural language requirements that\naddresses the challenges in writing formal specifications from requirements\nthat are expressed in natural language. Our methodology employed multiple\nacademic databases to identify relevant research. The AI-assisted tool Elicit\nfacilitated the initial paper selection, which were manually screened for final\nselection. The survey provides valuable insights and future directions for\nutilising LLMs while formalising software requirements."}
{"id": "2506.11638", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11638", "abs": "https://arxiv.org/abs/2506.11638", "authors": ["Yicheng Xiao", "Lin Song", "Rui Yang", "Cheng Cheng", "Yixiao Ge", "Xiu Li", "Ying Shan"], "title": "LoRA-Gen: Specializing Large Language Model via Online LoRA Generation", "comment": null, "summary": "Recent advances have highlighted the benefits of scaling language models to\nenhance performance across a wide range of NLP tasks. However, these approaches\nstill face limitations in effectiveness and efficiency when applied to\ndomain-specific tasks, particularly for small edge-side models. We propose the\nLoRA-Gen framework, which utilizes a large cloud-side model to generate LoRA\nparameters for edge-side models based on task descriptions. By employing the\nreparameterization technique, we merge the LoRA parameters into the edge-side\nmodel to achieve flexible specialization. Our method facilitates knowledge\ntransfer between models while significantly improving the inference efficiency\nof the specialized model by reducing the input context length. Without\nspecialized training, LoRA-Gen outperforms conventional LoRA fine-tuning, which\nachieves competitive accuracy and a 2.1x speedup with TinyLLaMA-1.1B in\nreasoning tasks. Besides, our method delivers a compression ratio of 10.1x with\nGemma-2B on intelligent agent tasks."}
{"id": "2506.11928", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11928", "abs": "https://arxiv.org/abs/2506.11928", "authors": ["Zihan Zheng", "Zerui Cheng", "Zeyu Shen", "Shang Zhou", "Kaiyuan Liu", "Hansen He", "Dongruixuan Li", "Stanley Wei", "Hangyi Hao", "Jianzhu Yao", "Peiyao Sheng", "Zixuan Wang", "Wenhao Chai", "Aleksandra Korolova", "Peter Henderson", "Sanjeev Arora", "Pramod Viswanath", "Jingbo Shang", "Saining Xie"], "title": "LiveCodeBench Pro: How Do Olympiad Medalists Judge LLMs in Competitive Programming?", "comment": "Project Page at https://livecodebenchpro.com/", "summary": "Recent reports claim that large language models (LLMs) now outperform elite\nhumans in competitive programming. Drawing on knowledge from a group of\nmedalists in international algorithmic contests, we revisit this claim,\nexamining how LLMs differ from human experts and where limitations still\nremain. We introduce LiveCodeBench Pro, a benchmark composed of problems from\nCodeforces, ICPC, and IOI that are continuously updated to reduce the\nlikelihood of data contamination. A team of Olympiad medalists annotates every\nproblem for algorithmic categories and conducts a line-by-line analysis of\nfailed model-generated submissions. Using this new data and benchmark, we find\nthat frontier models still have significant limitations: without external\ntools, the best model achieves only 53% pass@1 on medium-difficulty problems\nand 0% on hard problems, domains where expert humans still excel. We also find\nthat LLMs succeed at implementation-heavy problems but struggle with nuanced\nalgorithmic reasoning and complex case analysis, often generating confidently\nincorrect justifications. High performance appears largely driven by\nimplementation precision and tool augmentation, not superior reasoning.\nLiveCodeBench Pro thus highlights the significant gap to human grandmaster\nlevels, while offering fine-grained diagnostics to steer future improvements in\ncode-centric LLM reasoning."}
{"id": "2506.11666", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11666", "abs": "https://arxiv.org/abs/2506.11666", "authors": ["Pietro Ferrazzi", "Alberto Lavelli", "Bernardo Magnini"], "title": "Converting Annotated Clinical Cases into Structured Case Report Forms", "comment": "to be published in BioNLP 2025", "summary": "Case Report Forms (CRFs) are largely used in medical research as they ensure\naccuracy, reliability, and validity of results in clinical studies. However,\npublicly available, wellannotated CRF datasets are scarce, limiting the\ndevelopment of CRF slot filling systems able to fill in a CRF from clinical\nnotes. To mitigate the scarcity of CRF datasets, we propose to take advantage\nof available datasets annotated for information extraction tasks and to convert\nthem into structured CRFs. We present a semi-automatic conversion methodology,\nwhich has been applied to the E3C dataset in two languages (English and\nItalian), resulting in a new, high-quality dataset for CRF slot filling.\nThrough several experiments on the created dataset, we report that slot filling\nachieves 59.7% for Italian and 67.3% for English on a closed Large Language\nModels (zero-shot) and worse performances on three families of open-source\nmodels, showing that filling CRFs is challenging even for recent\nstate-of-the-art LLMs. We release the datest at\nhttps://huggingface.co/collections/NLP-FBK/e3c-to-crf-67b9844065460cbe42f80166"}
{"id": "2506.12014", "categories": ["cs.CL", "cs.AI", "cs.LG", "cs.SE"], "pdf": "https://arxiv.org/pdf/2506.12014", "abs": "https://arxiv.org/abs/2506.12014", "authors": ["Yuliang Xu", "Siming Huang", "Mingmeng Geng", "Yao Wan", "Xuanhua Shi", "Dongping Chen"], "title": "code_transformed: The Influence of Large Language Models on Code", "comment": "We release all the experimental dataset and source code at:\n  https://github.com/ignorancex/LLM_code", "summary": "Coding remains one of the most fundamental modes of interaction between\nhumans and machines. With the rapid advancement of Large Language Models\n(LLMs), code generation capabilities have begun to significantly reshape\nprogramming practices. This development prompts a central question: Have LLMs\ntransformed code style, and how can such transformation be characterized? In\nthis paper, we present a pioneering study that investigates the impact of LLMs\non code style, with a focus on naming conventions, complexity, maintainability,\nand similarity. By analyzing code from over 19,000 GitHub repositories linked\nto arXiv papers published between 2020 and 2025, we identify measurable trends\nin the evolution of coding style that align with characteristics of\nLLM-generated code. For instance, the proportion of snake\\_case variable names\nin Python code increased from 47% in Q1 2023 to 51% in Q1 2025. Furthermore, we\ninvestigate how LLMs approach algorithmic problems by examining their reasoning\nprocesses. Given the diversity of LLMs and usage scenarios, among other\nfactors, it is difficult or even impossible to precisely estimate the\nproportion of code generated or assisted by LLMs. Our experimental results\nprovide the first large-scale empirical evidence that LLMs affect real-world\nprogramming style."}
{"id": "2506.11673", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11673", "abs": "https://arxiv.org/abs/2506.11673", "authors": ["Alicja Dobrzeniecka", "Antske Fokkens", "Pia Sommerauer"], "title": "Improving Causal Interventions in Amnesic Probing with Mean Projection or LEACE", "comment": null, "summary": "Amnesic probing is a technique used to examine the influence of specific\nlinguistic information on the behaviour of a model. This involves identifying\nand removing the relevant information and then assessing whether the model's\nperformance on the main task changes. If the removed information is relevant,\nthe model's performance should decline. The difficulty with this approach lies\nin removing only the target information while leaving other information\nunchanged. It has been shown that Iterative Nullspace Projection (INLP), a\nwidely used removal technique, introduces random modifications to\nrepresentations when eliminating target information. We demonstrate that Mean\nProjection (MP) and LEACE, two proposed alternatives, remove information in a\nmore targeted manner, thereby enhancing the potential for obtaining behavioural\nexplanations through Amnesic Probing."}
{"id": "2506.11681", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11681", "abs": "https://arxiv.org/abs/2506.11681", "authors": ["Pratibha Zunjare", "Michael Hsiao"], "title": "LLMs for Sentence Simplification: A Hybrid Multi-Agent prompting Approach", "comment": null, "summary": "This paper addresses the challenge of transforming complex sentences into\nsequences of logical, simplified sentences while preserving semantic and\nlogical integrity with the help of Large Language Models. We propose a hybrid\napproach that combines advanced prompting with multi-agent architectures to\nenhance the sentence simplification process. Experimental results show that our\napproach was able to successfully simplify 70% of the complex sentences written\nfor video game design application. In comparison, a single-agent approach\nattained a 48% success rate on the same task."}
{"id": "2506.11702", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.11702", "abs": "https://arxiv.org/abs/2506.11702", "authors": ["Víctor Gallego"], "title": "Configurable Preference Tuning with Rubric-Guided Synthetic Data", "comment": "Accepted to ICML 2025 Workshop on Models of Human Feedback for AI\n  Alignment", "summary": "Models of human feedback for AI alignment, such as those underpinning Direct\nPreference Optimization (DPO), often bake in a singular, static set of\npreferences, limiting adaptability. This paper challenges the assumption of\nmonolithic preferences by introducing Configurable Preference Tuning (CPT), a\nnovel framework for endowing language models with the ability to dynamically\nadjust their behavior based on explicit, human-interpretable directives. CPT\nleverages synthetically generated preference data, conditioned on system\nprompts derived from structured, fine-grained rubrics that define desired\nattributes like writing style. By fine-tuning with these rubric-guided\npreferences, the LLM learns to modulate its outputs at inference time in\nresponse to the system prompt, without retraining. This approach not only\noffers fine-grained control but also provides a mechanism for modeling more\nnuanced and context-dependent human feedback. Several experimental artifacts,\nsuch as training code, generated datasets and fine-tuned models are released at\nhttps://github.com/vicgalle/configurable-preference-tuning"}
{"id": "2506.11728", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11728", "abs": "https://arxiv.org/abs/2506.11728", "authors": ["Héctor Martínez", "Adrián Castelló", "Francisco D. Igual", "Enrique S. Quintana-Ortí"], "title": "The Cambrian Explosion of Mixed-Precision Matrix Multiplication for Quantized Deep Learning Inference", "comment": "16 pages, 7 tables, 7 figures", "summary": "Recent advances in deep learning (DL) have led to a shift from traditional\n64-bit floating point (FP64) computations toward reduced-precision formats,\nsuch as FP16, BF16, and 8- or 16-bit integers, combined with mixed-precision\narithmetic. This transition enhances computational throughput, reduces memory\nand bandwidth usage, and improves energy efficiency, offering significant\nadvantages for resource-constrained edge devices. To support this shift,\nhardware architectures have evolved accordingly, now including adapted ISAs\n(Instruction Set Architectures) that expose mixed-precision vector units and\nmatrix engines tailored for DL workloads. At the heart of many DL and\nscientific computing tasks is the general matrix-matrix multiplication gemm, a\nfundamental kernel historically optimized using axpy vector instructions on\nSIMD (single instruction, multiple data) units. However, as hardware moves\ntoward mixed-precision dot-product-centric operations optimized for quantized\ninference, these legacy approaches are being phased out. In response to this,\nour paper revisits traditional high-performance gemm and describes strategies\nfor adapting it to mixed-precision integer (MIP) arithmetic across modern ISAs,\nincluding x86_64, ARM, and RISC-V. Concretely, we illustrate novel micro-kernel\ndesigns and data layouts that better exploit today's specialized hardware and\ndemonstrate significant performance gains from MIP arithmetic over\nfloating-point implementations across three representative CPU architectures.\nThese contributions highlight a new era of gemm optimization-driven by the\ndemands of DL inference on heterogeneous architectures, marking what we term as\nthe \"Cambrian period\" for matrix multiplication."}
{"id": "2506.11752", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11752", "abs": "https://arxiv.org/abs/2506.11752", "authors": ["Nan Jiang", "Ziming Wu", "De-Chuan Zhan", "Fuming Lai", "Shaobing Lian"], "title": "DART: Distilling Autoregressive Reasoning to Silent Thought", "comment": null, "summary": "Chain-of-Thought (CoT) reasoning has significantly advanced Large Language\nModels (LLMs) in solving complex tasks. However, its autoregressive paradigm\nleads to significant computational overhead, hindering its deployment in\nlatency-sensitive applications. To address this, we propose \\textbf{DART}\n(\\textbf{D}istilling \\textbf{A}utoregressive \\textbf{R}easoning to Silent\n\\textbf{T}hought), a self-distillation framework that enables LLMs to replace\nautoregressive CoT with non-autoregressive Silent Thought (ST). Specifically,\nDART introduces two training pathways: the CoT pathway for traditional\nreasoning and the ST pathway for generating answers directly from a few ST\ntokens. The ST pathway utilizes a lightweight Reasoning Evolvement Module (REM)\nto align its hidden states with the CoT pathway, enabling the ST tokens to\nevolve into informative embeddings. During inference, only the ST pathway is\nactivated, leveraging evolving ST tokens to deliver the answer directly.\nExtensive experimental results demonstrate that DART achieves comparable\nreasoning performance to existing baselines while offering significant\nefficiency gains, serving as a feasible alternative for efficient reasoning."}
{"id": "2506.11763", "categories": ["cs.CL", "cs.IR"], "pdf": "https://arxiv.org/pdf/2506.11763", "abs": "https://arxiv.org/abs/2506.11763", "authors": ["Mingxuan Du", "Benfeng Xu", "Chiwei Zhu", "Xiaorui Wang", "Zhendong Mao"], "title": "DeepResearch Bench: A Comprehensive Benchmark for Deep Research Agents", "comment": "31 pages, 5 figures", "summary": "Deep Research Agents are a prominent category of LLM-based agents. By\nautonomously orchestrating multistep web exploration, targeted retrieval, and\nhigher-order synthesis, they transform vast amounts of online information into\nanalyst-grade, citation-rich reports--compressing hours of manual desk research\ninto minutes. However, a comprehensive benchmark for systematically evaluating\nthe capabilities of these agents remains absent. To bridge this gap, we present\nDeepResearch Bench, a benchmark consisting of 100 PhD-level research tasks,\neach meticulously crafted by domain experts across 22 distinct fields.\nEvaluating DRAs is inherently complex and labor-intensive. We therefore propose\ntwo novel methodologies that achieve strong alignment with human judgment. The\nfirst is a reference-based method with adaptive criteria to assess the quality\nof generated research reports. The other framework is introduced to evaluate\nDRA's information retrieval and collection capabilities by assessing its\neffective citation count and overall citation accuracy. We have open-sourced\nDeepResearch Bench and key components of these frameworks at\nhttps://github.com/Ayanami0730/deep_research_bench to accelerate the\ndevelopment of practical LLM-based agents."}
{"id": "2506.11769", "categories": ["cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11769", "abs": "https://arxiv.org/abs/2506.11769", "authors": ["Tianqi Du", "Haotian Huang", "Yifei Wang", "Yisen Wang"], "title": "Long-Short Alignment for Effective Long-Context Modeling in LLMs", "comment": "ICML 2025", "summary": "Large language models (LLMs) have exhibited impressive performance and\nsurprising emergent properties. However, their effectiveness remains limited by\nthe fixed context window of the transformer architecture, posing challenges for\nlong-context modeling. Among these challenges, length generalization -- the\nability to generalize to sequences longer than those seen during training -- is\na classical and fundamental problem. In this work, we propose a fresh\nperspective on length generalization, shifting the focus from the conventional\nemphasis on input features such as positional encodings or data structures to\nthe output distribution of the model. Specifically, through case studies on\nsynthetic tasks, we highlight the critical role of \\textbf{long-short\nalignment} -- the consistency of output distributions across sequences of\nvarying lengths. Extending this insight to natural language tasks, we propose a\nmetric called Long-Short Misalignment to quantify this phenomenon, uncovering a\nstrong correlation between the metric and length generalization performance.\nBuilding on these findings, we develop a regularization term that promotes\nlong-short alignment during training. Extensive experiments validate the\neffectiveness of our approach, offering new insights for achieving more\neffective long-context modeling in LLMs. Code is available at\nhttps://github.com/PKU-ML/LongShortAlignment."}
{"id": "2506.11798", "categories": ["cs.CL", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11798", "abs": "https://arxiv.org/abs/2506.11798", "authors": ["Maximilian Kreutner", "Marlene Lutz", "Markus Strohmaier"], "title": "Persona-driven Simulation of Voting Behavior in the European Parliament with Large Language Models", "comment": null, "summary": "Large Language Models (LLMs) display remarkable capabilities to understand or\neven produce political discourse, but have been found to consistently display a\nprogressive left-leaning bias. At the same time, so-called persona or identity\nprompts have been shown to produce LLM behavior that aligns with socioeconomic\ngroups that the base model is not aligned with. In this work, we analyze\nwhether zero-shot persona prompting with limited information can accurately\npredict individual voting decisions and, by aggregation, accurately predict\npositions of European groups on a diverse set of policies. We evaluate if\npredictions are stable towards counterfactual arguments, different persona\nprompts and generation methods. Finally, we find that we can simulate voting\nbehavior of Members of the European Parliament reasonably well with a weighted\nF1 score of approximately 0.793. Our persona dataset of politicians in the 2024\nEuropean Parliament and our code are available at\nhttps://github.com/dess-mannheim/european_parliament_simulation."}
{"id": "2506.11807", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11807", "abs": "https://arxiv.org/abs/2506.11807", "authors": ["Simeon Junker", "Manar Ali", "Larissa Koch", "Sina Zarrieß", "Hendrik Buschmeier"], "title": "Are Multimodal Large Language Models Pragmatically Competent Listeners in Simple Reference Resolution Tasks?", "comment": "To appear in ACL Findings 2025", "summary": "We investigate the linguistic abilities of multimodal large language models\nin reference resolution tasks featuring simple yet abstract visual stimuli,\nsuch as color patches and color grids. Although the task may not seem\nchallenging for today's language models, being straightforward for human dyads,\nwe consider it to be a highly relevant probe of the pragmatic capabilities of\nMLLMs. Our results and analyses indeed suggest that basic pragmatic\ncapabilities, such as context-dependent interpretation of color descriptions,\nstill constitute major challenges for state-of-the-art MLLMs."}
{"id": "2506.11857", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11857", "abs": "https://arxiv.org/abs/2506.11857", "authors": ["Yi-Pei Chen", "Noriki Nishida", "Hideki Nakayama", "Yuji Matsumoto"], "title": "Post Persona Alignment for Multi-Session Dialogue Generation", "comment": null, "summary": "Multi-session persona-based dialogue generation presents challenges in\nmaintaining long-term consistency and generating diverse, personalized\nresponses. While large language models (LLMs) excel in single-session\ndialogues, they struggle to preserve persona fidelity and conversational\ncoherence across extended interactions. Existing methods typically retrieve\npersona information before response generation, which can constrain diversity\nand result in generic outputs. We propose Post Persona Alignment (PPA), a novel\ntwo-stage framework that reverses this process. PPA first generates a general\nresponse based solely on dialogue context, then retrieves relevant persona\nmemories using the response as a query, and finally refines the response to\nalign with the speaker's persona. This post-hoc alignment strategy promotes\nnaturalness and diversity while preserving consistency and personalization.\nExperiments on multi-session LLM-generated dialogue data demonstrate that PPA\nsignificantly outperforms prior approaches in consistency, diversity, and\npersona relevance, offering a more flexible and effective paradigm for\nlong-term personalized dialogue generation."}
{"id": "2506.11886", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11886", "abs": "https://arxiv.org/abs/2506.11886", "authors": ["Xiaoran Liu", "Siyang He", "Qiqi Wang", "Ruixiao Li", "Yuerong Song", "Zhigeng Liu", "Linlin Li", "Qun Liu", "Zengfeng Huang", "Qipeng Guo", "Ziwei He", "Xipeng Qiu"], "title": "Beyond Homogeneous Attention: Memory-Efficient LLMs via Fourier-Approximated KV Cache", "comment": "10 pages, 7 figures, work in progress", "summary": "Large Language Models struggle with memory demands from the growing Key-Value\n(KV) cache as context lengths increase. Existing compression methods homogenize\nhead dimensions or rely on attention-guided token pruning, often sacrificing\naccuracy or introducing computational overhead. We propose FourierAttention, a\ntraining-free framework that exploits the heterogeneous roles of transformer\nhead dimensions: lower dimensions prioritize local context, while upper ones\ncapture long-range dependencies. By projecting the long-context-insensitive\ndimensions onto orthogonal Fourier bases, FourierAttention approximates their\ntemporal evolution with fixed-length spectral coefficients. Evaluations on\nLLaMA models show that FourierAttention achieves the best long-context accuracy\non LongBench and Needle-In-A-Haystack (NIAH). Besides, a custom Triton kernel,\nFlashFourierAttention, is designed to optimize memory via streamlined\nread-write operations, enabling efficient deployment without performance\ncompromise."}
{"id": "2506.11903", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11903", "abs": "https://arxiv.org/abs/2506.11903", "authors": ["Raphael Scheible-Schmitt", "Johann Frei"], "title": "GeistBERT: Breathing Life into German NLP", "comment": null, "summary": "Advances in transformer-based language models have highlighted the benefits\nof language-specific pre-training on high-quality corpora. In this context,\nGerman NLP stands to gain from updated architectures and modern datasets\ntailored to the linguistic characteristics of the German language. GeistBERT\nseeks to improve German language processing by incrementally training on a\ndiverse corpus and optimizing model performance across various NLP tasks. It\nwas pre-trained using fairseq with standard hyperparameters, initialized from\nGottBERT weights, and trained on a large-scale German corpus using Whole Word\nMasking (WWM). Based on the pre-trained model, we derived extended-input\nvariants using Nystr\\\"omformer and Longformer architectures with support for\nsequences up to 8k tokens. While these long-context models were not evaluated\non dedicated long-context benchmarks, they are included in our release. We\nassessed all models on NER (CoNLL 2003, GermEval 2014) and text classification\n(GermEval 2018 fine/coarse, 10kGNAD) using $F_1$ score and accuracy. The\nGeistBERT models achieved strong performance, leading all tasks among the base\nmodels and setting a new state-of-the-art (SOTA). Notably, the base models\noutperformed larger models in several tasks. To support the German NLP research\ncommunity, we are releasing GeistBERT under the MIT license."}
{"id": "2506.11919", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11919", "abs": "https://arxiv.org/abs/2506.11919", "authors": ["Greta Damo", "Elena Cabrio", "Serena Villata"], "title": "Effectiveness of Counter-Speech against Abusive Content: A Multidimensional Annotation and Classification Study", "comment": null, "summary": "Counter-speech (CS) is a key strategy for mitigating online Hate Speech (HS),\nyet defining the criteria to assess its effectiveness remains an open\nchallenge. We propose a novel computational framework for CS effectiveness\nclassification, grounded in social science concepts. Our framework defines six\ncore dimensions - Clarity, Evidence, Emotional Appeal, Rebuttal, Audience\nAdaptation, and Fairness - which we use to annotate 4,214 CS instances from two\nbenchmark datasets, resulting in a novel linguistic resource released to the\ncommunity. In addition, we propose two classification strategies, multi-task\nand dependency-based, achieving strong results (0.94 and 0.96 average F1\nrespectively on both expert- and user-written CS), outperforming standard\nbaselines, and revealing strong interdependence among dimensions."}
{"id": "2506.11930", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11930", "abs": "https://arxiv.org/abs/2506.11930", "authors": ["Dongwei Jiang", "Alvin Zhang", "Andrew Wang", "Nicholas Andrews", "Daniel Khashabi"], "title": "Feedback Friction: LLMs Struggle to Fully Incorporate External Feedback", "comment": null, "summary": "Recent studies have shown LLMs possess some ability to improve their\nresponses when given external feedback. However, it remains unclear how\neffectively and thoroughly these models can incorporate extrinsic feedback. In\nan ideal scenario, if LLMs receive near-perfect and complete feedback, we would\nexpect them to fully integrate the feedback and change their incorrect answers\nto correct ones. In this paper, we systematically investigate LLMs' ability to\nincorporate feedback by designing a controlled experimental environment. For\neach problem, a solver model attempts a solution, then a feedback generator\nwith access to near-complete ground-truth answers produces targeted feedback,\nafter which the solver tries again. We evaluate this pipeline across a diverse\nrange of tasks, including math reasoning, knowledge reasoning, scientific\nreasoning, and general multi-domain evaluations with state-of-the-art language\nmodels including Claude 3.7 (with and without extended thinking). Surprisingly,\neven under these near-ideal conditions, solver models consistently show\nresistance to feedback, a limitation that we term FEEDBACK FRICTION. To\nmitigate this limitation, we experiment with sampling-based strategies like\nprogressive temperature increases and explicit rejection of previously\nattempted incorrect answers, which yield improvements but still fail to help\nmodels achieve target performance. We also perform a rigorous exploration of\npotential causes of FEEDBACK FRICTION, ruling out factors such as model\noverconfidence and data familiarity. We hope that highlighting this issue in\nLLMs and ruling out several apparent causes will help future research in\nself-improvement."}
{"id": "2506.11938", "categories": ["cs.CL", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11938", "abs": "https://arxiv.org/abs/2506.11938", "authors": ["Samuel Simko", "Mrinmaya Sachan", "Bernhard Schölkopf", "Zhijing Jin"], "title": "Improving Large Language Model Safety with Contrastive Representation Learning", "comment": null, "summary": "Large Language Models (LLMs) are powerful tools with profound societal\nimpacts, yet their ability to generate responses to diverse and uncontrolled\ninputs leaves them vulnerable to adversarial attacks. While existing defenses\noften struggle to generalize across varying attack types, recent advancements\nin representation engineering offer promising alternatives. In this work, we\npropose a defense framework that formulates model defense as a contrastive\nrepresentation learning (CRL) problem. Our method finetunes a model using a\ntriplet-based loss combined with adversarial hard negative mining to encourage\nseparation between benign and harmful representations. Our experimental results\nacross multiple models demonstrate that our approach outperforms prior\nrepresentation engineering-based defenses, improving robustness against both\ninput-level and embedding-space attacks without compromising standard\nperformance. Our code is available at\nhttps://github.com/samuelsimko/crl-llm-defense"}
{"id": "2506.12014", "categories": ["cs.CL", "cs.AI", "cs.LG", "cs.SE"], "pdf": "https://arxiv.org/pdf/2506.12014", "abs": "https://arxiv.org/abs/2506.12014", "authors": ["Yuliang Xu", "Siming Huang", "Mingmeng Geng", "Yao Wan", "Xuanhua Shi", "Dongping Chen"], "title": "code_transformed: The Influence of Large Language Models on Code", "comment": "We release all the experimental dataset and source code at:\n  https://github.com/ignorancex/LLM_code", "summary": "Coding remains one of the most fundamental modes of interaction between\nhumans and machines. With the rapid advancement of Large Language Models\n(LLMs), code generation capabilities have begun to significantly reshape\nprogramming practices. This development prompts a central question: Have LLMs\ntransformed code style, and how can such transformation be characterized? In\nthis paper, we present a pioneering study that investigates the impact of LLMs\non code style, with a focus on naming conventions, complexity, maintainability,\nand similarity. By analyzing code from over 19,000 GitHub repositories linked\nto arXiv papers published between 2020 and 2025, we identify measurable trends\nin the evolution of coding style that align with characteristics of\nLLM-generated code. For instance, the proportion of snake\\_case variable names\nin Python code increased from 47% in Q1 2023 to 51% in Q1 2025. Furthermore, we\ninvestigate how LLMs approach algorithmic problems by examining their reasoning\nprocesses. Given the diversity of LLMs and usage scenarios, among other\nfactors, it is difficult or even impossible to precisely estimate the\nproportion of code generated or assisted by LLMs. Our experimental results\nprovide the first large-scale empirical evidence that LLMs affect real-world\nprogramming style."}
{"id": "2506.11022", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11022", "abs": "https://arxiv.org/abs/2506.11022", "authors": ["Shivani Shukla", "Himanshu Joshi", "Romilla Syed"], "title": "Security Degradation in Iterative AI Code Generation -- A Systematic Analysis of the Paradox", "comment": "Keywords - Large Language Models, Security Vulnerabilities,\n  AI-Generated Code, Iterative Feedback, Software Security, Secure Coding\n  Practices, Feedback Loops, LLM Prompting Strategies", "summary": "The rapid adoption of Large Language Models(LLMs) for code generation has\ntransformed software development, yet little attention has been given to how\nsecurity vulnerabilities evolve through iterative LLM feedback. This paper\nanalyzes security degradation in AI-generated code through a controlled\nexperiment with 400 code samples across 40 rounds of \"improvements\" using four\ndistinct prompting strategies. Our findings show a 37.6% increase in critical\nvulnerabilities after just five iterations, with distinct vulnerability\npatterns emerging across different prompting approaches. This evidence\nchallenges the assumption that iterative LLM refinement improves code security\nand highlights the essential role of human expertise in the loop. We propose\npractical guidelines for developers to mitigate these risks, emphasizing the\nneed for robust human validation between LLM iterations to prevent the\nparadoxical introduction of new security issues during supposedly beneficial\ncode \"improvements\"."}
{"id": "2506.11059", "categories": ["cs.SE", "cs.CL", "cs.CY", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11059", "abs": "https://arxiv.org/abs/2506.11059", "authors": ["Hanxi Guo", "Siyuan Cheng", "Kaiyuan Zhang", "Guangyu Shen", "Xiangyu Zhang"], "title": "CodeMirage: A Multi-Lingual Benchmark for Detecting AI-Generated and Paraphrased Source Code from Production-Level LLMs", "comment": null, "summary": "Large language models (LLMs) have become integral to modern software\ndevelopment, producing vast amounts of AI-generated source code. While these\nmodels boost programming productivity, their misuse introduces critical risks,\nincluding code plagiarism, license violations, and the propagation of insecure\nprograms. As a result, robust detection of AI-generated code is essential. To\nsupport the development of such detectors, a comprehensive benchmark that\nreflects real-world conditions is crucial. However, existing benchmarks fall\nshort -- most cover only a limited set of programming languages and rely on\nless capable generative models. In this paper, we present CodeMirage, a\ncomprehensive benchmark that addresses these limitations through three major\nadvancements: (1) it spans ten widely used programming languages, (2) includes\nboth original and paraphrased code samples, and (3) incorporates outputs from\nten state-of-the-art production-level LLMs, including both reasoning and\nnon-reasoning models from six major providers. Using CodeMirage, we evaluate\nten representative detectors across four methodological paradigms under four\nrealistic evaluation configurations, reporting results using three\ncomplementary metrics. Our analysis reveals nine key findings that uncover the\nstrengths and weaknesses of current detectors, and identify critical challenges\nfor future work. We believe CodeMirage offers a rigorous and practical testbed\nto advance the development of robust and generalizable AI-generated code\ndetectors."}
{"id": "2506.11085", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.IR", "cs.LG", "cs.LO", "I.2.6; H.3.3; I.2.3"], "pdf": "https://arxiv.org/pdf/2506.11085", "abs": "https://arxiv.org/abs/2506.11085", "authors": ["Justin Asher"], "title": "LeanExplore: A search engine for Lean 4 declarations", "comment": "16 pages, 1 figure. Project website: https://www.leanexplore.com/ ,\n  Code: https://github.com/justincasher/lean-explore", "summary": "The expanding Lean 4 ecosystem poses challenges for navigating its vast\nlibraries. This paper introduces LeanExplore, a search engine for Lean 4\ndeclarations. LeanExplore enables users to semantically search for statements,\nboth formally and informally, across select Lean 4 packages (including\nBatteries, Init, Lean, Mathlib, PhysLean, and Std). This search capability is\npowered by a hybrid ranking strategy, integrating scores from a multi-source\nsemantic embedding model (capturing conceptual meaning from formal Lean code,\ndocstrings, AI-generated informal translations, and declaration titles), BM25+\nfor keyword-based lexical relevance, and a PageRank-based score reflecting\ndeclaration importance and interconnectedness. The search engine is accessible\nvia a dedicated website (https://www.leanexplore.com/) and a Python API\n(https://github.com/justincasher/lean-explore). Furthermore, the database can\nbe downloaded, allowing users to self-host the service. LeanExplore integrates\neasily with LLMs via the model context protocol (MCP), enabling users to chat\nwith an AI assistant about Lean declarations or utilize the search engine for\nbuilding theorem-proving agents. This work details LeanExplore's architecture,\ndata processing, functionalities, and its potential to enhance Lean 4 workflows\nand AI-driven mathematical research"}
{"id": "2506.11237", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2506.11237", "abs": "https://arxiv.org/abs/2506.11237", "authors": ["Ngoc Phuoc An Vo", "Brent Paulovicks", "Vadim Sheinin"], "title": "LLM-as-a-Judge for Reference-less Automatic Code Validation and Refinement for Natural Language to Bash in IT Automation", "comment": "10 pages", "summary": "In an effort to automatically evaluate and select the best model and improve\ncode quality for automatic incident remediation in IT Automation, it is crucial\nto verify if the generated code for remediation action is syntactically and\nsemantically correct and whether it can be executed correctly as intended.\nThere are three approaches: 1) conventional methods use surface form similarity\nmetrics (token match, exact match, etc.) which have numerous limitations, 2)\nexecution-based evaluation focuses more on code functionality based on\npass/fail judgments for given test-cases, and 3) LLM-as-a-Judge employs LLMs\nfor automated evaluation to judge if it is a correct answer for a given problem\nbased on pre-defined metrics. In this work, we focused on enhancing\nLLM-as-a-Judge using bidirectional functionality matching and logic\nrepresentation for reference-less automatic validation and refinement for Bash\ncode generation to select the best model for automatic incident remediation in\nIT Automation. We used execution-based evaluation as ground-truth to evaluate\nour LLM-as-a-Judge metrics. Results show high accuracy and agreement with\nexecution-based evaluation (and up to 8% over baseline). Finally, we built\nReflection code agents to utilize judgments and feedback from our evaluation\nmetrics which achieved significant improvement (up to 24% increase in accuracy)\nfor automatic code refinement."}
{"id": "2506.11928", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.11928", "abs": "https://arxiv.org/abs/2506.11928", "authors": ["Zihan Zheng", "Zerui Cheng", "Zeyu Shen", "Shang Zhou", "Kaiyuan Liu", "Hansen He", "Dongruixuan Li", "Stanley Wei", "Hangyi Hao", "Jianzhu Yao", "Peiyao Sheng", "Zixuan Wang", "Wenhao Chai", "Aleksandra Korolova", "Peter Henderson", "Sanjeev Arora", "Pramod Viswanath", "Jingbo Shang", "Saining Xie"], "title": "LiveCodeBench Pro: How Do Olympiad Medalists Judge LLMs in Competitive Programming?", "comment": "Project Page at https://livecodebenchpro.com/", "summary": "Recent reports claim that large language models (LLMs) now outperform elite\nhumans in competitive programming. Drawing on knowledge from a group of\nmedalists in international algorithmic contests, we revisit this claim,\nexamining how LLMs differ from human experts and where limitations still\nremain. We introduce LiveCodeBench Pro, a benchmark composed of problems from\nCodeforces, ICPC, and IOI that are continuously updated to reduce the\nlikelihood of data contamination. A team of Olympiad medalists annotates every\nproblem for algorithmic categories and conducts a line-by-line analysis of\nfailed model-generated submissions. Using this new data and benchmark, we find\nthat frontier models still have significant limitations: without external\ntools, the best model achieves only 53% pass@1 on medium-difficulty problems\nand 0% on hard problems, domains where expert humans still excel. We also find\nthat LLMs succeed at implementation-heavy problems but struggle with nuanced\nalgorithmic reasoning and complex case analysis, often generating confidently\nincorrect justifications. High performance appears largely driven by\nimplementation precision and tool augmentation, not superior reasoning.\nLiveCodeBench Pro thus highlights the significant gap to human grandmaster\nlevels, while offering fine-grained diagnostics to steer future improvements in\ncode-centric LLM reasoning."}

<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.SE](#cs.SE) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Modelling Program Spaces in Program Synthesis with Constraints](https://arxiv.org/abs/2508.00005)
*Tilman Hinnerichs,Bart Swinkels,Jaap de Jong,Reuben Gardos Reid,Tudor Magirescu,Neil Yorke-Smith,Sebastijan Dumancic*

Main category: cs.PL

TL;DR: 本文提出通过语法约束优化程序综合空间，并推出了BART求解器，实验表明能缩减99%的候选空间并加速程序枚举。


<details>
  <summary>Details</summary>
Motivation: 程序综合面临的核心挑战是如何高效地筛选庞大的候选程序空间。虽然组合约束求解器已被用来表达程序语义，但并未充分利用约束来排除不需要的程序。近来的归纳逻辑编程方法引入了对程序语法的约束，但该方向仍有进一步开发空间。

Method: 本文通过语法约束来建模程序空间，利用对约束的有效传播与求解，不仅定义可行程序，也定义有潜力的实用程序。为此，作者提出了BART求解器，能够高效处理和传播这类语法约束。

Result: 在程序空间枚举任务上的实验表明，BART借助约束能排除高达99%的不需要的程序空间，极大减少了枚举的时间。

Conclusion: 通过高效利用语法层面的约束，程序综合中的解空间得以显著缩减，提升了枚举效率，显示了BART的优势。

Abstract: A core challenge in program synthesis is taming the large space of possible
programs. Since program synthesis is essentially a combinatorial search, the
community has sought to leverage powerful combinatorial constraint solvers.
Here, constraints are used to express the program semantics, but not as a
potentially potent tool to remove unwanted programs. Recent inductive logic
programming approaches introduce constraints on the program's syntax to be
synthesized. These syntactic constraints allow for checking and propagating a
constraint without executing the program, and thus for arbitrary operators. In
this work, we leverage syntactic constraints to model program spaces, defining
not just solutions that are feasible, but also ones that are likely useful. To
demonstrate this idea, we introduce BART, a solver that efficiently propagates
and solves these constraints. We evaluate BART on program space enumeration
tasks, finding that the constraints eliminate up to 99 percent of the program
space, and that modeling program spaces significantly reduces enumeration time.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [2] [Tool-Assisted Conformance Checking to Reference Process Models](https://arxiv.org/abs/2508.00738)
*Bernhard Rumpe,Max Stachon,Sebastian Stüber,Valdes Voufo*

Main category: cs.SE

TL;DR: 本文提出了一种基于因果依赖分析的流程模型自动合规性检查方法，解决了现有方法缺乏语义对比与自动化的问题，经案例分析验证了其实用性，并指出了方法的优势和局限。


<details>
  <summary>Details</summary>
Motivation: 参考模型能够传递最佳实践和标准，但目前针对流程模型的合规性检查大多聚焦于流程执行轨迹，缺乏语义层面的对比能力和自动化手段。因此，如何有效自动化并提升模型语义对比的能力成为一项亟需解决的问题。

Method: 本研究提出基于任务和事件因果依赖分析的方法，实现具体流程模型与参考模型的自动化合规性检查，并将其集成到更广泛的语义合规框架中。文中给出了具体算法，并通过案例分析进行了评估。

Result: 所提出的方法能够增强流程模型合规性验证的准确性和灵活性，并提供了工具辅助的解决方案。案例研究展示了该方法的有效性，同时也讨论了相关优势与局限。

Conclusion: 自动化、基于因果依赖分析的流程模型合规性检查能有效提升对参考模型标准的遵从性，方法兼具实用性和推广价值。

Abstract: Reference models convey best practices and standards. The reference
frameworks necessitate conformance checks to ensure adherence to established
guidelines and principles, which is crucial for maintaining quality and
consistency in various processes. This paper explores automated conformance
checks for concrete process models against reference models using causal
dependency analysis of tasks and events. Existing notions of conformance
checking for process models focus on verifying process execution traces and
lack the expressiveness and automation needed for semantic model comparison,
leaving this question unresolved. We integrate our approach into a broader
semantic framework for defining reference model conformance. We outline an
algorithm for reference process model conformance checking, evaluate it through
a case study, and discuss its strengths and limitations. Our research provides
a tool-assisted solution enhancing accuracy and flexibility in process model
conformance verification.

</details>


### [3] [Dynamic Symbolic Execution for Semantic Difference Analysis of Component and Connector Architectures](https://arxiv.org/abs/2508.00749)
*Johanna Grahl,Bernhard Rumpe,Max Stachon,Sebastian Stüber*

Main category: cs.SE

TL;DR: 本文提出并实现了基于DSE的MontiArc模型语义差异分析方法，能够识别关键执行轨迹，但在处理大型系统时遇到可扩展性问题，需后续改进。


<details>
  <summary>Details</summary>
Motivation: 在模型驱动开发中，模型的正确性和一致性至关重要。模型在演化过程中，如何高效且准确地分析其语义差异，是提升系统质量的关键问题。

Method: 本文研究了动态符号执行（DSE）在组件-连接器架构语义差异分析中的应用，具体以MontiArc模型为例。作者增强了MontiArc到Java的代码生成器，在运行时收集符号和具体执行数据，包括自动机的转换条件、已访问状态和内部变量。基于这些数据，分析重要的执行轨迹。还提出了效率、最小性和完整性等评估标准，对不同执行策略进行比较。

Result: 实验证明DSE在分析此类架构的语义差异上具有一定潜力，但仍受限于可扩展性。对于规模较大的系统，其实际应用还需进一步技术突破。

Conclusion: DSE为组件-连接器架构的语义差异分析提供了新的途径，但其扩展到大型系统尚面临挑战，需要进一步研究改进其可扩展性和实用性。

Abstract: In the context of model-driven development, ensuring the correctness and
consistency of evolving models is paramount. This paper investigates the
application of Dynamic Symbolic Execution (DSE) for semantic difference
analysis of component-and-connector architectures, specifically utilizing
MontiArc models. We have enhanced the existing MontiArc-to-Java generator to
gather both symbolic and concrete execution data at runtime, encompassing
transition conditions, visited states, and internal variables of automata. This
data facilitates the identification of significant execution traces that
provide critical insights into system behavior. We evaluate various execution
strategies based on the criteria of runtime efficiency, minimality, and
completeness, establishing a framework for assessing the applicability of DSE
in semantic difference analysis. Our findings indicate that while DSE shows
promise for analyzing component and connector architectures, scalability
remains a primary limitation, suggesting further research is needed to enhance
its practical utility in larger systems.

</details>


### [4] [Git Context Controller: Manage the Context of LLM-based Agents like Git](https://arxiv.org/abs/2508.00031)
*Junde Wu*

Main category: cs.SE

TL;DR: 本文提出Git-Context-Controller(GCC)，以软件版本管理理念对大模型智能体上下文进行结构化管理，显著提升了其在复杂任务中的表现。


<details>
  <summary>Details</summary>
Motivation: 随着大语言模型(LLM)为基础的智能体在如长期编码项目等长流程任务中被应用，如何高效管理上下文成为制约其表现的关键瓶颈。现有方法在长距离信息关联和情景切换方面仍显不足。

Method: 提出了一种受软件版本控制系统启发的结构化上下文管理框架——Git-Context-Controller(GCC)。该方法将上下文管理提升为类似Git的版本化记忆体系，以持久化文件系统为结构，通过COMMIT、BRANCH、MERGE和CONTEXT等操作实现智能体记忆的里程碑式检查点保存、分支探索与反思管理等能力。

Result: 在SWE-Bench-Lite基准测试上，装备GCC后的智能体修复了48.00%的软件缺陷，超过了26个竞争系统。在自我复制案例中，应用GCC的智能体自零开发新CLI智能体，任务完成率40.7%，远高于未加GCC时的11.7%。

Conclusion: GCC极大提升了智能体在长周期和复杂任务中的上下文管理与任务解决能力，为增强多Agent协作和知识遗传提供了有力工具，具有实际应用和进一步探索价值。

Abstract: Large language model (LLM) based agents have shown impressive capabilities by
interleaving internal reasoning with external tool use. However, as these
agents are deployed in long-horizon workflows, such as coding for a big,
long-term project, context management becomes a critical bottleneck. We
introduce Git-Context-Controller (GCC), a structured context management
framework inspired by software version control systems. GCC elevates context as
versioned memory hierarchy like Git. It structures agent memory as a persistent
file system with explicit operations: COMMIT, BRANCH, MERGE, and CONTEXT,
enabling milestone-based checkpointing, exploration of alternative plans, and
structured reflection. Our approach empowers agents to manage long-term goals,
isolate architectural experiments, and recover or hand off memory across
sessions and agents. Empirically, agents equipped with GCC achieve
state-of-the-art performance on the SWE-Bench-Lite benchmark, resolving 48.00
of software bugs, outperforming 26 competitive systems. In a self-replication
case study, a GCC-augmented agent builds a new CLI agent from scratch,
achieving 40.7 task resolution, compared to only 11.7 without GCC. The code is
released at: https://github.com/theworldofagents/GCC

</details>

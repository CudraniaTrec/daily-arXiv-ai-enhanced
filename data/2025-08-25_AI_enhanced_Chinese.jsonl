{"id": "2508.15866", "categories": ["cs.PL", "cs.LG", "cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15866", "abs": "https://arxiv.org/abs/2508.15866", "authors": ["Lingxiao Li", "Salar Rahili", "Yiwei Zhao"], "title": "Correctness-Guaranteed Code Generation via Constrained Decoding", "comment": "Published at COLM 2025", "summary": "Language Models (LMs) are increasingly being used for code generation, but\nensuring the correctness of generated programs remains a significant challenge.\nAlthough imperfect code may be acceptable during software development with\nhuman oversight, domains such as video games and robotics require one-shot\ncorrectness for runtime-critical components. We present a constrained decoding\nalgorithm for generating semantically correct programs that incorporates a\ncontext-sensitive parser, which, at each step, outputs a regular expression\nthat satisfies a critical non-extensible property to guide the generation of\nthe next token sequence that can continue to a correct program. To build such a\ncontext-sensitive parser, we propose a framework of a dynamic tree of parsers\n(ToP) during parsing, where each parser corresponds to a modular context-free\ngrammar enriched with contextual information such as variable scopes and type\nconstraints, with tree branches representing ambiguity in the future code\nsegment. We demonstrate our approach through sLua, a strongly typed variant of\nLua, showing that our method can generate semantically correct programs\nconforming to any prescribed scripting API. We further show that, with careful\ndesign, our semantic guarantees extend to runtime correctness, as validated in\nthe application of generating game mechanics for a roguelike video game.", "AI": {"tldr": "\u8be5\u8bba\u6587\u9488\u5bf9\u4ee3\u7801\u751f\u6210\u6b63\u786e\u6027\u95ee\u9898\uff0c\u63d0\u51fa\u7ed3\u5408\u4e0a\u4e0b\u6587\u654f\u611f\u89e3\u6790\u5668\u548c\u7ea6\u675f\u6027\u89e3\u7801\u7684\u65b0\u7b97\u6cd5\uff0c\u5e76\u901a\u8fc7sLua\u548c\u6e38\u620f\u5b9e\u4f8b\u9a8c\u8bc1\u4e86\u5176\u53ef\u751f\u6210\u8bed\u4e49\u53ca\u8fd0\u884c\u65f6\u5747\u6b63\u786e\u7684\u7a0b\u5e8f\uff0c\u9002\u5408\u5bf9\u4ee3\u7801\u8d28\u91cf\u8981\u6c42\u6781\u9ad8\u7684\u573a\u666f\u3002", "motivation": "\u968f\u7740\u8bed\u8a00\u6a21\u578b\u5728\u4ee3\u7801\u751f\u6210\u9886\u57df\u7684\u5e7f\u6cdb\u5e94\u7528\uff0c\u63d0\u9ad8\u751f\u6210\u4ee3\u7801\u7684\u6b63\u786e\u6027\u5df2\u6210\u4e3a\u6838\u5fc3\u96be\u9898\u3002\u4e00\u822c\u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u4e0d\u5b8c\u7f8e\u4ee3\u7801\u5c1a\u53ef\u63a5\u53d7\uff0c\u4f46\u5728\u89c6\u9891\u6e38\u620f\u548c\u673a\u5668\u4eba\u9886\u57df\uff0c\u5bf9\u8fd0\u884c\u65f6\u5173\u952e\u7ec4\u4ef6\u5219\u8981\u6c42\u4e00\u6b21\u6027\u751f\u6210\u6b63\u786e\u4ee3\u7801\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u7ea6\u675f\u6027\u89e3\u7801\u7b97\u6cd5\uff0c\u7ed3\u5408\u4e0a\u4e0b\u6587\u654f\u611f\u7684\u89e3\u6790\u5668\u3002\u8be5\u89e3\u6790\u5668\u5728\u751f\u6210\u8fc7\u7a0b\u4e2d\u6bcf\u4e00\u6b65\u8f93\u51fa\u4e00\u4e2a\u6ee1\u8db3\u5173\u952e\u4e0d\u53ef\u6269\u5c55\u5c5e\u6027\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\uff0c\u6307\u5bfc\u4e0b\u4e00\u4e2a\u53ef\u751f\u6210\u6b63\u786e\u7a0b\u5e8f\u7684\u7b26\u53f7\u5e8f\u5217\u3002\u6b64\u5916\uff0c\u63d0\u51fa\u4e86\u57fa\u4e8e\u52a8\u6001\u89e3\u6790\u5668\u6811\uff08ToP\uff09\u7684\u6846\u67b6\uff0c\u6bcf\u4e2a\u89e3\u6790\u5668\u5bf9\u5e94\u4e0a\u4e0b\u6587\u76f8\u5173\u7684\u4fe1\u606f\uff0c\u5982\u53d8\u91cf\u4f5c\u7528\u57df\u548c\u7c7b\u578b\u7ea6\u675f\uff0c\u6811\u5206\u652f\u5219\u8868\u793a\u4ee3\u7801\u672a\u6765\u6bb5\u7684\u4e0d\u786e\u5b9a\u6027\u3002", "result": "\u901a\u8fc7\u5bf9Lua\u7684\u5f3a\u7c7b\u578b\u53d8\u79cdsLua\u8fdb\u884c\u5b9e\u9a8c\uff0c\u8bc1\u660e\u6240\u63d0\u51fa\u65b9\u6cd5\u80fd\u751f\u6210\u6ee1\u8db3\u6307\u5b9a\u811a\u672cAPI\u7684\u8bed\u4e49\u6b63\u786e\u7a0b\u5e8f\u3002\u8fdb\u4e00\u6b65\u5728roguelike\u6e38\u620f\u673a\u5236\u751f\u6210\u4e0a\uff0c\u9a8c\u8bc1\u8be5\u65b9\u6cd5\u53ef\u901a\u8fc7\u8bbe\u8ba1\u83b7\u5f97\u8fd0\u884c\u65f6\u6b63\u786e\u6027\u3002", "conclusion": "\u63d0\u51fa\u7684\u4e0a\u4e0b\u6587\u654f\u611f\u89e3\u6790\u548c\u7ea6\u675f\u89e3\u7801\u7b97\u6cd5\u80fd\u663e\u8457\u63d0\u5347\u8bed\u8a00\u6a21\u578b\u751f\u6210\u4ee3\u7801\u7684\u8bed\u4e49\u548c\u8fd0\u884c\u65f6\u6b63\u786e\u6027\uff0c\u7279\u522b\u9002\u7528\u4e8e\u9700\u8981\u9ad8\u6b63\u786e\u6027\u4fdd\u8bc1\u7684\u9886\u57df\uff0c\u5982\u6e38\u620f\u548c\u673a\u5668\u4eba\u5f00\u53d1\u3002"}}
{"id": "2508.15898", "categories": ["cs.PL", "cs.CR"], "pdf": "https://arxiv.org/pdf/2508.15898", "abs": "https://arxiv.org/abs/2508.15898", "authors": ["Matthew Sotoudeh", "Zachary Yedidia"], "title": "Automated Formal Verification of a Software Fault Isolation System", "comment": "Short paper to appear at FMCAD 2025, https://fmcad.org/", "summary": "Software fault isolation (SFI) is a popular way to sandbox untrusted\nsoftware. A key component of SFI is the verifier that checks the untrusted code\nis written in a subset of the machine language that guarantees it never reads\nor writes outside of a region of memory dedicated to the sandbox. Soundness\nbugs in the SFI verifier would break the SFI security model and allow the\nsupposedly sandboxed code to read protected memory. In this paper, we address\nthe concern of SFI verifier bugs by performing an automated formal verification\nof a recent SFI system called Lightweight Fault Isolation (LFI). In particular,\nwe formally verify that programs accepted by the LFI verifier never read or\nwrite to memory outside of a designated sandbox region.", "AI": {"tldr": "\u672c\u6587\u5229\u7528\u81ea\u52a8\u5316\u5f62\u5f0f\u5316\u9a8c\u8bc1\u65b9\u6cd5\uff0c\u8bc1\u660eLFI\u7cfb\u7edf\u4e2d\u7684SFI\u9a8c\u8bc1\u5668\u80fd\u591f\u5b89\u5168\u5730\u9650\u5236\u4ee3\u7801\u4ec5\u8bbf\u95ee\u6c99\u7bb1\u5185\u5b58\u533a\u57df\uff0c\u6709\u6548\u63d0\u5347\u7cfb\u7edf\u5b89\u5168\u6027\u3002", "motivation": "SFI\uff08\u8f6f\u4ef6\u6545\u969c\u9694\u79bb\uff09\u4f5c\u4e3a\u4e00\u79cd\u6d41\u884c\u7684\u6c99\u7bb1\u6280\u672f\uff0c\u5176\u5b89\u5168\u6027\u4f9d\u8d56\u4e8e\u9a8c\u8bc1\u5668\u786e\u4fdd\u4e0d\u53ef\u4fe1\u4ee3\u7801\u65e0\u6cd5\u8bbf\u95ee\u6307\u5b9a\u6c99\u7bb1\u533a\u57df\u4e4b\u5916\u7684\u5185\u5b58\u3002\u9a8c\u8bc1\u5668\u51fa\u73b0\u6f0f\u6d1e\u5c06\u5371\u53ca\u6574\u4f53\u5b89\u5168\u6027\uff0c\u5141\u8bb8\u6076\u610f\u4ee3\u7801\u8d8a\u754c\u8bbf\u95ee\u654f\u611f\u5185\u5b58\u3002\u672c\u6587\u5173\u6ce8\u4e8eSFI\u9a8c\u8bc1\u5668\u6f5c\u5728\u7684\u6b63\u786e\u6027\u95ee\u9898\u3002", "method": "\u4f5c\u8005\u5bf9\u4e00\u79cd\u540d\u4e3aLFI\uff08\u8f7b\u91cf\u7ea7\u6545\u969c\u9694\u79bb\uff09\u7684\u6700\u65b0SFI\u7cfb\u7edf\u8fdb\u884c\u4e86\u81ea\u52a8\u5316\u5f62\u5f0f\u5316\u9a8c\u8bc1\uff0c\u5177\u4f53\u68c0\u67e5\u9a8c\u8bc1\u5668\u63a5\u53d7\u7684\u7a0b\u5e8f\u662f\u5426\u4e25\u683c\u9650\u5236\u5728\u6c99\u7bb1\u533a\u57df\u5185\u8bfb\u5199\u5185\u5b58\u3002", "result": "\u4f5c\u8005\u5b9e\u73b0\u4e86\u5bf9LFI\u9a8c\u8bc1\u5668\u7684\u81ea\u52a8\u5316\u5f62\u5f0f\u5316\u9a8c\u8bc1\uff0c\u8bc1\u660e\u5176\u80fd\u4fdd\u8bc1\u88ab\u63a5\u6536\u7684\u7a0b\u5e8f\u4ec5\u5728\u6307\u5b9a\u7684\u6c99\u7bb1\u533a\u57df\u5185\u8bfb\u5199\u5185\u5b58\u3002", "conclusion": "\u672c\u6587\u8bc1\u5b9eLFI\u7cfb\u7edf\u7684\u9a8c\u8bc1\u5668\u662f\u6b63\u786e\u4e14\u5b89\u5168\u7684\uff0c\u88ab\u63a5\u53d7\u7684\u7a0b\u5e8f\u4e0d\u4f1a\u8d8a\u754c\u8bfb\u5199\u5185\u5b58\uff0c\u4ece\u800c\u6709\u6548\u6d88\u9664\u76f8\u5173\u7684\u5b89\u5168\u9690\u60a3\u3002"}}
{"id": "2508.16063", "categories": ["cs.PL", "cs.FL"], "pdf": "https://arxiv.org/pdf/2508.16063", "abs": "https://arxiv.org/abs/2508.16063", "authors": ["Paul Krogmeier", "P. Madhusudan"], "title": "Synthesizing DSLs for Few-Shot Learning", "comment": null, "summary": "We study the problem of synthesizing domain-specific languages (DSLs) for\nfew-shot learning in symbolic domains. Given a base language and instances of\nfew-shot learning problems, where each instance is split into training and\ntesting samples, the DSL synthesis problem asks for a grammar over the base\nlanguage that guarantees that small expressions solving training samples also\nsolve corresponding testing samples. We prove that the problem is decidable for\na class of languages whose semantics over fixed structures can be evaluated by\ntree automata and when expression size corresponds to parse tree depth in the\ngrammar, and, furthermore, the grammars solving the problem correspond to a\nregular set of trees. We also prove decidability results for variants of the\nproblem where DSLs are only required to express solutions for input learning\nproblems and where DSLs are defined using macro grammars.", "AI": {"tldr": "\u8be5\u8bba\u6587\u7814\u7a76\u4e86\u57fa\u4e8e\u5c11\u6837\u672c\u5b66\u4e60\u81ea\u52a8\u5408\u6210\u9886\u57df\u7279\u5b9a\u8bed\u8a00\u7684\u95ee\u9898\uff0c\u63d0\u51fa\u4e86\u5224\u5b9a\u6027\u5206\u6790\u65b9\u6cd5\uff0c\u5e76\u7ed9\u51fa\u5728\u6811\u81ea\u52a8\u673a\u8bed\u4e49\u4e0b\u7684\u53ef\u5224\u5b9a\u6027\u7406\u8bba\u7ed3\u679c\u3002", "motivation": "\u5c11\u6837\u672c\u5b66\u4e60\u5728\u7b26\u53f7\u9886\u57df\u5e94\u7528\u5e7f\u6cdb\uff0c\u4f46\u5b9e\u9645\u5f80\u5f80\u7f3a\u4e4f\u6709\u6548\u7684DSL\u6765\u652f\u6301\u8868\u8fbe\u548c\u63a8\u65ad\u3002\u7814\u7a76\u57fa\u4e8e\u5c11\u91cf\u8bad\u7ec3\u6837\u672c\u81ea\u52a8\u5408\u6210\u80fd\u63a8\u5e7f\u5230\u6d4b\u8bd5\u6837\u672c\u7684DSL\uff0c\u4ee5\u63d0\u5347\u5c11\u6837\u672c\u5b66\u4e60\u7684\u53ef\u6269\u5c55\u6027\u548c\u81ea\u52a8\u5316\u7a0b\u5ea6\u3002", "method": "\u901a\u8fc7\u5f62\u5f0f\u5316DSL\u7684\u5408\u6210\u95ee\u9898\uff0c\u5e76\u5229\u7528\u6811\u81ea\u52a8\u673a\u5206\u6790\u542b\u6709\u56fa\u5b9a\u7ed3\u6784\u7684\u8bed\u8a00\u8bed\u4e49\uff0c\u540c\u65f6\u4ee5\u89e3\u6790\u6811\u6df1\u5ea6\u523b\u753b\u8868\u8fbe\u5f0f\u89c4\u6a21\u3002\u8fdb\u4e00\u6b65\u901a\u8fc7\u6b63\u89c4\u6811\u96c6\u5408\u63cf\u8ff0\u6ee1\u8db3\u8bad\u7ec3\u6837\u672c\u53ca\u6d4b\u8bd5\u6837\u672c\u7684\u8bed\u6cd5\u3002\u8fd8\u5bf9\u5b8f\u8bed\u6cd5\u53ca\u4ec5\u5bf9\u8f93\u5165\u95ee\u9898\u9002\u7528\u7684DSL\u5408\u6210\u95ee\u9898\u8fdb\u884c\u4e86\u5224\u5b9a\u6027\u5206\u6790\u3002", "result": "\u8bba\u6587\u8bc1\u660e\u4e86\uff0c\u5f53\u56fa\u5b9a\u7ed3\u6784\u8bed\u8a00\u53ef\u7531\u6811\u81ea\u52a8\u673a\u8bc4\u4f30\u4e14\u8868\u8fbe\u5f0f\u5927\u5c0f\u5bf9\u5e94\u4e8e\u8bed\u6cd5\u89e3\u6790\u6811\u6df1\u5ea6\u65f6\uff0cDSL\u5408\u6210\u95ee\u9898\u662f\u53ef\u5224\u5b9a\u7684\uff1b\u7ed9\u51fa\u4e86\u76f8\u5173\u8bed\u6cd5\u7684\u6b63\u89c4\u6811\u96c6\u8868\u793a\u3002\u4e5f\u8bc1\u660e\u4e86\u5b8f\u8bed\u6cd5\u548c\u90e8\u5206\u53d8\u4f53\u573a\u666f\u4e0b\u95ee\u9898\u7684\u53ef\u5224\u5b9a\u6027\u3002", "conclusion": "\u8bba\u6587\u8bc1\u660e\u4e86\u5728\u7279\u5b9a\u6761\u4ef6\u4e0b\uff0c\u5408\u6210\u9886\u57df\u7279\u5b9a\u8bed\u8a00\uff08DSLs\uff09\u4ee5\u652f\u6301\u7b26\u53f7\u9886\u57df\u7684\u5c11\u6837\u672c\u5b66\u4e60\u95ee\u9898\u662f\u53ef\u5224\u5b9a\u7684\uff0c\u5e76\u4e14\u53ef\u5f97\u5230\u6ee1\u8db3\u8981\u6c42\u7684DSL\u8bed\u6cd5\u3002"}}
{"id": "2508.16125", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16125", "abs": "https://arxiv.org/abs/2508.16125", "authors": ["Zhenyang Xu", "Hongxu Xu", "Yongqiang Tian", "Xintong Zhou", "Chengnian Sun"], "title": "Leveraging Large Language Models to Detect Missed Peephole Optimizations", "comment": null, "summary": "By replacing small, suboptimal instruction sequences within programs with a\nmore efficient equivalent, peephole optimization can not only directly optimize\ncode size and performance, but also potentially enables further transformations\nin the subsequent optimization pipeline. Although peephole optimization is a\ncritical class of compiler optimizations, discovering new and effective\npeephole optimizations is challenging as the instruction sets can be extremely\ncomplex and diverse. Previous methods either do not scale well or can only\ncapture a limited subset of peephole optimizations. In this work, we leverage\nLarge Language Models (LLMs) to detect missed peephole optimizations. We\npropose Lampo, a novel automated framework that synergistically combines the\ncreative but unreliable code optimization ability of LLMs with rigorous\ncorrectness verification performed by translation validation tools, integrated\nin a feedback-driven iterative process. Through a comprehensive evaluation\nwithin LLVM ecosystems, we show that Lampo can successfully detect up to 17 out\nof 25 previously reported missed optimizations in LLVM on average, and that 22\nout of 25 can potentially be found by Lampo with different LLMs. For\ncomparison, the state-of-the-art superoptimizer for LLVM, Souper, identified 15\nof them. Moreover, within seven months of development and intermittent\nexperiments, Lampo found 26 missed peephole optimizations, 15 of which have\nbeen confirmed and 6 already fixed. These results demonstrate Lampo's strong\npotential in continuously detecting missed peephole optimizations.", "AI": {"tldr": "Lampo\u81ea\u52a8\u5316\u6846\u67b6\u5229\u7528LLM\u4e0e\u9a8c\u8bc1\u5de5\u5177\uff0c\u663e\u8457\u63d0\u5347LLVM\u7f16\u8bd1\u5668peephole\u4f18\u5316\u7684\u53d1\u73b0\u4e0e\u4fee\u590d\u80fd\u529b\uff0c\u8d85\u8d8a\u5df2\u6709\u5de5\u5177\uff0c\u8868\u73b0\u51fa\u6301\u7eed\u4f18\u5316\u548c\u53d1\u73b0\u65b0\u4f18\u5316\u7684\u6f5c\u529b\u3002", "motivation": "peephole\u4f18\u5316\u662f\u4e00\u79cd\u5173\u952e\u7684\u7f16\u8bd1\u5668\u4f18\u5316\uff0c\u80fd\u76f4\u63a5\u63d0\u5347\u4ee3\u7801\u6027\u80fd\u548c\u8282\u7701\u4ee3\u7801\u4f53\u79ef\uff0c\u4f46\u5728\u590d\u6742\u591a\u6837\u7684\u6307\u4ee4\u96c6\u4e0b\uff0c\u53d1\u73b0\u65b0\u7684\u9ad8\u6548peephole\u4f18\u5316\u975e\u5e38\u56f0\u96be\u3002\u4ee5\u5f80\u65b9\u6cd5\u5728\u89c4\u6a21\u5316\u548c\u4f18\u5316\u80fd\u529b\u65b9\u9762\u5b58\u5728\u5c40\u9650\u3002", "method": "\u63d0\u51fa\u4e86Lampo\uff0c\u4e00\u4e2a\u7ed3\u5408LLM\u521b\u9020\u6027\u4f46\u4e0d\u592a\u53ef\u9760\u7684\u4ee3\u7801\u4f18\u5316\u80fd\u529b\u4e0e\u7ffb\u8bd1\u9a8c\u8bc1\u5de5\u5177\u4e25\u8c28\u9a8c\u8bc1\u7684\u81ea\u52a8\u5316\u6846\u67b6\uff0c\u901a\u8fc7\u53cd\u9988\u9a71\u52a8\u7684\u8fed\u4ee3\u6d41\u7a0b\uff0c\u5b9e\u73b0\u5bf9peephole\u4f18\u5316\u7684\u81ea\u52a8\u68c0\u6d4b\u4e0e\u8bc4\u4f30\u3002", "result": "Lampo\u5e73\u5747\u53ef\u4ee5\u8bc6\u522bLLVM\u4e2d25\u9879\u5df2\u62a5\u9053\u9057\u6f0fpeephole\u4f18\u5316\u4e2d\u768417\u9879\uff0c\u7406\u8bba\u4e0a\u6362\u7528\u4e0d\u540cLLM\u53ef\u8fbe22\u9879\u3002\u5bf9\u6bd4\u4e4b\u4e0b\uff0cLLVM\u73b0\u6709\u6700\u5148\u8fdb\u7684Souper\u5de5\u5177\u53ea\u80fd\u8bc6\u522b15\u9879\u3002\u540c\u65f6\u57287\u4e2a\u6708\u7684\u53d1\u5c55\u4e0e\u95f4\u6b47\u8bd5\u9a8c\u4e2d\uff0cLampo\u65b0\u53d1\u73b0\u4e8626\u9879\u9057\u6f0fpeephole\u4f18\u5316\uff0c\u5176\u4e2d15\u9879\u5df2\u786e\u8ba4\uff0c6\u9879\u5df2\u4fee\u590d\u3002", "conclusion": "Lampo\u663e\u793a\u51fa\u6301\u7eed\u53d1\u73b0\u9057\u6f0fpeephole\u4f18\u5316\u7684\u5f3a\u5927\u6f5c\u529b\uff0c\u6709\u671b\u663e\u8457\u63d0\u5347\u7f16\u8bd1\u5668\u4f18\u5316\u6c34\u5e73\u3002"}}
{"id": "2508.15856", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2508.15856", "abs": "https://arxiv.org/abs/2508.15856", "authors": ["Mikol\u00e1\u0161 Janota"], "title": "Experimental Results for Vampire on the Equational Theories Project", "comment": null, "summary": "Equational Theories Project is a collaborative effort, which explores the\nvalidity of certain first-order logic implications of certain kind. The project\nhas been completed but triggered further research. This report investigates how\nmuch can be automatically proven and disproven by the automated theorem prover\nVampire. An interesting conclusion is that Vampire can prove all the considered\nimplications that hold and also is able to refute a vast majority of those that\ndo not hold.", "AI": {"tldr": "\u672c\u6587\u63a2\u8ba8\u4e86\u81ea\u52a8\u5b9a\u7406\u8bc1\u660e\u5668Vampire\u5728\u4e00\u7c7b\u7279\u5b9a\u4e00\u9636\u903b\u8f91\u8574\u542b\u5f0f\u4e0a\u7684\u8bc1\u660e\u4e0e\u53cd\u9a73\u80fd\u529b\uff0c\u53d1\u73b0\u5176\u51e0\u4e4e\u80fd\u5168\u90e8\u5224\u522b\u6b63\u786e\u4e0e\u9519\u8bef\u7684\u60c5\u5f62\uff0c\u663e\u793a\u81ea\u52a8\u63a8\u7406\u5de5\u5177\u5728\u903b\u8f91\u5206\u6790\u9886\u57df\u7684\u4ef7\u503c\u3002", "motivation": "\u672c\u6587\u627f\u63a5Equational Theories Project\u7684\u540e\u7eed\u7814\u7a76\uff0c\u65e8\u5728\u63a2\u8ba8\u5982\u4f55\u501f\u52a9\u81ea\u52a8\u5b9a\u7406\u8bc1\u660e\u5668\u81ea\u52a8\u9a8c\u8bc1\u3001\u53cd\u9a73\u67d0\u7c7b\u4e00\u9636\u903b\u8f91\u8574\u542b\u5f0f\u3002\u8be5\u9879\u76ee\u5df2\u5b8c\u6210\uff0c\u4f46\u542f\u53d1\u4e86\u8fdb\u4e00\u6b65\u7684\u81ea\u52a8\u5316\u7814\u7a76\u3002", "method": "\u4f5c\u8005\u4f7f\u7528\u4e86\u81ea\u52a8\u5b9a\u7406\u8bc1\u660e\u5668Vampire\uff0c\u5bf9\u82e5\u5e72\u7279\u5b9a\u7c7b\u578b\u7684\u4e00\u9636\u903b\u8f91\u8574\u542b\u5f0f\u8fdb\u884c\u81ea\u52a8\u8bc1\u660e\u6216\u53cd\u9a73\u3002\u901a\u8fc7\u5b9e\u9a8c\u6027\u7814\u7a76\u6bd4\u8f83\u4e86Vampire\u5bf9\u6210\u7acb\u4e0e\u4e0d\u6210\u7acb\u8574\u542b\u5f0f\u7684\u5904\u7406\u80fd\u529b\u3002", "result": "Vampire\u80fd\u591f\u81ea\u52a8\u8bc1\u660e\u6240\u6709\u6210\u7acb\u7684\u8574\u542b\u5f0f\uff0c\u5e76\u80fd\u53cd\u9a73\u5927\u591a\u6570\u4e0d\u6210\u7acb\u7684\u8574\u542b\u5f0f\uff0c\u8868\u73b0\u51fa\u5f3a\u5927\u7684\u81ea\u52a8\u9a8c\u8bc1\u4e0e\u53cd\u8bc1\u80fd\u529b\u3002", "conclusion": "\u81ea\u52a8\u5b9a\u7406\u8bc1\u660e\u5668\uff08\u5982Vampire\uff09\u5728\u5206\u6790\u8fd9\u7c7b\u4e00\u9636\u903b\u8f91\u8574\u542b\u5f0f\u65f6\u65e2\u9ad8\u6548\u53c8\u51c6\u786e\uff0c\u662f\u63a8\u8fdb\u76f8\u5173\u81ea\u52a8\u63a8\u7406\u7814\u7a76\u7684\u6709\u529b\u5de5\u5177\u3002"}}
{"id": "2508.15941", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15941", "abs": "https://arxiv.org/abs/2508.15941", "authors": ["Imen Trabelsi", "Brahim Mahmoudi", "Jean Baptiste Minani", "Naouel Moha", "Yann-Ga\u00ebl Gu\u00e9h\u00e9neuc"], "title": "A Systematic Literature Review of Machine Learning Approaches for Migrating Monolithic Systems to Microservices", "comment": null, "summary": "Scalability and maintainability challenges in monolithic systems have led to\nthe adoption of microservices, which divide systems into smaller, independent\nservices. However, migrating existing monolithic systems to microservices is a\ncomplex and resource-intensive task, which can benefit from machine learning\n(ML) to automate some of its phases. Choosing the right ML approach for\nmigration remains challenging for practitioners. Previous works studied\nseparately the objectives, artifacts, techniques, tools, and benefits and\nchallenges of migrating monolithic systems to microservices. No work has yet\ninvestigated systematically existing ML approaches for this migration to\nunderstand the \\revised{automated migration phases}, inputs used, ML techniques\napplied, evaluation processes followed, and challenges encountered. We present\na systematic literature review (SLR) that aggregates, synthesises, and\ndiscusses the approaches and results of 81 primary studies (PSs) published\nbetween 2015 and 2024. We followed the Preferred Reporting Items for Systematic\nReview and Meta-Analysis (PRISMA) statement to report our findings and answer\nour research questions (RQs). We extract and analyse data from these PSs to\nanswer our RQs. We synthesise the findings in the form of a classification that\nshows the usage of ML techniques in migrating monolithic systems to\nmicroservices. The findings reveal that some phases of the migration process,\nsuch as monitoring and service identification, are well-studied, while others,\nlike packaging microservices, remain unexplored. Additionally, the findings\nhighlight key challenges, including limited data availability, scalability and\ncomplexity constraints, insufficient tool support, and the absence of\nstandardized benchmarking, emphasizing the need for more holistic solutions.", "AI": {"tldr": "\u672c\u6587\u901a\u8fc7\u7cfb\u7edf\u6027\u6587\u732e\u56de\u987e\uff0c\u68b3\u7406\u4e862015-2024\u5e74\u95f4ML\u652f\u6301\u5355\u4f53\u7cfb\u7edf\u5230\u5fae\u670d\u52a1\u8fc1\u79fb\u7684\u4e3b\u8981\u7814\u7a76\uff0c\u603b\u7ed3\u4e86\u5404\u9636\u6bb5\u7684\u7814\u7a76\u73b0\u72b6\u4e0e\u4e0d\u8db3\uff0c\u63d0\u51fa\u672a\u6765\u53d1\u5c55\u65b9\u5411\u5e94\u89e3\u51b3\u6570\u636e\u3001\u5de5\u5177\u548c\u6807\u51c6\u5316\u7b49\u6838\u5fc3\u6311\u6218\u3002", "motivation": "\u5355\u4f53\u7cfb\u7edf\u7684\u53ef\u6269\u5c55\u6027\u548c\u53ef\u7ef4\u62a4\u6027\u96be\u9898\u4fc3\u4f7f\u5fae\u670d\u52a1\u67b6\u6784\u5e7f\u6cdb\u88ab\u91c7\u7528\u3002\u4f46\u73b0\u6709\u5355\u4f53\u7cfb\u7edf\u8fc1\u79fb\u5230\u5fae\u670d\u52a1\u8fc7\u7a0b\u590d\u6742\u3001\u8017\u65f6\uff0c\u90e8\u5206\u9636\u6bb5\u53ef\u901a\u8fc7ML\u81ea\u52a8\u5316\uff0c\u9009\u62e9\u9002\u5408\u7684ML\u65b9\u6cd5\u548c\u4e86\u89e3\u73b0\u6709\u7814\u7a76\u73b0\u72b6\u6210\u4e3a\u5b9e\u8df5\u8005\u9762\u4e34\u7684\u96be\u70b9\uff0c\u6709\u5fc5\u8981\u5bf9\u76f8\u5173\u7814\u7a76\u8fdb\u884c\u7cfb\u7edf\u68b3\u7406\u548c\u5f52\u7eb3\u3002", "method": "\u91c7\u53d6\u7cfb\u7edf\u6027\u6587\u732e\u56de\u987e\uff08SLR\uff09\u7684\u65b9\u6cd5\uff0c\u9075\u5faaPRISMA\u51c6\u5219\uff0c\u6536\u96c62015-2024\u5e74\u95f4\u53d1\u8868\u768481\u9879\u4e3b\u8981\u7814\u7a76\uff0c\u7cfb\u7edf\u6027\u63d0\u53d6\u4e0e\u5206\u6790ML\u5728\u8fc1\u79fb\u8fc7\u7a0b\u4e2d\u7684\u5e94\u7528\u3001\u9636\u6bb5\u3001\u8f93\u5165\u3001\u6280\u672f\u53ca\u8bc4\u4f30\u65b9\u5f0f\u7b49\u3002", "result": "\u7cfb\u7edf\u5f52\u7c7b\u4e86ML\u5728\u8fc1\u79fb\u8fc7\u7a0b\u4e2d\u7684\u5e94\u7528\u573a\u666f\uff0c\u53d1\u73b0\u76d1\u63a7\u548c\u670d\u52a1\u8bc6\u522b\u7b49\u9636\u6bb5\u7814\u7a76\u5145\u5206\uff0c\u800c\u5982\u5fae\u670d\u52a1\u5c01\u88c5\u7b49\u73af\u8282\u7814\u7a76\u7a7a\u767d\u3002\u4e3b\u8981\u6311\u6218\u5305\u62ec\u6570\u636e\u83b7\u53d6\u4e0d\u8db3\u3001\u590d\u6742\u6027\u4e0e\u53ef\u6269\u5c55\u6027\u9650\u5236\u3001\u5de5\u5177\u652f\u6301\u4e0d\u8db3\u3001\u7f3a\u4e4f\u6807\u51c6\u5316\u8bc4\u6d4b\u7b49\uff0c\u547c\u5401\u540e\u7eed\u7814\u7a76\u5173\u6ce8\u66f4\u5168\u9762\u7684\u89e3\u51b3\u65b9\u6848\u3002", "conclusion": "\u672c\u7efc\u8ff0\u7cfb\u7edf\u6027\u68b3\u7406\u4e86\u4f7f\u7528\u673a\u5668\u5b66\u4e60\uff08ML\uff09\u8f85\u52a9\u5355\u4f53\u7cfb\u7edf\u8fc1\u79fb\u5230\u5fae\u670d\u52a1\u7684\u76f8\u5173\u7814\u7a76\u4e0e\u65b9\u6cd5\uff0c\u5e76\u6307\u51fa\u867d\u7136\u90e8\u5206\u8fc1\u79fb\u9636\u6bb5\u6709\u826f\u597d\u7814\u7a76\u57fa\u7840\uff0c\u4f46\u4ecd\u6709\u591a\u4e2a\u5173\u952e\u73af\u8282\u548c\u6311\u6218\u9700\u8fdb\u4e00\u6b65\u7814\u7a76\u4e0e\u6539\u8fdb\u3002"}}
{"id": "2508.16305", "categories": ["cs.FL"], "pdf": "https://arxiv.org/pdf/2508.16305", "abs": "https://arxiv.org/abs/2508.16305", "authors": ["Edi Mu\u0161kardin", "Tamim Burgstaller"], "title": "Passive Model Learning of Visibly Deterministic Context-free Grammars", "comment": null, "summary": "We present PAPNI, a passive automata learning algorithm capable of learning\ndeterministic context-free grammars, which are modeled with visibly\ndeterministic pushdown automata. PAPNI is a generalization of RPNI, a passive\nautomata learning algorithm capable of learning regular languages from positive\nand negative samples. PAPNI uses RPNI as its underlying learning algorithm\nwhile assuming a priori knowledge of the visibly deterministic input alphabet,\nthat is, the alphabet decomposition into symbols that push to the stack, pop\nfrom the stack, or do not affect the stack.\n  In this paper, we show how passive learning of deterministic pushdown\nautomata can be viewed as a preprocessing step of standard RPNI\nimplementations. We evaluate the proposed approach on various deterministic\ncontext-free grammars found in the literature and compare the predictive\naccuracy of learned models with RPNI.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86PAPNI\u7b97\u6cd5\uff0c\u901a\u8fc7\u6269\u5c55RPNI\uff0c\u5c06\u5176\u5b66\u4e60\u80fd\u529b\u63d0\u5347\u81f3\u786e\u5b9a\u6027\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5\uff0c\u5e76\u5728\u5b9e\u9645\u6587\u6cd5\u5b66\u4e60\u4efb\u52a1\u4e2d\u9a8c\u8bc1\u4e86\u5176\u51c6\u786e\u6027\u3002", "motivation": "\u539f\u6709\u7684\u88ab\u52a8\u81ea\u52a8\u673a\u5b66\u4e60\u65b9\u6cd5RPNI\u53ea\u80fd\u5b66\u4e60\u6b63\u5219\u8bed\u8a00\uff0c\u96be\u4ee5\u5e94\u5bf9\u5305\u542b\u6808\u7ed3\u6784\u7684\u590d\u6742\u8bed\u8a00\u5982\u786e\u5b9a\u6027\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5\u3002\u8be5\u8bba\u6587\u52a8\u673a\u662f\u901a\u8fc7\u6269\u5c55RPNI\uff0c\u80fd\u591f\u5b66\u4e60\u66f4\u590d\u6742\u7684\u8bed\u8a00\u6a21\u578b\u3002", "method": "\u63d0\u51fa\u4e86PAPNI\u7b97\u6cd5\uff0c\u5b83\u4ee5RPNI\u4e3a\u57fa\u7840\uff0c\u901a\u8fc7\u5bf9\u8f93\u5165\u5b57\u6bcd\u8868\u8fdb\u884c\u7ed3\u6784\u5316\u9884\u5904\u7406\uff08\u77e5\u9053\u54ea\u4e9b\u7b26\u53f7\u63a8\u5165\u3001\u5f39\u51fa\u6216\u4e0d\u5f71\u54cd\u6808\uff09\uff0c\u5b9e\u73b0\u5bf9\u786e\u5b9a\u6027\u4e0b\u63a8\u81ea\u52a8\u673a\u7684\u5b66\u4e60\u3002\u5e76\u5728\u591a\u4e2a\u5df2\u77e5\u6587\u6cd5\u4e0a\u6d4b\u8bd5\u4e86\u7b97\u6cd5\u6709\u6548\u6027\u3002", "result": "PAPNI\u5728\u591a\u4e2a\u786e\u5b9a\u6027\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5\u7684\u6d4b\u8bd5\u96c6\u4e0a\u8868\u73b0\u826f\u597d\uff0c\u6240\u5b66\u4e60\u5230\u7684\u6a21\u578b\u5728\u9884\u6d4b\u51c6\u786e\u6027\u4e0a\u4f18\u4e8e\u4ec5\u4f7f\u7528RPNI\u7b97\u6cd5\u3002", "conclusion": "PAPNI\u53ef\u4ee5\u901a\u8fc7\u88ab\u52a8\u5b66\u4e60\u7b97\u6cd5\uff0c\u6709\u6548\u5b66\u4e60\u53ef\u89c1\u786e\u5b9a\u6027\u4e0b\u63a8\u81ea\u52a8\u673a\uff0c\u4ece\u800c\u80fd\u5b66\u4e60\u786e\u5b9a\u6027\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5\uff0c\u5bf9\u6bd4RPNI\u5177\u6709\u66f4\u5f3a\u8868\u8fbe\u80fd\u529b\u3002"}}
{"id": "2508.15790", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.15790", "abs": "https://arxiv.org/abs/2508.15790", "authors": ["Nan Wang", "Yongqi Fan", "yansha zhu", "ZongYu Wang", "Xuezhi Cao", "Xinyan He", "Haiyun Jiang", "Tong Ruan", "Jingping Liu"], "title": "KG-o1: Enhancing Multi-hop Question Answering in Large Language Models via Knowledge Graph Integration", "comment": null, "summary": "Large Language Models (LLMs) face challenges in knowledge-intensive reasoning\ntasks like classic multi-hop question and answering, which involves reasoning\nacross multiple facts. This difficulty arises because the chain of thoughts\n(CoTs) generated by LLMs in such tasks often deviate from real or a priori\nreasoning paths. In contrast, knowledge graphs (KGs) explicitly represent the\nlogical connections between facts through entities and relationships. This\nreflects a significant gap. Meanwhile, large reasoning models (LRMs), such as\no1, have demonstrated that long-step reasoning significantly enhances the\nperformance of LLMs. Building on these insights, we propose KG-o1, a four-stage\napproach that integrates KGs to enhance the multi-hop reasoning abilities of\nLLMs. We first filter out initial entities and generate complex subgraphs.\nSecondly, we construct logical paths for subgraphs and then use knowledge\ngraphs to build a dataset with a complex and extended brainstorming process,\nwhich trains LLMs to imitate long-term reasoning. Finally, we employ rejection\nsampling to generate a self-improving corpus for direct preference optimization\n(DPO), further refining the LLMs reasoning abilities. We conducted experiments\non two simple and two complex datasets. The results show that KG-o1 models\nexhibit superior performance across all tasks compared to existing LRMs.", "AI": {"tldr": "\u672c\u6587\u9488\u5bf9LLM\u5728\u591a\u8df3\u590d\u6742\u63a8\u7406\u4e2d\u6613\u504f\u79bb\u6b63\u786e\u63a8\u7406\u8def\u5f84\u7684\u95ee\u9898\uff0c\u63d0\u51fa\u878d\u5408\u77e5\u8bc6\u56fe\u8c31\u7684\u56db\u9636\u6bb5\u63a8\u7406\u589e\u5f3a\u65b9\u6cd5KG-o1\uff0c\u663e\u8457\u63d0\u5347\u4e86\u6a21\u578b\u63a8\u7406\u6027\u80fd\uff0c\u5728\u591a\u4e2a\u6570\u636e\u96c6\u4e0a\u8d85\u8d8a\u73b0\u6709\u5148\u8fdb\u6a21\u578b\u3002", "motivation": "\u73b0\u6709\u5927\u578b\u8bed\u8a00\u6a21\u578b\uff08LLMs\uff09\u5728\u77e5\u8bc6\u5bc6\u96c6\u578b\u3001\u591a\u8df3\u63a8\u7406\u4efb\u52a1\uff08\u5982\u590d\u6742\u95ee\u7b54\uff09\u4e2d\u8868\u73b0\u4e0d\u4f73\uff0c\u4e3b\u8981\u56e0\u4e3a\u5176\u94fe\u5f0f\u63a8\u7406\u5bb9\u6613\u504f\u79bb\u771f\u5b9e\u6216\u5148\u9a8c\u7684\u63a8\u7406\u8def\u5f84\u3002\u800c\u77e5\u8bc6\u56fe\u8c31\uff08KGs\uff09\u53ef\u4ee5\u660e\u786e\u8868\u793a\u5b9e\u4f53\u548c\u4e8b\u5b9e\u95f4\u7684\u903b\u8f91\u8fde\u63a5\uff0c\u4e14\u6709\u5927\u578b\u63a8\u7406\u6a21\u578b\uff08LRMs\uff09\u7684\u76f8\u5173\u7814\u7a76\u8868\u660e\u957f\u6b65\u63a8\u7406\u80fd\u63d0\u5347LLMs\u6027\u80fd\u3002\u4f5c\u8005\u5e0c\u671b\u7ed3\u5408KG\u4e0eLLM\u63d0\u5347\u591a\u8df3\u63a8\u7406\u80fd\u529b\u3002", "method": "\u63d0\u51faKG-o1\u65b9\u6cd5\uff0c\u91c7\u7528\u56db\u9636\u6bb5\u6d41\u7a0b\uff1a1\uff09\u7b5b\u9009\u521d\u59cb\u5b9e\u4f53\u5e76\u751f\u6210\u590d\u6742\u5b50\u56fe\uff1b2\uff09\u4e3a\u5b50\u56fe\u6784\u5efa\u903b\u8f91\u8def\u5f84\uff1b3\uff09\u5229\u7528\u77e5\u8bc6\u56fe\u8c31\u6784\u5efa\u5305\u542b\u590d\u6742\u3001\u6269\u5c55\u8111\u529b\u6fc0\u8361\u8fc7\u7a0b\u7684\u6570\u636e\u96c6\uff0c\u7528\u4e8e\u8bad\u7ec3LLM\u4eff\u6548\u957f\u671f\u63a8\u7406\uff1b4\uff09\u901a\u8fc7\u62d2\u7edd\u91c7\u6837\u751f\u6210\u81ea\u6211\u63d0\u5347\u8bed\u6599\uff0c\u7528\u4e8eDPO\u4f18\u5316\u8fdb\u4e00\u6b65\u589e\u5f3a\u6a21\u578b\u63a8\u7406\u80fd\u529b\u3002", "result": "\u5728\u4e24\u4e2a\u7b80\u5355\u548c\u4e24\u4e2a\u590d\u6742\u6570\u636e\u96c6\u4e0a\u7684\u5b9e\u9a8c\u8bc1\u660e\uff0cKG-o1\u65b9\u6cd5\u5728\u6240\u6709\u4efb\u52a1\u4e0a\u90fd\u4f18\u4e8e\u73b0\u6709\u7684\u5927\u578b\u63a8\u7406\u6a21\u578b\uff08LRMs\uff09\u3002", "conclusion": "KG\u4e0eLLM\u7ed3\u5408\u7684\u65b0\u65b9\u6cd5KG-o1\u80fd\u663e\u8457\u63d0\u5347\u591a\u8df3\u63a8\u7406\u4efb\u52a1\u4e2d\u7684\u8868\u73b0\uff0c\u76f8\u6bd4\u73b0\u6709\u65b9\u6cd5\u5177\u6709\u66f4\u5f3a\u7684\u63a8\u7406\u80fd\u529b\u548c\u6cdb\u5316\u6548\u679c\u3002"}}
{"id": "2508.16522", "categories": ["cs.PL", "cs.DC"], "pdf": "https://arxiv.org/pdf/2508.16522", "abs": "https://arxiv.org/abs/2508.16522", "authors": ["Rohan Yadav", "Joseph Guman", "Sean Treichler", "Michael Garland", "Alex Aiken", "Fredrik Kjolstad", "Michael Bauer"], "title": "On the Duality of Task and Actor Programming Models", "comment": null, "summary": "Programming models for distributed and heterogeneous machines are rapidly\ngrowing in popularity to meet the demands of modern workloads. Task and actor\nmodels are common choices that offer different trade-offs between development\nproductivity and achieved performance. Task-based models offer better\nproductivity and composition of software, whereas actor-based models routinely\ndeliver better peak performance due to lower overheads. While task-based and\nactor-based models appear to be different superficially, we demonstrate these\nprogramming models are duals of each other. Importantly, we show that this\nduality extends beyond functionality to performance, and elucidate techniques\nthat let task-based systems deliver performance competitive with actor-based\nsystems without compromising productivity. We apply these techniques to both\nRealm, an explicitly parallel task-based runtime, as well as Legion, an\nimplicitly parallel task-based runtime. We show these techniques reduce Realm's\noverheads by between 1.7-5.3x, coming within a factor of two of the overheads\nimposed by heavily optimized actor-based systems like Charm++ and MPI. We\nfurther show that our techniques enable between 1.3-5.0x improved strong\nscaling of unmodified Legion applications.", "AI": {"tldr": "\u4efb\u52a1\u4e0eactor\u6a21\u578b\u672c\u8d28\u4e0a\u662f\u5bf9\u5076\uff0c\u901a\u8fc7\u6280\u672f\u4e92\u901a\uff0c\u4efb\u52a1\u6a21\u578b\u65e2\u80fd\u9ad8\u6548\u5f00\u53d1\u53c8\u80fd\u5ab2\u7f8eactor\u6a21\u578b\u6027\u80fd\u3002", "motivation": "\u5206\u5e03\u5f0f\u548c\u5f02\u6784\u8ba1\u7b97\u673a\u5bf9\u4e8e\u73b0\u4ee3\u8d1f\u8f7d\u573a\u666f\u8d8a\u6765\u8d8a\u91cd\u8981\uff0c\u4f46\u73b0\u6709\u7684\u4efb\u52a1\u6a21\u578b\u548cactor\u6a21\u578b\u5728\u5f00\u53d1\u6548\u7387\u548c\u6027\u80fd\u4e4b\u95f4\u5b58\u5728\u6743\u8861\u3002\u56e0\u6b64\uff0c\u5982\u4f55\u517c\u5177\u9ad8\u751f\u4ea7\u529b\u4e0e\u9ad8\u6027\u80fd\u6210\u4e3a\u5173\u952e\u95ee\u9898\u3002", "method": "\u8bba\u6587\u7cfb\u7edf\u6027\u5206\u6790\u4e86\u4efb\u52a1\u6a21\u578b\u548cactor\u6a21\u578b\u7684\u672c\u8d28\u5173\u7cfb\uff0c\u63d0\u51fa\u4e24\u8005\u4e92\u4e3a\u5bf9\u5076\uff0c\u5e76\u8fdb\u4e00\u6b65\u63d0\u51fa\u5728\u4efb\u52a1\u6a21\u578b\u4e2d\u5e94\u7528\u501f\u9274\u81eaactor\u6a21\u578b\u7684\u6027\u80fd\u4f18\u5316\u6280\u672f\u3002\u6240\u63d0\u6280\u672f\u5206\u522b\u5728Realm\uff08\u663e\u5f0f\u5e76\u884c\u4efb\u52a1\u8fd0\u884c\u65f6\uff09\u548cLegion\uff08\u9690\u5f0f\u5e76\u884c\u4efb\u52a1\u8fd0\u884c\u65f6\uff09\u8fdb\u884c\u9a8c\u8bc1\u3002", "result": "\u5728Realm\u7cfb\u7edf\u4e2d\uff0c\u4f18\u5316\u6280\u672f\u5c06\u8fd0\u884c\u65f6\u5f00\u9500\u964d\u4f4e\u4e861.7-5.3\u500d\uff0c\u6027\u80fd\u63a5\u8fd1\u6bd4\u4f18\u5316\u6781\u81f4\u7684actor\u7cfb\u7edf\uff08\u5982Charm++\u548cMPI\uff09\u53ea\u9ad8\u4e00\u500d\u4ee5\u5185\uff1b\u5728Legion\u7cfb\u7edf\u4e2d\uff0c\u672a\u4fee\u6539\u5e94\u7528\u7684\u5f3a\u6269\u5c55\u6027\u63d0\u5347\u4e861.3-5.0\u500d\u3002", "conclusion": "\u4efb\u52a1\u6a21\u578b\u4e0eactor\u6a21\u578b\u5177\u6709\u7406\u8bba\u548c\u5b9e\u9645\u7684\u5bf9\u5076\u5173\u7cfb\uff0c\u901a\u8fc7\u8de8\u6a21\u578b\u7684\u6280\u672f\u8fc1\u79fb\uff0c\u53ef\u4ee5\u4f7f\u4efb\u52a1\u6a21\u578b\u5b9e\u73b0\u63a5\u8fd1actor\u6a21\u578b\u7684\u6027\u80fd\u4f18\u52bf\uff0c\u540c\u65f6\u4ecd\u4fdd\u6301\u9ad8\u751f\u4ea7\u529b\u3002"}}
{"id": "2508.15878", "categories": ["cs.LO", "cs.AI", "cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2508.15878", "abs": "https://arxiv.org/abs/2508.15878", "authors": ["Terry Jingchen Zhang", "Wenyuan Jiang", "Rongchuan Liu", "Yisong Wang", "Junran Yang", "Ning Wang", "Nicole Ni", "Yinya Huang", "Mrinmaya Sachan"], "title": "Lean Meets Theoretical Computer Science: Scalable Synthesis of Theorem Proving Challenges in Formal-Informal Pairs", "comment": "Accepted to AI4MATH@ICML2025", "summary": "Formal theorem proving (FTP) has emerged as a critical foundation for\nevaluating the reasoning capabilities of large language models, enabling\nautomated verification of mathematical proofs at scale. However, progress has\nbeen constrained by limited datasets due to the high cost of manual curation\nand the scarcity of challenging problems with verified formal-informal\ncorrespondences. We propose leveraging theoretical computer science (TCS) as a\nscalable source of rigorous proof problems, where algorithmic definitions\nenable automated generation of arbitrarily many challenging theorem-proof\npairs. We demonstrate this approach on two TCS domains: Busy Beaver problems,\nwhich involve proving bounds on Turing machine halting behavior, and Mixed\nBoolean Arithmetic problems, which combine logical and arithmetic reasoning.\nOur framework automatically synthesizes problems with parallel formal (Lean4)\nand informal (Markdown) specifications, creating a scalable pipeline for\ngenerating verified proof challenges. Evaluation on frontier models reveals\nsubstantial gaps in automated theorem proving: while DeepSeekProver-V2-671B\nachieves 57.5\\% success on Busy Beaver problems, it manages only 12\\% on Mixed\nBoolean Arithmetic problems. These results highlight the difficulty of\nlong-form proof generation even for problems that are computationally easy to\nverify, demonstrating the value of TCS domains for advancing automated\nreasoning research.", "AI": {"tldr": "\u63d0\u51fa\u7528\u7406\u8bba\u8ba1\u7b97\u673a\u79d1\u5b66\u81ea\u52a8\u751f\u6210\u9ad8\u96be\u5ea6\u5b9a\u7406\u8bc1\u660e\u6570\u636e\uff0c\u6709\u6548\u63ed\u793a\u5e76\u63a8\u52a8\u5927\u6a21\u578b\u5728\u81ea\u52a8\u63a8\u7406\u9886\u57df\u7684\u6311\u6218\u548c\u8fdb\u6b65\u3002", "motivation": "\u5f53\u524d\u5927\u6a21\u578b\u7684\u81ea\u52a8\u8bc1\u660e\u80fd\u529b\u53d7\u5230\u6570\u636e\u96c6\u6709\u9650\u7684\u5236\u7ea6\uff0c\u4e3b\u8981\u56e0\u4e3a\u4eba\u5de5\u6574\u7406\u6210\u672c\u9ad8\u3001\u96be\u4ee5\u83b7\u53d6\u5927\u91cf\u5e26\u6709\u4e25\u683c\u9a8c\u8bc1\u7684\u96be\u9898\u3002\u4f5c\u8005\u5e0c\u671b\u7a81\u7834\u8fd9\u4e00\u74f6\u9888\uff0c\u4e3a\u81ea\u52a8\u5316\u63a8\u7406\u7814\u7a76\u63d0\u4f9b\u66f4\u591a\u9ad8\u8d28\u91cf\u6570\u636e\u3002", "method": "\u4f5c\u8005\u63d0\u51fa\u5229\u7528\u7406\u8bba\u8ba1\u7b97\u673a\u79d1\u5b66\uff08TCS\uff09\u7b97\u6cd5\u5b9a\u4e49\u660e\u786e\u3001\u53ef\u81ea\u52a8\u751f\u6210\u5927\u91cf\u56f0\u96be\u5b9a\u7406-\u8bc1\u660e\u5bf9\u7684\u7279\u70b9\uff0c\u81ea\u52a8\u89c4\u6a21\u5316\u751f\u6210\u5177\u6709\u6b63\u5f0f\u548c\u975e\u6b63\u5f0f\u63cf\u8ff0\u7684\u8bc1\u660e\u6570\u636e\uff08\u5206\u522b\u7528Lean4\u548cMarkdown\u683c\u5f0f\uff09\u3002\u7814\u7a76\u6db5\u76d6\u4e86\u4e24\u4e2a\u9886\u57df\uff1a\u5fd9\u6d77\u72f8\uff08Busy Beaver\uff09\u95ee\u9898\u548c\u6df7\u5408\u5e03\u5c14\u7b97\u672f\u95ee\u9898\u3002\u6574\u4e2a\u6d41\u7a0b\u81ea\u52a8\u751f\u6210\u9898\u76ee\u3001\u53cc\u91cd\u89c4\u8303\u63cf\u8ff0\uff0c\u5e76\u7528\u4e8e\u8bc4\u4f30\u5927\u6a21\u578b\u7684\u5b9a\u7406\u8bc1\u660e\u80fd\u529b\u3002", "result": "\u5728\u6700\u65b0\u5927\u6a21\u578b\u4e0a\u8bc4\u4f30\u53d1\u73b0\uff1a\u5728\u5fd9\u6d77\u72f8\u4efb\u52a1\u4e2d\uff0cDeepSeekProver-V2-67B\u53d6\u5f97\u4e8657.5%\u7684\u6210\u529f\u7387\uff0c\u4f46\u5728\u6df7\u5408\u5e03\u5c14\u7b97\u672f\u4e0b\u6210\u529f\u7387\u4ec5\u4e3a12%\u3002", "conclusion": "TCS\u53ef\u4f5c\u4e3a\u751f\u6210\u9ad8\u96be\u5ea6\u3001\u9a8c\u8bc1\u51c6\u786e\u7684\u5b9a\u7406\u8bc1\u660e\u6570\u636e\u96c6\u7684\u53ef\u6269\u5c55\u65b9\u6848\u3002\u5373\u4f7f\u5bf9\u4e8e\u6613\u4e8e\u9a8c\u8bc1\u7684\u95ee\u9898\uff0c\u590d\u6742\u7684\u957f\u8bc1\u660e\u751f\u6210\u4ecd\u5b58\u5728\u5f88\u5927\u96be\u5ea6\uff0c\u8fd9\u51f8\u663eTCS\u9886\u57df\u5bf9\u63a8\u8fdb\u81ea\u52a8\u5316\u63a8\u7406\u7814\u7a76\u7684\u91cd\u8981\u4ef7\u503c\u3002"}}
{"id": "2508.16025", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.16025", "abs": "https://arxiv.org/abs/2508.16025", "authors": ["Saba Naqvi", "Mohammad Baqar"], "title": "Breaking Barriers in Software Testing: The Power of AI-Driven Automation", "comment": "10 Pages", "summary": "Software testing remains critical for ensuring reliability, yet traditional\napproaches are slow, costly, and prone to gaps in coverage. This paper presents\nan AI-driven framework that automates test case generation and validation using\nnatural language processing (NLP), reinforcement learning (RL), and predictive\nmodels, embedded within a policy-driven trust and fairness model. The approach\ntranslates natural language requirements into executable tests, continuously\noptimizes them through learning, and validates outcomes with real-time analysis\nwhile mitigating bias. Case studies demonstrate measurable gains in defect\ndetection, reduced testing effort, and faster release cycles, showing that\nAI-enhanced testing improves both efficiency and reliability. By addressing\nintegration and scalability challenges, the framework illustrates how AI can\nshift testing from a reactive, manual process to a proactive, adaptive system\nthat strengthens software quality in increasingly complex environments.", "AI": {"tldr": "\u8be5\u6587\u63d0\u51faAI+NLP+RL\u667a\u80fd\u81ea\u52a8\u751f\u6210\u548c\u4f18\u5316\u8f6f\u4ef6\u6d4b\u8bd5\u7528\u4f8b\u6846\u67b6\uff0c\u6709\u6548\u63d0\u5347\u7f3a\u9677\u68c0\u6d4b\u4e0e\u6d4b\u8bd5\u6548\u7387\uff0c\u5b9e\u8bc1\u663e\u793a\u53ef\u5927\u5e45\u51cf\u5c11\u4eba\u5de5\u3001\u4fc3\u8fdb\u5feb\u901f\u9ad8\u8d28\u91cf\u4ea4\u4ed8\u3002", "motivation": "\u4f20\u7edf\u8f6f\u4ef6\u6d4b\u8bd5\u6548\u7387\u4f4e\u3001\u6210\u672c\u9ad8\u4e14\u8986\u76d6\u9762\u6709\u9650\uff0c\u6025\u9700\u667a\u80fd\u5316\u3001\u81ea\u52a8\u5316\u89e3\u51b3\u65b9\u6848\u63d0\u5347\u7f3a\u9677\u68c0\u6d4b\u80fd\u529b\u3001\u51cf\u5c11\u4eba\u5de5\u548c\u63d0\u9ad8\u8f6f\u4ef6\u8d28\u91cf\u3002", "method": "\u63d0\u51fa\u4e86\u57fa\u4e8eNLP\u3001\u5f3a\u5316\u5b66\u4e60\u548c\u9884\u6d4b\u6a21\u578b\u7684AI\u81ea\u52a8\u5316\u6d4b\u8bd5\u6846\u67b6\uff0c\u5305\u62ec\u9700\u6c42\u7684\u81ea\u7136\u8bed\u8a00\u8f6c\u5316\u3001\u6d4b\u8bd5\u7528\u4f8b\u81ea\u52a8\u751f\u6210\u4e0e\u6301\u7eed\u4f18\u5316\uff0c\u5e76\u5229\u7528\u5b9e\u65f6\u5206\u6790\u9a8c\u8bc1\u7ed3\u679c\uff0c\u878d\u5408\u53ef\u4fe1\u4e0e\u516c\u5e73\u653f\u7b56\u3002\u901a\u8fc7\u6848\u4f8b\u7814\u7a76\u9a8c\u8bc1\u6548\u679c\u3002", "result": "\u8be5AI\u9a71\u52a8\u6d4b\u8bd5\u6846\u67b6\u63d0\u5347\u4e86\u7f3a\u9677\u68c0\u6d4b\u7387\uff0c\u964d\u4f4e\u4e86\u6d4b\u8bd5\u5de5\u4f5c\u91cf\uff0c\u52a0\u5feb\u4e86\u53d1\u5e03\u5468\u671f\uff0c\u5c55\u73b0\u4e86\u5728\u590d\u6742\u8f6f\u4ef6\u73af\u5883\u4e0b\u6269\u5c55\u548c\u96c6\u6210\u7684\u4f18\u52bf\u3002", "conclusion": "AI\u548c\u81ea\u52a8\u5316\u6280\u672f\u80fd\u591f\u6709\u6548\u63d0\u5347\u8f6f\u4ef6\u6d4b\u8bd5\u7684\u6548\u7387\u548c\u8d28\u91cf\uff0c\u80fd\u4ece\u4f20\u7edf\u4eba\u5de5\u6d41\u7a0b\u8f6c\u5411\u66f4\u4e3b\u52a8\u548c\u81ea\u9002\u5e94\u7684\u667a\u80fd\u6d4b\u8bd5\u4f53\u7cfb\u3002\u6846\u67b6\u7ecf\u5b9e\u8bc1\u5c55\u73b0\u4e86\u53ef\u6269\u5c55\u6027\u3001\u5b9e\u7528\u6027\u548c\u63d0\u5347\u53ef\u9760\u6027\u7684\u6f5c\u529b\u3002"}}
{"id": "2508.16384", "categories": ["cs.FL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16384", "abs": "https://arxiv.org/abs/2508.16384", "authors": ["Gabriel Dengler", "Sven Apel", "Holger Hermanns"], "title": "Automata Learning -- Expect Delays!", "comment": "Accepted at Integrated Formal Methods (iFM) 2025", "summary": "This paper studies active automata learning (AAL) in the presence of\nstochastic delays. We consider Mealy machines that have stochastic delays\nassociated with each transition and explore how the learner can efficiently\narrive at faithful estimates of those machines, the precision of which\ncrucially relies on repetitive sampling of transition delays. While it is\npossible to na\\\"ively integrate the delay sampling into AAL algorithms such as\n$L^*$, this leads to considerable oversampling near the root of the state\nspace. We address this problem by separating conceptually the learning of\nbehavior and delays such that the learner uses the information gained while\nlearning the logical behavior to arrive at efficient input sequences for\ncollecting the needed delay samples. We put emphasis on treating cases in which\nidentical input/output behaviors might stem from distinct delay\ncharacteristics. Finally, we provide empirical evidence that our method\noutperforms the na\\\"ive baseline across a wide range of benchmarks and\ninvestigate its applicability in a realistic setting by studying the join order\nin a relational database.", "AI": {"tldr": "\u8be5\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u6709\u6548\u533a\u5206\u81ea\u52a8\u673a\u884c\u4e3a\u4e0e\u5ef6\u8fdf\u91c7\u6837\u7684\u65b0\u65b9\u6cd5\uff0c\u5728\u5904\u7406\u5e26\u968f\u673a\u5ef6\u8fdf\u7684Mealy\u673a\u5b66\u4e60\u4efb\u52a1\u65f6\uff0c\u80fd\u5927\u5e45\u51cf\u5c11\u65e0\u6548\u91c7\u6837\u5e76\u63d0\u5347\u5b66\u4e60\u8d28\u91cf\uff0c\u4f18\u4e8e\u4f20\u7edfAAL\u7b97\u6cd5\u3002", "motivation": "\u4e3b\u52a8\u81ea\u52a8\u673a\u5b66\u4e60\uff08AAL\uff09\u901a\u5e38\u4fa7\u91cd\u4e8e\u786e\u5b9a\u7cfb\u7edf\u7684\u884c\u4e3a\u63cf\u8ff0\uff0c\u4f46\u5728\u5b58\u5728\u968f\u673a\u5ef6\u8fdf\u7684\u60c5\u51b5\u4e0b\uff0c\u63a8\u65ad\u6a21\u578b\u53d8\u5f97\u66f4\u52a0\u56f0\u96be\u3002\u73b0\u6709\u7b97\u6cd5\u5982$L^*$\u5728\u96c6\u6210\u5ef6\u8fdf\u91c7\u6837\u65f6\u4f1a\u5bfc\u81f4\u5728\u72b6\u6001\u7a7a\u95f4\u6839\u90e8\u7684\u8fc7\u5ea6\u62bd\u6837\uff0c\u6548\u7387\u4f4e\u4e0b\u3002\u56e0\u6b64\uff0c\u4f5c\u8005\u5e0c\u671b\u63d0\u5347AAL\u5728\u968f\u673a\u5ef6\u8fdf\u573a\u666f\u4e0b\u7684\u6548\u7387\u4e0e\u7cbe\u51c6\u6027\u3002", "method": "\u8be5\u8bba\u6587\u9488\u5bf9\u5e26\u6709\u968f\u673a\u5ef6\u8fdf\u7684Mealy\u673a\uff0c\u63d0\u51fa\u4e86\u5c06\u884c\u4e3a\u5b66\u4e60\u4e0e\u5ef6\u8fdf\u5b66\u4e60\u6982\u5ff5\u6027\u5206\u79bb\u7684\u65b9\u6cd5\u3002\u5728\u5b66\u4e60\u903b\u8f91\u884c\u4e3a\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6536\u96c6\u6709\u6548\u7684\u4fe1\u606f\uff0c\u5f15\u5bfc\u5ef6\u8fdf\u91c7\u6837\uff0c\u4ece\u800c\u8bbe\u8ba1\u9ad8\u6548\u7684\u8f93\u5165\u5e8f\u5217\u8fdb\u884c\u91c7\u6837\uff0c\u907f\u514d\u65e0\u610f\u4e49\u7684\u8fc7\u5ea6\u62bd\u6837\u3002\u8be5\u65b9\u6cd5\u5f3a\u8c03\u5373\u4f7f\u8f93\u5165/\u8f93\u51fa\u884c\u4e3a\u4e00\u81f4\uff0c\u5ef6\u8fdf\u7279\u5f81\u53ef\u80fd\u4e0d\u540c\u7684\u7279\u6b8a\u60c5\u5f62\u3002", "result": "\u5b9e\u9a8c\u8868\u660e\uff0c\u8be5\u5206\u79bb\u884c\u4e3a\u4e0e\u5ef6\u8fdf\u7684\u91c7\u6837\u65b9\u6cd5\u5728\u591a\u79cd\u57fa\u51c6\u6d4b\u8bd5\u4e0b\u5747\u4f18\u4e8e\u76f4\u63a5\u96c6\u6210\u5ef6\u8fdf\u91c7\u6837\u7684\u6734\u7d20\u57fa\u7ebf\uff0c\u5e76\u5728\u5b9e\u9645\u573a\u666f\u4e0b\uff08\u5982\u5173\u7cfb\u6570\u636e\u5e93\u8fde\u63a5\u987a\u5e8f\uff09\u5177\u5907\u826f\u597d\u9002\u7528\u6027\u3002", "conclusion": "\u5c06\u4e3b\u52a8\u81ea\u52a8\u673a\u5b66\u4e60\u4e2d\u7684\u884c\u4e3a\u4e0e\u5ef6\u8fdf\u91c7\u6837\u76f8\u5206\u79bb\uff0c\u53ef\u4ee5\u663e\u8457\u63d0\u5347\u5728\u6709\u968f\u673a\u5ef6\u8fdf\u60c5\u5f62\u4e0b\u7684\u6a21\u578b\u5b66\u4e60\u6548\u7387\u548c\u7cbe\u5ea6\uff0c\u89e3\u51b3\u4e86\u4f20\u7edfAAL\u4e2d\u56e0\u6734\u7d20\u91c7\u6837\u5e26\u6765\u7684\u6548\u7387\u74f6\u9888\u548c\u8bef\u5dee\u653e\u5927\u95ee\u9898\u3002"}}
{"id": "2508.15791", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.15791", "abs": "https://arxiv.org/abs/2508.15791", "authors": ["Xiaolei Diao", "Zhihan Zhou", "Lida Shi", "Ting Wang", "Ruihua Qi", "Hao Xu", "Daqian Shi"], "title": "InteChar: A Unified Oracle Bone Character List for Ancient Chinese Language Modeling", "comment": null, "summary": "Constructing historical language models (LMs) plays a crucial role in aiding\narchaeological provenance studies and understanding ancient cultures. However,\nexisting resources present major challenges for training effective LMs on\nhistorical texts. First, the scarcity of historical language samples renders\nunsupervised learning approaches based on large text corpora highly\ninefficient, hindering effective pre-training. Moreover, due to the\nconsiderable temporal gap and complex evolution of ancient scripts, the absence\nof comprehensive character encoding schemes limits the digitization and\ncomputational processing of ancient texts, particularly in early Chinese\nwriting. To address these challenges, we introduce InteChar, a unified and\nextensible character list that integrates unencoded oracle bone characters with\ntraditional and modern Chinese. InteChar enables consistent digitization and\nrepresentation of historical texts, providing a foundation for robust modeling\nof ancient scripts. To evaluate the effectiveness of InteChar, we construct the\nOracle Corpus Set (OracleCS), an ancient Chinese corpus that combines\nexpert-annotated samples with LLM-assisted data augmentation, centered on\nChinese oracle bone inscriptions. Extensive experiments show that models\ntrained with InteChar on OracleCS achieve substantial improvements across\nvarious historical language understanding tasks, confirming the effectiveness\nof our approach and establishing a solid foundation for future research in\nancient Chinese NLP.", "AI": {"tldr": "\u672c\u7814\u7a76\u63d0\u51fa\u4e86InteChar\u7edf\u4e00\u6c49\u5b57\u7f16\u7801\u65b9\u6848\uff0c\u5e76\u6784\u5efa\u4e86\u7532\u9aa8\u6587\u8bed\u6599\u5e93OracleCS\u3002\u5b9e\u9a8c\u8868\u660e\uff0c\u57fa\u4e8e\u8be5\u65b9\u6848\u8bad\u7ec3\u7684\u6a21\u578b\u5728\u53e4\u6c49\u8bed\u7406\u89e3\u4efb\u52a1\u4e0a\u6709\u660e\u663e\u63d0\u5347\uff0c\u4e3a\u53e4\u6c49\u8bedNLP\u7814\u7a76\u5f00\u8f9f\u4e86\u65b0\u65b9\u5411\u3002", "motivation": "\u73b0\u6709\u6784\u5efa\u5386\u53f2\u8bed\u8a00\u6a21\u578b\u9762\u4e34\u4e24\u5927\u6311\u6218\uff1a\u4e00\u662f\u5386\u53f2\u6587\u672c\u6837\u672c\u7a00\u7f3a\u5bfc\u81f4\u5927\u89c4\u6a21\u65e0\u76d1\u7763\u9884\u8bad\u7ec3\u6548\u679c\u5dee\uff1b\u4e8c\u662f\u53e4\u6587\u5b57\u7f16\u7801\u4e0d\u8db3\uff0c\u5f71\u54cd\u6570\u5b57\u5316\u5904\u7406\uff0c\u5c24\u5176\u4ee5\u65e9\u671f\u6c49\u5b57\u4e3a\u751a\u3002", "method": "\u63d0\u51faInteChar\uff0c\u4e00\u4e2a\u7edf\u4e00\u4e14\u53ef\u6269\u5c55\u7684\u6c49\u5b57\u5217\u8868\uff0c\u5c06\u672a\u7f16\u7801\u7684\u7532\u9aa8\u6587\u5b57\u7b26\u4e0e\u4f20\u7edf\u3001\u73b0\u4ee3\u6c49\u5b57\u878d\u5408\uff0c\u5b9e\u73b0\u5386\u53f2\u6587\u672c\u7684\u7edf\u4e00\u6570\u5b57\u5316\u4e0e\u8868\u793a\u3002\u5e76\u6784\u5efaOracle Corpus Set\uff08OracleCS\uff09\uff0c\u7ed3\u5408\u4e13\u5bb6\u6807\u6ce8\u4e0e\u5927\u6a21\u578b\u8f85\u52a9\u6269\u589e\uff0c\u751f\u6210\u53e4\u6c49\u8bed\u8bed\u6599\u5e93\u7528\u4e8e\u5b9e\u9a8c\u3002", "result": "\u4f7f\u7528InteChar\u548cOracleCS\u8bad\u7ec3\u7684\u6a21\u578b\u5728\u591a\u9879\u5386\u53f2\u8bed\u8a00\u7406\u89e3\u4efb\u52a1\u4e0a\u8868\u73b0\u663e\u8457\u63d0\u5347\u3002", "conclusion": "InteChar\u548cOracleCS\u4e3a\u53e4\u6c49\u8bed\u81ea\u7136\u8bed\u8a00\u5904\u7406\u5960\u5b9a\u4e86\u575a\u5b9e\u57fa\u7840\uff0c\u6709\u6548\u63d0\u5347\u4e86\u5386\u53f2\u6587\u672c\u5efa\u6a21\u80fd\u529b\u3002"}}
{"id": "2508.16517", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2508.16517", "abs": "https://arxiv.org/abs/2508.16517", "authors": ["Bingkun Yao", "Ning Wang", "Xiangfeng Liu", "Yuxin Du", "Yuchen Hu", "Hong Gao", "Zhe Jiang", "Nan Guan"], "title": "ARSP: Automated Repair of Verilog Designs via Semantic Partitioning", "comment": null, "summary": "Debugging functional Verilog bugs consumes a significant portion of front-end\ndesign time. While Large Language Models (LLMs) have demonstrated great\npotential in mitigating this effort, existing LLM-based automated debugging\nmethods underperform on industrial-scale modules. A major reason for this is\nbug signal dilution in long contexts, where a few bug-relevant tokens are\noverwhelmed by hundreds of unrelated lines, diffusing the model's attention. To\naddress this issue, we introduce ARSP, a two-stage system that mitigates\ndilution via semantics-guided fragmentation. A Partition LLM splits a module\ninto semantically tight fragments; a Repair LLM patches each fragment; edits\nare merged without altering unrelated logic. A synthetic data framework\ngenerates fragment-level training pairs spanning bug types, design styles, and\nscales to supervise both models. Experiments show that ARSP achieves 77.92%\npass@1 and 83.88% pass@5, outperforming mainstream commercial LLMs including\nClaude-3.7 and SOTA automated Verilog debugging tools Strider and MEIC. Also,\nsemantic partitioning improves pass@1 by 11.6% and pass@5 by 10.2% over\nwhole-module debugging, validating the effectiveness of fragment-level scope\nreduction in LLM-based Verilog debugging.", "AI": {"tldr": "\u6587\u7ae0\u63d0\u51fa\u4e86ARSP\uff0c\u4e00\u79cd\u901a\u8fc7\u8bed\u4e49\u5206\u5272\u548c\u4e13\u7528\u4fee\u590d\u6a21\u578b\u63d0\u5347Verilog\u81ea\u52a8\u5316\u8c03\u8bd5\u6027\u80fd\u7684\u65b0\u7cfb\u7edf\u3002\u4e0e\u4e3b\u6d41\u5de5\u5177\u548c\u6a21\u578b\u76f8\u6bd4\uff0c\u5728\u5de5\u4e1a\u7ea7\u6a21\u5757\u4e0a\u51c6\u786e\u7387\u6709\u660e\u663e\u63d0\u5347\uff0c\u6709\u6548\u89e3\u51b3\u4e86\u957f\u4e0a\u4e0b\u6587\u4fe1\u53f7\u7a00\u91ca\u95ee\u9898\u3002", "motivation": "\u73b0\u6709\u7684\u57fa\u4e8e\u5927\u6a21\u578b\u7684\u81ea\u52a8\u5316\u8c03\u8bd5\u65b9\u6cd5\uff0c\u5728\u5de5\u4e1a\u7ea7Verilog\u6a21\u5757\u4e0a\u8868\u73b0\u4e0d\u4f73\uff0c\u4e3b\u8981\u539f\u56e0\u662f\u7531\u4e8e\u957f\u4e0a\u4e0b\u6587\u5bfc\u81f4\u7684bug\u4fe1\u53f7\u7a00\u91ca\uff0c\u5373\u4e0ebug\u76f8\u5173\u7684\u8bed\u53e5\u88ab\u5927\u91cf\u65e0\u5173\u4ee3\u7801\u6df9\u6ca1\uff0c\u4ece\u800c\u5f71\u54cd\u6a21\u578b\u7684\u805a\u7126\u4e0e\u4fee\u590d\u80fd\u529b\u3002", "method": "\u63d0\u51fa\u4e86ARSP\u7cfb\u7edf\uff0c\u91c7\u7528\u4e24\u9636\u6bb5\u7b56\u7565\u3002\u9996\u5148\u901a\u8fc7Partition LLM\u5c06\u6a21\u5757\u5206\u5272\u4e3a\u8bed\u4e49\u7d27\u5bc6\u7684\u788e\u7247\uff0c\u968f\u540e\u901a\u8fc7Repair LLM\u5bf9\u6bcf\u4e2a\u788e\u7247\u72ec\u7acb\u8fdb\u884c\u4fee\u590d\uff0c\u6700\u7ec8\u5c06\u4fee\u6539\u5408\u5e76\uff0c\u4ece\u800c\u907f\u514d\u5f71\u54cd\u65e0\u5173\u903b\u8f91\u3002\u7cfb\u7edf\u8fd8\u6784\u5efa\u4e86\u5408\u6210\u6570\u636e\u6846\u67b6\uff0c\u751f\u6210\u5305\u62ec\u4e0d\u540cbug\u7c7b\u578b\u3001\u8bbe\u8ba1\u98ce\u683c\u548c\u89c4\u6a21\u7684\u788e\u7247\u7ea7\u8bad\u7ec3\u5bf9\uff0c\u4ee5\u76d1\u7763\u6a21\u578b\u8bad\u7ec3\u3002", "result": "\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0cARSP\u5728pass@1\u4e0a\u8fbe\u523077.92%\uff0cpass@5\u4e3a83.88%\uff0c\u4f18\u4e8e\u4e3b\u6d41\u5546\u7528\u5927\u6a21\u578b\uff08\u5982Claude-3.7\uff09\u53ca\u9876\u7ea7\u81ea\u52a8Verilog\u8c03\u8bd5\u5de5\u5177\uff08Strider\u548cMEIC\uff09\u3002\u8bed\u4e49\u5206\u5272\u7b56\u7565\u76f8\u6bd4\u6574\u4f53\u6a21\u5757\u8c03\u8bd5\uff0c\u5206\u522b\u63d0\u5347\u4e86pass@1\u548cpass@5 11.6%\u548c10.2%\u3002", "conclusion": "\u57fa\u4e8e\u7247\u6bb5\u7ea7\u8bed\u4e49\u5206\u5272\u7684\u8c03\u8bd5\u7cfb\u7edf\uff0c\u53ef\u4ee5\u6709\u6548\u7f13\u89e3\u957f\u4e0a\u4e0b\u6587\u4e2d\u7684bug\u4fe1\u53f7\u7a00\u91ca\u95ee\u9898\uff0c\u5927\u5e45\u63d0\u5347\u4e86\u5de5\u4e1a\u7ea7Verilog\u6a21\u5757\u8c03\u8bd5\u7684\u81ea\u52a8\u5316\u51c6\u786e\u7387\u3002ARSP\u5728\u5de5\u4e1a\u573a\u666f\u4e0b\u4f18\u4e8e\u4e3b\u6d41\u5de5\u5177\u4e0e\u6a21\u578b\u3002"}}
{"id": "2508.16146", "categories": ["cs.LO", "cs.DB"], "pdf": "https://arxiv.org/pdf/2508.16146", "abs": "https://arxiv.org/abs/2508.16146", "authors": ["Nicolas Fr\u00f6hlich", "Phokion G. Kolaitis", "Arne Meier"], "title": "Disjunctions of Two Dependence Atoms", "comment": null, "summary": "Dependence logic is a formalism that augments the syntax of first-order logic\nwith dependence atoms asserting that the value of a variable is determined by\nthe values of some other variables, i.e., dependence atoms express functional\ndependencies in relational databases. On finite structures, dependence logic\ncaptures NP, hence there are sentences of dependence logic whose model-checking\nproblem is NP-complete. In fact, it is known that there are disjunctions of\nthree dependence atoms whose model-checking problem is NP-complete. Motivated\nfrom considerations in database theory, we study the model-checking problem for\ndisjunctions of two unary dependence atoms and establish a trichotomy theorem,\nnamely, for every such formula, one of the following is true for the\nmodel-checking problem: (i) it is NL-complete; (ii) it is LOGSPACE-complete;\n(iii) it is first-order definable (hence, in AC[0]). Furthermore, we classify\nthe complexity of the model-checking problem for disjunctions of two arbitrary\ndependence atoms, and also characterize when such a disjunction is coherent,\ni.e., when it satisfies a certain small-model property. Along the way, we\nidentify a new class of 2CNF-formulas whose satisfiability problem is\nLOGSPACE-complete.", "AI": {"tldr": "\u672c\u6587\u7cfb\u7edf\u5206\u6790\u4e86\u4e24\u4e2a\u4f9d\u8d56\u539f\u5b50\u6790\u53d6\u7684\u6a21\u578b\u68c0\u6d4b\u590d\u6742\u5ea6\uff0c\u63d0\u51fa\u4e09\u5206\u6cd5\uff08NL\u3001LOGSPACE\u6216AC[0]\uff09\uff0c\u5e76\u523b\u753b\u4e86\u66f4\u4e00\u822c\u60c5\u51b5\u7684\u590d\u6742\u5ea6\uff0c\u62d3\u5c55\u4e86\u4f9d\u8d56\u903b\u8f91\u5728\u6570\u636e\u5e93\u7406\u8bba\u4e2d\u7684\u7406\u8bba\u57fa\u7840\u3002", "motivation": "\u4f9d\u8d56\u903b\u8f91\u53ef\u4ee5\u8868\u8fbe\u5173\u7cfb\u6570\u636e\u5e93\u4e2d\u7684\u51fd\u6570\u4f9d\u8d56\u3002\u867d\u7136\u4e09\u4e2a\u4f9d\u8d56\u539f\u5b50\u7684\u6790\u53d6\u5df2\u77e5\u6a21\u578b\u68c0\u6d4b\u662fNP-\u5b8c\u5168\u7684\uff0c\u4f46\u5c1a\u672a\u7cfb\u7edf\u7814\u7a76\u4e24\u4e2a\u4e00\u5143\u4f9d\u8d56\u539f\u5b50\u7684\u60c5\u51b5\uff0c\u8fd9\u4e0e\u6570\u636e\u5e93\u7406\u8bba\u4e2d\u7684\u5b9e\u9645\u95ee\u9898\u5bc6\u5207\u76f8\u5173\u3002\u4f5c\u8005\u5e0c\u671b\u63ed\u793a\u8fd9\u7c7b\u516c\u5f0f\u6a21\u578b\u68c0\u6d4b\u95ee\u9898\u7684\u590d\u6742\u5ea6\u8fb9\u754c\u3002", "method": "\u4f5c\u8005\u5bf9\u5305\u542b\u4e24\u4e2a\u4e00\u5143\u4f9d\u8d56\u539f\u5b50\u7684\u516c\u5f0f\u7684\u6a21\u578b\u68c0\u6d4b\u95ee\u9898\u8fdb\u884c\u4e86\u7cfb\u7edf\u590d\u6742\u5ea6\u5206\u7c7b\uff0c\u5efa\u7acb\u4e09\u5206\u6cd5\u5b9a\u7406\uff0c\u5e76\u8fdb\u4e00\u6b65\u5206\u6790\u4efb\u610f\u4e24\u4e2a\u4f9d\u8d56\u539f\u5b50\u516c\u5f0f\u7684\u60c5\u5f62\u3002\u540c\u65f6\uff0c\u4f5c\u8005\u8fd8\u7814\u7a76\u4e86\u8fd9\u4e9b\u6790\u53d6\u5f0f\u7684\u76f8\u5e72\u6027\uff08\u6ee1\u8db3\u5c0f\u6a21\u578b\u6027\u8d28\u7684\u6761\u4ef6\uff09\uff0c\u5e76\u5728\u8fc7\u7a0b\u4e2d\u8bc6\u522b\u51fa\u4e00\u4e2aLOGSPACE-\u5b8c\u5168\u7684\u65b0\u578b2CNF\u516c\u5f0f\u7c7b\u3002", "result": "\u5bf9\u4e24\u4e2a\u4e00\u5143\u4f9d\u8d56\u539f\u5b50\u7684\u6790\u53d6\u6a21\u578b\u68c0\u6d4b\u95ee\u9898\uff0c\u4f5c\u8005\u8bc1\u660e\uff1a\u5176\u590d\u6742\u5ea6\u4e25\u683c\u843d\u5728\u4e09\u7c7b\u4e4b\u4e00\u2014\u2014NL-\u5b8c\u5168\u3001LOGSPACE-\u5b8c\u5168\u6216\u4e00\u9636\u53ef\u5b9a\u4e49\uff08AC[0]\u5185\uff09\u3002\u540c\u65f6\u7ed9\u51fa\u4e86\u4e24\u4e2a\u4efb\u610f\u4f9d\u8d56\u539f\u5b50\u7684\u590d\u6742\u5ea6\u786e\u5b9a\u548c\u76f8\u5e72\u6027\u523b\u753b\uff0c\u4ee5\u53caLOGSPACE-\u5b8c\u5168\u76842CNF-\u516c\u5f0f\u7c7b\u3002", "conclusion": "\u8be5\u5de5\u4f5c\u63ed\u793a\u4e86\u4f9d\u8d56\u903b\u8f91\u4e2d\u7279\u5b9a\u6790\u53d6\u516c\u5f0f\u6a21\u578b\u68c0\u6d4b\u95ee\u9898\u7684\u7ec6\u81f4\u590d\u6742\u5ea6\u5206\u5c42\uff0c\u4e3a\u7406\u89e3\u4f9d\u8d56\u539f\u5b50\u8868\u8fbe\u5f0f\u7684\u8ba1\u7b97\u5c5e\u6027\u548c\u5176\u5728\u6570\u636e\u5e93\u7406\u8bba\u4e2d\u7684\u5e94\u7528\u6253\u4e0b\u57fa\u7840\u3002\u4e5f\u4e3a\u5224\u65ad\u590d\u6742\u516c\u5f0f\u54ea\u4e9b\u60c5\u5f62\u6613\u4e8e\u8ba1\u7b97\u7ed9\u51fa\u4e86\u660e\u786e\u6807\u51c6\u3002"}}
{"id": "2508.16053", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16053", "abs": "https://arxiv.org/abs/2508.16053", "authors": ["Shadikur Rahman", "Umme Ayman Koana", "Hasibul Karim Shanto", "Mahmuda Akter", "Chitra Roy", "Aras M. Ismael"], "title": "Measuring the effectiveness of code review comments in GitHub repositories: A machine learning approach", "comment": null, "summary": "This paper illustrates an empirical study of the working efficiency of\nmachine learning techniques in classifying code review text by semantic\nmeaning. The code review comments from the source control repository in GitHub\nwere extracted for development activity from the existing year for three\nopen-source projects. Apart from that, programmers need to be aware of their\ncode and point out their errors. In that case, it is a must to classify the\nsentiment polarity of the code review comments to avoid an error. We manually\nlabelled 13557 code review comments generated by three open source projects in\nGitHub during the existing year. In order to recognize the sentiment polarity\n(or sentiment orientation) of code reviews, we use seven machine learning\nalgorithms and compare those results to find the better ones. Among those\nLinear Support Vector Classifier(SVC) classifier technique achieves higher\naccuracy than others. This study will help programmers to make any solution\nbased on code reviews by avoiding misconceptions.", "AI": {"tldr": "\u672c\u6587\u5206\u6790\u4e86\u4e03\u79cd\u673a\u5668\u5b66\u4e60\u65b9\u6cd5\u5728\u4ee3\u7801\u5ba1\u67e5\u6587\u672c\u8bed\u4e49\u5206\u7c7b\u4e2d\u7684\u6548\u679c\uff0c\u53d1\u73b0\u7ebf\u6027SVC\u8868\u73b0\u6700\u597d\uff0c\u80fd\u6709\u6548\u5e2e\u52a9\u7a0b\u5e8f\u5458\u7406\u89e3\u8bc4\u8bba\u3001\u51cf\u5c11\u9519\u8bef\u3002", "motivation": "\u968f\u7740\u4ee3\u7801\u5ba1\u67e5\u5728\u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u7684\u666e\u53ca\uff0c\u5982\u4f55\u9ad8\u6548\u3001\u51c6\u786e\u5730\u7406\u89e3\u548c\u5206\u7c7b\u4ee3\u7801\u5ba1\u67e5\u8bc4\u8bba\u4e2d\u7684\u8bed\u4e49\u4e0e\u60c5\u611f\u503e\u5411\u6210\u4e3a\u4e00\u4e2a\u91cd\u8981\u95ee\u9898\u3002\u8fd9\u4e0d\u4ec5\u53ef\u4ee5\u63d0\u5347\u4ee3\u7801\u8d28\u91cf\uff0c\u8fd8\u80fd\u5e2e\u52a9\u7a0b\u5e8f\u5458\u8bc6\u522b\u548c\u907f\u514d\u9519\u8bef\u3002", "method": "\u672c\u7814\u7a76\u4eceGitHub\u7684\u4e09\u4e2a\u5f00\u6e90\u9879\u76ee\u4e2d\u63d0\u53d6\u4e86\u5f53\u5e74\u5f00\u53d1\u6d3b\u52a8\u7684\u4ee3\u7801\u5ba1\u67e5\u8bc4\u8bba\uff0c\u5e76\u4e14\u5bf913557\u6761\u8bc4\u8bba\u8fdb\u884c\u4e86\u4eba\u5de5\u6807\u6ce8\u3002\u63a5\u7740\uff0c\u5e94\u7528\u4e86\u4e03\u79cd\u673a\u5668\u5b66\u4e60\u7b97\u6cd5\u5bf9\u8bc4\u8bba\u7684\u60c5\u611f\u503e\u5411\u8fdb\u884c\u5206\u7c7b\uff0c\u5e76\u5bf9\u8fd9\u4e9b\u7b97\u6cd5\u7684\u8868\u73b0\u8fdb\u884c\u4e86\u6bd4\u8f83\u3002", "result": "\u5728\u4e03\u79cd\u673a\u5668\u5b66\u4e60\u7b97\u6cd5\u4e2d\uff0c\u7ebf\u6027\u652f\u6301\u5411\u91cf\u5206\u7c7b\u5668(SVC)\u5728\u60c5\u611f\u503e\u5411\u5206\u7c7b\u4efb\u52a1\u4e2d\u53d6\u5f97\u4e86\u6700\u9ad8\u7684\u51c6\u786e\u7387\u3002", "conclusion": "\u901a\u8fc7\u5bf9\u4e0d\u540c\u673a\u5668\u5b66\u4e60\u65b9\u6cd5\u7684\u6bd4\u8f83\uff0c\u7ebf\u6027SVC\u6700\u9002\u5408\u7528\u4e8e\u4ee3\u7801\u5ba1\u67e5\u8bc4\u8bba\u7684\u60c5\u611f\u5206\u7c7b\uff0c\u8fd9\u6709\u52a9\u4e8e\u7a0b\u5e8f\u5458\u6839\u636e\u8bc4\u8bba\u505a\u51fa\u66f4\u5408\u7406\u7684\u5224\u65ad\uff0c\u907f\u514d\u8bef\u89e3\u548c\u9519\u8bef\u3002"}}
{"id": "2508.15792", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2508.15792", "abs": "https://arxiv.org/abs/2508.15792", "authors": ["Samyak S. Sanghvi"], "title": "Bhav-Net: Knowledge Transfer for Cross-Lingual Antonym vs Synonym Distinction via Dual-Space Graph Transformers", "comment": null, "summary": "Antonym vs synonym distinction across multiple languages presents unique\ncomputational challenges due to the paradoxical nature of antonymous\nrelationships words that share semantic domains while expressing opposite\nmeanings. This work introduces Bhav-Net, a novel dual-space architecture that\nenables effective knowledge transfer from complex multilingual models to\nsimpler, language-specific architectures while maintaining robust cross-lingual\nantonym--synonym distinction capabilities. Our approach combines\nlanguage-specific BERT encoders with graph transformer networks, creating\ndistinct semantic projections where synonymous pairs cluster in one space while\nantonymous pairs exhibit high similarity in a complementary space. Through\ncomprehensive evaluation across eight languages (English, German, French,\nSpanish, Italian, Portuguese, Dutch, and Russian), we demonstrate that semantic\nrelationship modeling transfers effectively across languages. The dual-encoder\ndesign achieves competitive performance against state-of-the-art baselines\nwhile providing interpretable semantic representations and effective\ncross-lingual generalization.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u9896\u7684\u53cc\u7a7a\u95f4\u67b6\u6784Bhav-Net\uff0c\u7ed3\u5408BERT\u4e0e\u56fe\u795e\u7ecf\u7f51\u7edc\uff0c\u5b9e\u73b0\u4e86\u591a\u8bed\u8a00\u4e0b\u53cd\u4e49\u8bcd\u4e0e\u540c\u4e49\u8bcd\u7684\u9ad8\u6548\u533a\u5206\uff0c\u5e76\u5177\u5907\u5f3a\u6cdb\u5316\u80fd\u529b\u3002", "motivation": "\u8de8\u8bed\u8a00\u7684\u53cd\u4e49\u8bcd\u4e0e\u540c\u4e49\u8bcd\u533a\u5206\u5177\u6709\u590d\u6742\u7684\u8ba1\u7b97\u6311\u6218\uff0c\u539f\u56e0\u5728\u4e8e\u53cd\u4e49\u8bcd\u901a\u5e38\u5904\u4e8e\u76f8\u4f3c\u8bed\u4e49\u57df\u4f46\u610f\u4e49\u76f8\u53cd\u3002\u672c\u7814\u7a76\u65e8\u5728\u89e3\u51b3\u8fd9\u4e00\u5efa\u6a21\u96be\u9898\uff0c\u5b9e\u73b0\u591a\u8bed\u8a00\u6761\u4ef6\u4e0b\u53cd\u4e49\u8bcd\u4e0e\u540c\u4e49\u8bcd\u7684\u6709\u6548\u533a\u5206\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u540d\u4e3aBhav-Net\u7684\u53cc\u7a7a\u95f4\u67b6\u6784\uff1a\u7ed3\u5408\u8bed\u8a00\u7279\u5b9a\u7684BERT\u7f16\u7801\u5668\u4e0e\u56fe\u795e\u7ecf\u7f51\u7edc\uff0c\u5c06\u8bed\u4e49\u5173\u7cfb\u6620\u5c04\u5230\u4e24\u4e2a\u4e0d\u540c\u7684\u7a7a\u95f4\uff0c\u4f7f\u540c\u4e49\u8bcd\u805a\u7c7b\u5728\u4e00\u4e2a\u7a7a\u95f4\uff0c\u53cd\u4e49\u8bcd\u5728\u53e6\u5916\u4e00\u4e2a\u7a7a\u95f4\u8868\u73b0\u51fa\u9ad8\u76f8\u4f3c\u6027\uff0c\u5e76\u5b9e\u73b0\u77e5\u8bc6\u4ece\u591a\u8bed\u8a00\u590d\u6742\u6a21\u578b\u5230\u5355\u4e00\u8bed\u8a00\u6a21\u578b\u7684\u8fc1\u79fb\u3002", "result": "\u5728\u5305\u542b\u82f1\u8bed\u3001\u5fb7\u8bed\u3001\u6cd5\u8bed\u3001\u897f\u73ed\u7259\u8bed\u3001\u610f\u5927\u5229\u8bed\u3001\u8461\u8404\u7259\u8bed\u3001\u8377\u5170\u8bed\u548c\u4fc4\u8bed\u7684\u516b\u79cd\u8bed\u8a00\u4e0a\u8fdb\u884c\u4e86\u8bc4\u6d4b\uff0cBhav-Net\u5c55\u73b0\u4e86\u8de8\u8bed\u8a00\u7684\u6709\u6548\u8bed\u4e49\u5173\u7cfb\u5efa\u6a21\u80fd\u529b\u3002\u8be5\u65b9\u6cd5\u5728\u8868\u73b0\u3001\u89e3\u91ca\u6027\u4e0e\u8de8\u8bed\u8a00\u6cdb\u5316\u80fd\u529b\u4e0a\u5747\u4e0e\u5f53\u524d\u6700\u5148\u8fdb\u7684\u57fa\u7ebf\u65b9\u6cd5\u7ade\u4e89\u3002", "conclusion": "Bhav-Net\u80fd\u591f\u9ad8\u6548\u5730\u5bf9\u591a\u8bed\u8a00\u73af\u5883\u4e0b\u7684\u53cd\u4e49\u8bcd\u548c\u540c\u4e49\u8bcd\u8fdb\u884c\u533a\u5206\uff0c\u540c\u65f6\u63d0\u4f9b\u4e86\u53ef\u89e3\u91ca\u6027\u7684\u8bed\u4e49\u8868\u8fbe\u548c\u826f\u597d\u7684\u8de8\u8bed\u8a00\u8fc1\u79fb\u80fd\u529b\u3002"}}
{"id": "2508.16242", "categories": ["cs.LO", "cs.AI", "68T27", "I.2.3"], "pdf": "https://arxiv.org/pdf/2508.16242", "abs": "https://arxiv.org/abs/2508.16242", "authors": ["Alexander Steen"], "title": "A Reduction of Input/Output Logics to SAT", "comment": "32 pages", "summary": "Deontic logics are formalisms for reasoning over norms, obligations,\npermissions and prohibitions. Input/Output (I/O) Logics are a particular family\nof so-called norm-based deontic logics that formalize conditional norms outside\nof the underlying object logic language, where conditional norms do not carry a\ntruth-value themselves. In this paper, an automation approach for I/O logics is\npresented that makes use of suitable reductions to (sequences of) propositional\nsatisfiability problems. A prototypical implementation, named rio (reasoner for\ninput/output logics), of the proposed procedures is presented and applied to\nillustrative examples.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u5c06I/O\u89c4\u8303\u903b\u8f91\u81ea\u52a8\u5316\u7684\u65b9\u6cd5\uff0c\u901a\u8fc7\u547d\u9898\u53ef\u6ee1\u8db3\u6027\u5f52\u7ea6\u5e76\u5f00\u53d1\u4e86\u539f\u578b\u63a8\u7406\u7cfb\u7edfrio\uff0c\u7ecf\u5b9e\u8bc1\u793a\u4f8b\u5c55\u793a\u4e86\u53ef\u884c\u6027\u3002", "motivation": "\u7814\u7a76\u89c4\u8303\u3001\u4e49\u52a1\u3001\u8bb8\u53ef\u548c\u7981\u6b62\u7b49\u8303\u7574\u7684\u903b\u8f91\u5f62\u5f0f\u5316\u95ee\u9898\uff0c\u5c24\u5176\u5173\u6ce8\u6761\u4ef6\u89c4\u8303\u7684\u5904\u7406\u65b9\u5f0f\u3002I/O\u903b\u8f91\u4f5c\u4e3a\u4e00\u79cd\u7279\u6b8a\u7684\u89c4\u8303\u578b\u903b\u8f91\uff0c\u5c06\u6761\u4ef6\u89c4\u8303\u72ec\u7acb\u4e8e\u5bf9\u8c61\u903b\u8f91\u8bed\u8a00\uff0c\u540c\u65f6\u63a2\u8ba8\u5176\u81ea\u52a8\u5316\u63a8\u7406\u7684\u53ef\u884c\u6027\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u5c06I/O\u903b\u8f91\u81ea\u52a8\u5316\u7684\u65b9\u6848\uff0c\u5373\u901a\u8fc7\u5408\u9002\u7684\u7b80\u5316\u65b9\u6cd5\u5c06\u5176\u5f52\u7ea6\u4e3a\uff08\u591a\u6b65\uff09\u547d\u9898\u53ef\u6ee1\u8db3\u6027\u95ee\u9898\uff0c\u5e76\u636e\u6b64\u5f00\u53d1\u4e86\u539f\u578b\u5de5\u5177rio\u8fdb\u884c\u5b9e\u73b0\u3002", "result": "\u63d0\u51fa\u7684\u81ea\u52a8\u5316\u65b9\u6cd5\u80fd\u591f\u6709\u6548\u5b9e\u73b0I/O\u903b\u8f91\u7684\u63a8\u7406\uff0c\u5e76\u4e14\u901a\u8fc7\u5b9e\u7528\u793a\u4f8b\u9a8c\u8bc1\u4e86\u65b9\u6cd5\u548c\u5de5\u5177\u7684\u53ef\u884c\u6027\u3002", "conclusion": "I/O\u903b\u8f91\u7684\u81ea\u52a8\u5316\u5904\u7406\u53ef\u4ee5\u901a\u8fc7\u5f52\u7ea6\u547d\u9898\u53ef\u6ee1\u8db3\u6027\u95ee\u9898\u5b9e\u73b0\uff0c\u5e76\u901a\u8fc7\u539f\u578b\u7cfb\u7edfrio\u5c55\u793a\u4e86\u5176\u5b9e\u7528\u6027\u3002\u8be5\u65b9\u6cd5\u4e3a\u89c4\u8303\u63a8\u7406\u9886\u57df\u63d0\u4f9b\u4e86\u65b0\u7684\u6280\u672f\u8def\u7ebf\u548c\u5de5\u5177\u652f\u6301\u3002"}}

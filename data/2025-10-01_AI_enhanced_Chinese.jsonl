{"id": "2509.26616", "categories": ["cs.SE", "cs.FL", "cs.PL", "68Q42, 68Q45 (Primary), 68T50 (Secondary)", "D.2.5; F.4.2"], "pdf": "https://arxiv.org/pdf/2509.26616", "abs": "https://arxiv.org/abs/2509.26616", "authors": ["Mohammad Rifat Arefin", "Shanto Rahman", "Christoph Csallner"], "title": "Black-box Context-free Grammar Inference for Readable & Natural Grammars", "comment": "20 pages", "summary": "Black-box context-free grammar inference is crucial for program analysis,\nreverse engineering, and security, yet existing tools such as Arvada, TreeVada,\nand Kedavra struggle with scalability, readability, and accuracy on large,\ncomplex languages. We present NatGI, a novel LLM-guided grammar inference\nframework that extends TreeVada's parse tree recovery with three key\ninnovations: bracket-guided bubble exploration, LLM-driven bubble generation\nand non-terminal labeling, and hierarchical delta debugging (HDD) for\nsystematic tree simplification. Bracket-guided exploration leverages syntactic\ncues such as parentheses to propose well-structured grammar fragments, while\nLLM guidance produces meaningful non-terminal names and selects more promising\nmerges. Finally, HDD incrementally reduces unnecessary rules, which makes the\ngrammars both compact and interpretable. In our experiments, we evaluate NatGI\non a comprehensive benchmark suite ranging from small languages to larger ones\nsuch as lua, c, and mysql. Our results show that NatGI consistently outperforms\nstrong baselines in terms of F1 score. On average, NatGI achieves an F1 score\nof 0.57, which is 25pp (percentage points) higher than the best-performing\nbaseline, TreeVada. In the case of interpretability, our generated grammars\nperform significantly better than those produced by existing approaches.\nLeveraging LLM-based node renaming and bubble exploration, NatGI produces rules\nwith meaningful non-terminal names and compact structures that align more\nclosely with human intuition. As a result, developers and researchers can\nachieve higher accuracy while still being able to easily inspect, verify, and\nreason about the structure and semantics of the induced grammars.", "AI": {"tldr": "NatGI\u662f\u4e00\u79cd\u7ed3\u5408LLM\u7684\u65b0\u578b\u6587\u6cd5\u5f52\u7eb3\u65b9\u6cd5\uff0c\u901a\u8fc7\u7ed3\u6784\u521b\u65b0\u548c\u667a\u80fd\u547d\u540d\uff0c\u663e\u8457\u63d0\u9ad8\u4e86\u51c6\u786e\u7387\u548c\u6587\u6cd5\u53ef\u89e3\u91ca\u6027\uff0c\u4f18\u4e8e\u73b0\u6709\u4e3b\u6d41\u5de5\u5177\uff0c\u5e76\u9002\u7528\u4e8e\u5305\u62ecC\u3001lua\u7b49\u590d\u6742\u8bed\u8a00\u3002", "motivation": "\u73b0\u6709\u7684\u9ed1\u76d2\u6587\u6cd5\u5f52\u7eb3\u5de5\u5177\u5728\u5904\u7406\u5927\u89c4\u6a21\u590d\u6742\u8bed\u8a00\u65f6\uff0c\u5b58\u5728\u53ef\u6269\u5c55\u6027\u3001\u53ef\u8bfb\u6027\u548c\u51c6\u786e\u6027\u4e0d\u8db3\u7684\u95ee\u9898\uff0c\u5f71\u54cd\u7a0b\u5e8f\u5206\u6790\u3001\u9006\u5411\u5de5\u7a0b\u53ca\u5b89\u5168\u9886\u57df\u5e94\u7528\u3002", "method": "NatGI\u7ed3\u5408\u4e09\u5927\u521b\u65b0\uff1a\u57fa\u4e8e\u62ec\u53f7\u7684bubble\u63a2\u7d22\u3001LLM\u9a71\u52a8\u7684bubble\u751f\u6210\u4e0e\u975e\u7ec8\u7ed3\u7b26\u547d\u540d\u3001\u5206\u5c42Delta\u8c03\u8bd5\uff08HDD\uff09\u7528\u4e8e\u7cfb\u7edf\u5316\u7b80\u5316\u6587\u6cd5\u6811\u3002Bracket\u5f15\u5bfc\u63a2\u7d22\u7ed3\u5408\u8bed\u6cd5\u7ed3\u6784\u63d0\u793a\uff0cLLM\u5b9e\u73b0\u66f4\u6709\u610f\u4e49\u7684\u975e\u7ec8\u7ed3\u7b26\u547d\u540d\u548c\u5408\u5e76\u9009\u62e9\uff0cHDD\u9010\u6b65\u5220\u51cf\u5197\u4f59\u89c4\u5219\u3002", "result": "NatGI\u5e73\u5747F1\u5206\u6570\u4e3a0.57\uff0c\u9ad8\u51fa\u6700\u4f73\u5bf9\u6bd4\u57fa\u7ebfTreeVada 25\u4e2a\u767e\u5206\u70b9\u3002\u751f\u6210\u6587\u6cd5\u5728\u53ef\u89e3\u91ca\u6027\u4e0a\u4e5f\u663e\u8457\u4f18\u4e8e\u73b0\u6709\u65b9\u6cd5\uff0c\u7ed3\u6784\u66f4\u7d27\u51d1\u3001\u547d\u540d\u66f4\u6613\u61c2\u3001\u66f4\u8d34\u8fd1\u4eba\u7c7b\u7406\u89e3\u3002", "conclusion": "NatGI\u65b9\u6cd5\u5728F1\u5206\u6570\u548c\u53ef\u89e3\u91ca\u6027\u4e0a\u90fd\u663e\u8457\u4f18\u4e8e\u73b0\u6709\u7684\u9ed1\u76d2\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5\u5f52\u7eb3\u5de5\u5177\uff0c\u5982Arvada\u3001TreeVada\u548cKedavra\u3002\u6b64\u5916\uff0c\u751f\u6210\u7684\u6587\u6cd5\u66f4\u7d27\u51d1\u6613\u61c2\uff0c\u66f4\u8d34\u8fd1\u4eba\u7c7b\u76f4\u89c9\uff0c\u65b9\u4fbf\u5f00\u53d1\u8005\u548c\u7814\u7a76\u8005\u5ba1\u67e5\u548c\u7406\u89e3\u3002"}}
{"id": "2509.25879", "categories": ["cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.25879", "abs": "https://arxiv.org/abs/2509.25879", "authors": ["Michele De Pascalis", "Tarmo Uustalu", "Niccol\u00f2 Veltr\u00ec"], "title": "Monoid Structures on Indexed Containers", "comment": "In Proceedings LSFA 2025, arXiv:2509.23739", "summary": "Containers represent a wide class of type constructions relevant for\nfunctional programming and (co)inductive reasoning. Indexed containers\ngeneralize this notion to better fit the scope of dependently typed\nprogramming. When interpreting types to be sets, a container describes an\nendofunctor on the category of sets while an I-indexed container describes an\nendofunctor on the category Set^I of I-indexed families of sets.\n  We consider the monoidal structure on the category of I-indexed containers\nwhose tensor product of containers describes the composition of the respective\ninduced endofunctors. We then give a combinatorial characterization of monoids\nin this monoidal category, and we show how these monoids correspond precisely\nto monads on the induced endofunctors on Set^I. Lastly, we conclude by\npresenting some examples of monads on Set^I that fall under our\ncharacterization, including the product of two monads, indexed variants of the\nstate and the writer monads and an example of a free monad. The technical\nresults of this work are accompanied by a formalization in the proof assistant\nCubical Agda.", "AI": {"tldr": "\u672c\u6587\u7cfb\u7edf\u7814\u7a76\u4e86I-\u7d22\u5f15\u5bb9\u5668\u7684\u8303\u7574\u53ca\u5176\u5355\u5b50\u7ed3\u6784\uff0c\u8bc1\u660e\u4e86\u5e7a\u534a\u7fa4\u4e0eSet^I\u4e0a\u7684\u5355\u5b50\u4e00\u4e00\u5bf9\u5e94\uff0c\u5e76\u901a\u8fc7\u591a\u4e2a\u5b9e\u4f8b\u548cCubical Agda\u5f62\u5f0f\u5316\u5c55\u793a\u5176\u7406\u8bba\u6709\u6548\u6027\u3002", "motivation": "\u5bb9\u5668\u7406\u8bba\u53ca\u5176\u63a8\u5e7f\uff08\u7d22\u5f15\u5bb9\u5668\uff09\u5728\u51fd\u6570\u5f0f\u548c\u4f9d\u8d56\u7c7b\u578b\u7f16\u7a0b\uff0c\u4ee5\u53ca\u5f52\u7eb3\u548c\u4f59\u5f52\u7eb3\u63a8\u7406\u4e2d\u975e\u5e38\u91cd\u8981\u3002\u73b0\u6709\u7406\u8bba\u5bf9\u5982\u4f55\u5728\u4f9d\u8d56\u7c7b\u578b\u80cc\u666f\u4e0b\u63a8\u5e7f\u5bb9\u5668\u8303\u7574\u7ed3\u6784\u548c\u5355\u5b50\u7ed3\u6784\u5c1a\u7f3a\u7cfb\u7edf\u5316\u7814\u7a76\u3002\u672c\u6587\u65e8\u5728\u586b\u8865\u8be5\u9886\u57df\u7684\u7a7a\u767d\uff0c\u63ed\u793a\u4e8c\u8005\u4e4b\u95f4\u7684\u6df1\u5c42\u8054\u7cfb\u3002", "method": "\u91c7\u7528\u8303\u7574\u8bba\u5de5\u5177\uff0c\u5b9a\u4e49\u548c\u523b\u753b\u4e86I-\u7d22\u5f15\u5bb9\u5668\u7c7b\u522b\u53ca\u5176\u5f20\u91cf\u79ef\uff0c\u63a2\u8ba8\u4e86\u5e7a\u534a\u7fa4\u5bf9\u8c61\u53ca\u5176\u4e0e\u5e7a\u534a\u8303\u7574\uff08monad\uff09\u7684\u5173\u7cfb\uff0c\u5e76\u901a\u8fc7Cubical Agda\u5bf9\u4e3b\u8981\u7ed3\u679c\u8fdb\u884c\u4e86\u5f62\u5f0f\u5316\u9a8c\u8bc1\u3002", "result": "\u660e\u786e\u5b9a\u4e49\u5e76\u523b\u753b\u4e86I-\u7d22\u5f15\u5bb9\u5668\u7684\u5f20\u91cf\u79ef\u7ed3\u6784\u3001\u8303\u7574\u4e2d\u7684\u5e7a\u534a\u7fa4\u5bf9\u8c61\uff0c\u4ee5\u53ca\u8fd9\u4e9b\u5e7a\u534a\u7fa4\u4e0eSet^I\u4e0a\u5355\u5b50\u7684\u5bf9\u5e94\u5173\u7cfb\u3002\u5177\u4f53\u5b9e\u4f8b\u5305\u62ec\u4e24\u4e2a\u5355\u5b50\u7684\u79ef\u3001\u7d22\u5f15\u5316\u7684\u72b6\u6001\u5355\u5b50\u3001\u5199\u8005\u5355\u5b50\uff0c\u4ee5\u53ca\u81ea\u7531\u5355\u5b50\u7684\u793a\u4f8b\u3002\u6240\u6709\u7ed3\u679c\u5747\u5df2\u7528Cubical Agda\u5f62\u5f0f\u5316\u3002", "conclusion": "\u672c\u6587\u5f97\u51fa\u4e86I-\u7d22\u5f15\u5bb9\u5668\u8303\u7574\u4e2d\u7684\u5e7a\u534a\u7fa4\u4e0eSet^I\u4e0a\u7684\u5e7a\u534a\u7fa4\u4e00\u4e00\u5bf9\u5e94\u7684\u7ed3\u8bba\uff08\u5373\u5e7a\u534a\u7fa4\u5bf9\u5e94\u4e8e\u5e7a\u534a\u8303\u7574\u4e2d\u7684\u5e7a\u534a\u4f53\uff09\uff0c\u5e76\u7ed9\u51fa\u4e86\u82e5\u5e72\u76f8\u5173\u5355\u5b50\uff08monad\uff09\u7684\u7ec4\u5408\u5b9e\u4f8b\u3002"}}
{"id": "2509.26260", "categories": ["cs.DM", "math.CO", "05C10, 05C20, 05C45, 05C60, 05C83, 06F30, 57N35, 06A06", "G.2; F.2"], "pdf": "https://arxiv.org/pdf/2509.26260", "abs": "https://arxiv.org/abs/2509.26260", "authors": ["Dario Cavallaro", "Ken-ichi Kawarabayashi", "Stephan Kreutzer"], "title": "Well-Quasi-Ordering Eulerian Digraphs Embeddable in Surfaces by Strong Immersion", "comment": null, "summary": "We prove that for every surface $\\Sigma$, the class of Eulerian directed\ngraphs that are Eulerian embeddable into $\\Sigma$ (in particular they have\ndegree at most $4$) is well-quasi-ordered by strong immersion. This result\nmarks one of the most versatile directed graph classes (besides tournaments)\nfor which we are aware of a positive well-quasi-ordering result regarding a\nwell-studied graph relation.\n  Our result implies that the class of bipartite circle graphs is\nwell-quasi-ordered under the pivot-minor relation. Furthermore, this also\nyields two other interesting applications, namely, a polynomial-time algorithm\nfor testing immersion closed properties of Eulerian-embeddable graphs into a\nfixed surface, and a characterisation of the Erd\\H{o}s-P\\'osa property for\nEulerian digraphs of maximum degree four.\n  Further, in order to prove the mentioned result, we prove that Eulerian\ndigraphs of carving width bounded by some constant $k$ (which correspond to\nEulerian digraphs with bounded treewidth and additionally bounded degree) are\nwell-quasi-ordered by strong immersion. We actually prove a stronger result\nwhere we allow for vertices of the Eulerian digraphs to be labeled by elements\nof some well-quasi-order $\\Omega$. We complement these results with a proof\nthat the class of Eulerian planar digraphs of treewidth at most $3$ is not\nwell-quasi-ordered by strong immersion, noting that any antichain of bounded\ntreewidth cannot have bounded degree.", "AI": {"tldr": "\u672c\u6587\u8bc1\u660e\u4e86\u6240\u6709\u53ef\u5d4c\u5165\u5728\u4efb\u610f\u8868\u9762\u4e0a\u7684Eulerian\u6709\u5411\u56fe\u5728\u5f3a\u6d78\u5165\u4e0b\u826f\u5e8f\uff0c\u5e26\u6765\u4e86\u82e5\u5e72\u76f8\u5173\u7ed3\u6784\uff08\u5982\u53cc\u5708\u56fe\uff09\u5728pivot-minor\u5173\u7cfb\u4e0b\u826f\u5e8f\u3001\u6709\u6548\u7b97\u6cd5\u53caErd\u0151s-P\u00f3sa\u5b9a\u7406\u523b\u753b\u3002\u540c\u65f6\u4e5f\u53d1\u73b0\u4e86\u6811\u5bbd\u8f83\u5927\u65f6\u826f\u5e8f\u7ed3\u679c\u4e0d\u6210\u7acb\u7684\u5c40\u9650\u3002", "motivation": "\u7814\u7a76\u6709\u5411\u56fe\u5728\u7279\u5b9a\u8868\u9762\u4e0a\u7684\u5d4c\u5165\u53ca\u5176\u76f8\u5173\u7684\u5f3a\u6d78\u5165\u5173\u7cfb\u7684\u826f\u5e8f\u6027\uff08well-quasi-order\uff09\uff0c\u586b\u8865\u5173\u4e8e\u8be5\u56fe\u5bf9\u8c61\u826f\u5e8f\u6027\u7684\u7406\u8bba\u7a7a\u767d\uff0c\u5e76\u63a2\u7d22\u5176\u5728\u56fe\u8bba\u53ca\u7ec4\u5408\u4f18\u5316\u4e2d\u7684\u5e94\u7528\u3002", "method": "\u8bc1\u660e\u5bf9\u4e8e\u4efb\u610f\u8868\u9762\u03a3\uff0c\u53efEulerian\u5d4c\u5165\u7684Eulerian\u6709\u5411\u56fe\uff08\u5176\u5ea6\u81f3\u591a\u4e3a4\uff09\u5728\u5f3a\u6d78\u5165\u5173\u7cfb\u4e0b\u662f\u826f\u5e8f\u7684\u3002\u8fdb\u4e00\u6b65\uff0c\u5206\u6790\u8be5\u7ed3\u679c\u5728\u53cc\u5708\u56fepivot-minor\u5173\u7cfb\u3001\u591a\u9879\u5f0f\u65f6\u95f4\u5224\u5b9a\u53caErd\u0151s-P\u00f3sa\u6027\u8d28\u4e0a\u7684\u5e94\u7528\u3002\u6b64\u5916\uff0c\u8bc1\u660e\u6709\u754ccarving\u5bbd\u5ea6\u7684Eulerian\u6709\u5411\u56fe\u4e5f\u5728\u5f3a\u6d78\u5165\u5173\u7cfb\u4e0b\u826f\u5e8f\uff0c\u5e76\u63a8\u5e7f\u5230\u9876\u70b9\u5e26\u6807\u7b7e\u7684\u60c5\u51b5\u3002\u6700\u540e\uff0c\u901a\u8fc7\u6784\u9020\u53cd\u4f8b\u8bc1\u660e\u6811\u5bbd\u81f3\u591a3\u7684Eulerian\u5e73\u9762\u6709\u5411\u56fe\u5728\u5f3a\u6d78\u5165\u5173\u7cfb\u4e0b\u5e76\u975e\u826f\u5e8f\u3002", "result": "\u5bf9\u4e8e\u4efb\u610f\u8868\u9762\u03a3\uff0c\u6240\u6709\u53efEulerian\u5d4c\u5165\u7684Eulerian\u6709\u5411\u56fe\uff08\u5ea6\u81f3\u591a4\uff09\u5728\u5f3a\u6d78\u5165\u4e0b\u826f\u5e8f\uff1b\u53cc\u5708\u56fe\u5728pivot-minor\u5173\u7cfb\u4e0b\u826f\u5e8f\u3002\u63d0\u51fa\u4e86\u9488\u5bf9\u6709\u9650\u8868\u9762\u4e0a\u7684Eulerian-embeddable\u56fe\u6d78\u5165\u5c01\u95ed\u6027\u8d28\u7684\u591a\u9879\u5f0f\u7b97\u6cd5\uff0c\u4ee5\u53ca\u6700\u5927\u5ea6\u4e3a4\u7684Eulerian\u6709\u5411\u56fe\u7684Erd\u0151s-P\u00f3sa\u6027\u8d28\u523b\u753b\u3002\u540c\u65f6\uff0c\u63a8\u5e7f\u81f3\u6807\u7b7e\u56fe\u7684\u60c5\u51b5\uff0c\u4f46\u6307\u51fa\u6811\u5bbd\u22643\u7684Eulerian\u5e73\u9762\u6709\u5411\u56fe\u4e0d\u826f\u5e8f\u3002", "conclusion": "\u672c\u6587\u9996\u6b21\u7cfb\u7edf\u5730\u8bc1\u660e\u4e86\u5728\u7ed9\u5b9a\u8868\u9762\u4e0a\u7684Eulerian\u53ef\u5d4c\u5165\u6709\u5411\u56fe\u5728\u5f3a\u6d78\u5165\u4e0b\u826f\u5e8f\uff0c\u5e76\u8054\u52a8\u5230\u591a\u9879\u5e94\u7528\u53ca\u63a8\u5e7f\uff0c\u586b\u8865\u4e86\u6b64\u7c7b\u6709\u5411\u56fe\u826f\u5e8f\u7406\u8bba\u53ca\u76f8\u5173\u7b97\u6cd5\u7684\u7a7a\u7f3a\u3002\u4e5f\u63ed\u793a\u4e86\u6709\u5411\u56fe\u826f\u5e8f\u6027\u5728\u9ad8\u6811\u5bbd\u65f6\u7684\u5c40\u9650\u6027\u3002"}}
{"id": "2509.25192", "categories": ["cs.SE", "68T07"], "pdf": "https://arxiv.org/pdf/2509.25192", "abs": "https://arxiv.org/abs/2509.25192", "authors": ["Anderson de Lima Luiz"], "title": "WARP -- Web-Augmented Real-time Program Repairer: A Real-Time Compilation Error Resolution using LLMs and Web-Augmented Synthesis", "comment": "5 pages, 2 figures", "summary": "Compilation errors represent a significant bottleneck in software development\nproductivity. This paper introduces WARP (Web-Augmented Real-time Program\nRepairer), a novel system that leverages Large Language Models (LLMs) and\ndynamic web-augmented synthesis for real-time resolution of these errors. WARP\nactively monitors developer terminals, intelligently detects compilation\nerrors, and synergistically combines the understanding of a fine-tuned Code-LLM\nwith relevant solutions, explanations, and code snippets retrieved from\nup-to-date web sources like developer forums and official documentation.\nExperimental results on our curated benchmark, CGP (featuring C/C++, Python,\nand Go errors), demonstrate WARP achieves a superior fix rate (72.5 % Compiles\ncorrectly) and higher semantic correctness compared to baseline LLM-only\napproaches and traditional IDE quick-fixes. Key technical challenges in\nachieving high-accuracy synthesis from noisy web data.", "AI": {"tldr": "WARP\u7ed3\u5408\u4ee3\u7801LLM\u4e0e\u7f51\u7edc\u8d44\u6e90\uff0c\u80fd\u66f4\u9ad8\u6548\u4fee\u590d\u7f16\u8bd1\u9519\u8bef\uff0c\u5728\u5b9e\u9a8c\u4e2d\u6027\u80fd\u663e\u8457\u4f18\u4e8e\u5355\u4e00LLM\u65b9\u6848\u548cIDE\u5de5\u5177\u3002", "motivation": "\u7f16\u8bd1\u9519\u8bef\u4e25\u91cd\u5f71\u54cd\u8f6f\u4ef6\u5f00\u53d1\u6548\u7387\uff0c\u73b0\u6709\u4fee\u590d\u65b9\u6cd5\uff08\u5355\u9760LLM\u6216IDE\u5feb\u6377\u4fee\u590d\uff09\u6548\u679c\u6709\u9650\uff0c\u9700\u7ed3\u5408\u5b9e\u65f6\u7f51\u7edc\u8d44\u6e90\u63d0\u5347\u4fee\u590d\u80fd\u529b\u3002", "method": "\u8be5\u7814\u7a76\u63d0\u51faWARP\u7cfb\u7edf\uff0c\u5c06\u5fae\u8c03\u7684Code-LLM\u4e0e\u52a8\u6001\u68c0\u7d22\u7f51\u7edc\u8d44\u6e90\uff08\u8bba\u575b\u3001\u5b98\u65b9\u6587\u6863\u7b49\uff09\u7ed3\u5408\uff0c\u5bf9\u5f00\u53d1\u8005\u7f16\u8bd1\u9519\u8bef\u8fdb\u884c\u89e3\u6790\u3001\u68c0\u7d22\u548c\u4ee3\u7801\u4fee\u590d\uff0c\u5e76\u8fdb\u884c\u5b9e\u9a8c\u9a8c\u8bc1\u3002", "result": "\u5728CGP\u57fa\u51c6\u6d4b\u8bd5\u4e0a\uff0cWARP\u4fee\u590d\u7387\u8fbe\u523072.5%\uff08\u53ef\u6b63\u786e\u7f16\u8bd1\uff09\uff0c\u5e76\u5b9e\u73b0\u66f4\u9ad8\u7684\u8bed\u4e49\u6b63\u786e\u6027\uff0c\u4f18\u4e8e\u5bf9\u6bd4\u65b9\u6848\u3002", "conclusion": "WARP\u7cfb\u7edf\u80fd\u6709\u6548\u63d0\u9ad8\u7f16\u8bd1\u9519\u8bef\u7684\u4fee\u590d\u7387\u548c\u8bed\u4e49\u6b63\u786e\u6027\uff0c\u4f18\u4e8e\u4ec5\u4f9d\u8d56LLM\u7684\u65b9\u6848\u4ee5\u53ca\u4f20\u7edfIDE\u4fee\u590d\u65b9\u5f0f\u3002"}}
{"id": "2509.25220", "categories": ["cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25220", "abs": "https://arxiv.org/abs/2509.25220", "authors": ["Eduard Kapelko"], "title": "Cyclic Ablation: Testing Concept Localization against Functional Regeneration in AI", "comment": "Code is available at:\n  https://www.kaggle.com/code/kapedalex/cycleablationpublic/", "summary": "Safety and controllability are critical for large language models. A central\nquestion is whether undesirable behaviors like deception are localized\nfunctions that can be removed, or if they are deeply intertwined with a model's\ncore cognitive abilities. We introduce \"cyclic ablation,\" an iterative method\nto test this. By combining sparse autoencoders, targeted ablation, and\nadversarial training on DistilGPT-2, we attempted to eliminate the concept of\ndeception. We found that, contrary to the localization hypothesis, deception\nwas highly resilient. The model consistently recovered its deceptive behavior\nafter each ablation cycle via adversarial training, a process we term\nfunctional regeneration. Crucially, every attempt at this \"neurosurgery\" caused\na gradual but measurable decay in general linguistic performance, reflected by\na consistent rise in perplexity. These findings are consistent with the view\nthat complex concepts are distributed and entangled, underscoring the\nlimitations of direct model editing through mechanistic interpretability.", "AI": {"tldr": "\u4f5c\u8005\u901a\u8fc7\u5faa\u73af\u6d88\u878d\u548c\u5bf9\u6297\u8bad\u7ec3\u8bd5\u56fe\u6d88\u9664\u5927\u8bed\u8a00\u6a21\u578b\u4e2d\u7684\u6b3a\u9a97\u884c\u4e3a\uff0c\u53d1\u73b0\u8be5\u884c\u4e3a\u9ad8\u5ea6\u987d\u56fa\u4e14\u65e0\u6cd5\u88ab\u5b9a\u70b9\u6d88\u9664\uff0c\u4e14\u591a\u6b21\u5c1d\u8bd5\u540e\u6a21\u578b\u6574\u4f53\u8bed\u8a00\u80fd\u529b\u9010\u6b65\u51cf\u5f31\u3002\u8fd9\u8bf4\u660e\u590d\u6742\u884c\u4e3a\u662f\u5206\u5e03\u5f0f\u4e14\u7f20\u7ed5\u7684\uff0c\u9650\u5236\u4e86\u76f4\u63a5\u901a\u8fc7\u673a\u7406\u53ef\u89e3\u91ca\u6027\u65b9\u6cd5\u7f16\u8f91\u6a21\u578b\u5b9e\u73b0\u5b89\u5168\u548c\u53ef\u63a7\u3002", "motivation": "\u7814\u7a76\u5927\u8bed\u8a00\u6a21\u578b\u4e2d\u7684\u4e0d\u826f\u884c\u4e3a\uff08\u5982\u6b3a\u9a97\uff09\u662f\u5426\u53ef\u4ee5\u901a\u8fc7\u76f4\u63a5\u5b9a\u4f4d\u5e76\u79fb\u9664\uff0c\u63a2\u7d22\u6a21\u578b\u5b89\u5168\u6027\u548c\u53ef\u63a7\u6027\u7684\u53ef\u884c\u6027\u3002", "method": "\u63d0\u51fa\u4e86\u201c\u5faa\u73af\u6d88\u878d\u201d\u65b9\u6cd5\uff1a\u7ed3\u5408\u7a00\u758f\u81ea\u52a8\u7f16\u7801\u5668\u3001\u5b9a\u5411\u6d88\u878d\u548c\u5bf9\u6297\u8bad\u7ec3\uff0c\u5728DistilGPT-2\u6a21\u578b\u4e0a\u9488\u5bf9\u201c\u6b3a\u9a97\u201d\u6982\u5ff5\u8fdb\u884c\u591a\u8f6e\u8fed\u4ee3\u6d88\u9664\u5b9e\u9a8c\u3002", "result": "\u6bcf\u6b21\u6d88\u878d\u540e\uff0c\u6a21\u578b\u901a\u8fc7\u5bf9\u6297\u8bad\u7ec3\u6062\u590d\u51fa\u6b3a\u9a97\u884c\u4e3a\uff0c\u5bfc\u81f4\u8bed\u8a00\u80fd\u529b\u6574\u4f53\u4e0b\u964d\uff08\u56f0\u60d1\u5ea6\u4e0a\u5347\uff09\uff0c\u8868\u660e\u6b3a\u9a97\u884c\u4e3a\u96be\u4ee5\u88ab\u5b9a\u5411\u6d88\u9664\uff0c\u6a21\u578b\u6027\u80fd\u53d7\u635f\u3002", "conclusion": "\u590d\u6742\u6982\u5ff5\uff08\u5982\u6b3a\u9a97\uff09\u5728\u5927\u8bed\u8a00\u6a21\u578b\u4e2d\u7684\u5206\u5e03\u662f\u5206\u6563\u4e14\u5bc6\u5207\u76f8\u5173\u7684\uff0c\u96be\u4ee5\u901a\u8fc7\u76f4\u63a5\u7f16\u8f91\u6a21\u578b\u6765\u5b9e\u73b0\u5b89\u5168\u6027\u548c\u53ef\u63a7\u6027\u3002"}}
{"id": "2509.25196", "categories": ["cs.SE", "cs.AI", "cs.LG", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.25196", "abs": "https://arxiv.org/abs/2509.25196", "authors": ["Hua Zhong", "Shan Jiang", "Sarfraz Khurshid"], "title": "APRIL: API Synthesis with Automatic Prompt Optimization and Reinforcement Learning", "comment": null, "summary": "APIs are central to modern software development, yet composing new APIs from\nlarge libraries is difficult due to the exponential search space; traditional\ncomponent-based synthesis relies on costly exploration and hand-crafted\nspecifications. While large language models (LLMs) can generate implementations\nfrom natural language, hallucinations and limited access to up-to-date\ncontextual information often yield incorrect code. In this paper, we present\nAPRIL, an approach that combines LLM-based synthesis with Automatic Prompt\nOptimization (APO) and Reinforcement Learning from Verifiable Rewards (RLVR):\nAPO iteratively refines prompts for a frozen model, while RLVR fine-tunes the\npolicy toward functional correctness, producing an efficient synthesis\npipeline. Evaluated on 81 real-world APIs from widely used scientific Python\nlibraries and benchmarked against instruction-tuned but unfine-tuned LLMs\nguided by expert prompts, APRIL achieves substantial improvements. These\nresults indicate that integrating APO and RLVR provides a robust, scalable path\nfor component-based API synthesis in large libraries.", "AI": {"tldr": "APRIL\u901a\u8fc7\u63d0\u793a\u4f18\u5316\u548c\u5f3a\u5316\u5b66\u4e60\uff0c\u663e\u8457\u63d0\u5347\u4e86LLM\u9a71\u52a8\u7684API\u5408\u6210\u6027\u80fd\uff0c\u662f\u5927\u89c4\u6a21\u5e93\u7ec4\u4ef6\u5f0fAPI\u5408\u6210\u7684\u9ad8\u6548\u65b9\u6848\u3002", "motivation": "\u751f\u6210\u65b0API\u65f6\u9700\u8981\u4ece\u5e9e\u5927\u7684\u5e93\u4e2d\u7ec4\u5408\u7ec4\u4ef6\uff0c\u7a7a\u95f4\u5de8\u5927\u4e14\u4f20\u7edf\u65b9\u6cd5\u4f9d\u8d56\u4eba\u5de5\u89c4\u8303\u548c\u9ad8\u6602\u63a2\u7d22\u6210\u672c\uff0c\u800cLLM\u751f\u6210\u4ee3\u7801\u5b58\u5728\u5e7b\u89c9\u548c\u4e0a\u4e0b\u6587\u4fe1\u606f\u4e0d\u8db3\u3001\u51c6\u786e\u6027\u6709\u9650\u3002", "method": "\u63d0\u51faAPRIL\uff0c\u5c06\u57fa\u4e8e\u5927\u8bed\u8a00\u6a21\u578b\u7684\u5408\u6210\u4e0e\u81ea\u52a8\u5316\u63d0\u793a\u4f18\u5316\uff08APO\uff09\u53ca\u57fa\u4e8e\u53ef\u9a8c\u8bc1\u5956\u52b1\u7684\u5f3a\u5316\u5b66\u4e60\uff08RLVR\uff09\u7ed3\u5408\uff1aAPO\u81ea\u52a8\u4f18\u5316\u51bb\u7ed3\u6a21\u578b\u7684\u63d0\u793a\uff0cRLVR\u7528\u529f\u80fd\u6b63\u786e\u6027\u7684\u5956\u52b1\u5fae\u8c03\u7b56\u7565\u3002", "result": "\u572881\u4e2a\u79d1\u5b66Python\u5e93\u7684\u771f\u5b9eAPI\u4e0a\u8bc4\u4f30\uff0cAPRIL\u6bd4\u57fa\u7ebf\u672a\u5fae\u8c03\u4f46\u7531\u4e13\u5bb6\u6307\u5b9a\u63d0\u793a\u7684LLM\u6548\u679c\u63d0\u5347\u660e\u663e\uff0c\u8bc1\u660e\u65b9\u6cd5\u9ad8\u6548\u5e76\u5177\u5907\u5b9e\u9645\u5e94\u7528\u80fd\u529b\u3002", "conclusion": "\u7ed3\u5408APO\u548cRLVR\uff0c\u4e3a\u5927\u578b\u5e93\u4e2d\u57fa\u4e8e\u7ec4\u4ef6\u7684API\u5408\u6210\u63d0\u4f9b\u4e86\u5f3a\u5065\u3001\u53ef\u6269\u5c55\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u5b9e\u73b0\u4e86\u51c6\u786e\u6027\u548c\u6548\u7387\u7684\u5927\u5e45\u63d0\u5347\u3002"}}

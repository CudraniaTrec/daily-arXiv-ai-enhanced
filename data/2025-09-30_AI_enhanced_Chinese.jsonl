{"id": "2509.24024", "categories": ["cs.FL", "cs.CL", "cs.LG", "cs.LO"], "pdf": "https://arxiv.org/pdf/2509.24024", "abs": "https://arxiv.org/abs/2509.24024", "authors": ["Anthony W. Lin", "Pablo Barcelo"], "title": "The Role of Logic and Automata in Understanding Transformers", "comment": "Preprint of invited paper for RP'25", "summary": "The advent of transformers has in recent years led to powerful and\nrevolutionary Large Language Models (LLMs). Despite this, our understanding on\nthe capability of transformers is still meager. In this invited contribution,\nwe recount the rapid progress in the last few years to the question of what\ntransformers can do. In particular, we will see the integral role of logic and\nautomata (also with some help from circuit complexity) in answering this\nquestion. We also mention several open problems at the intersection of logic,\nautomata, verification and transformers.", "AI": {"tldr": "\u672c\u6587\u7efc\u8ff0\u4e86\u5229\u7528\u903b\u8f91\u548c\u81ea\u52a8\u673a\u7b49\u7406\u8bba\u5de5\u5177\u5206\u6790\u5927\u578b\u8bed\u8a00\u6a21\u578btransformers\u80fd\u529b\u7684\u6700\u65b0\u8fdb\u5c55\uff0c\u5e76\u63d0\u51fa\u4e86\u8bb8\u591a\u76f8\u5173\u5f00\u653e\u95ee\u9898\u3002", "motivation": "\u76ee\u524d\u5bf9transformers\u5e95\u5c42\u80fd\u529b\u673a\u5236\u7406\u89e3\u4e0d\u8db3\uff0c\u4e9f\u9700\u7406\u8bba\u89d2\u5ea6\u89e3\u91ca\u5176\u5f3a\u5927\u8868\u73b0\u3002", "method": "\u56de\u987e\u8fd1\u5e74\u6709\u5173transformers\u80fd\u529b\u95ee\u9898\u7684\u7814\u7a76\u8fdb\u5c55\uff0c\u5f3a\u8c03\u903b\u8f91\u3001\u81ea\u52a8\u673a\u4e0e\u7535\u8def\u590d\u6742\u6027\u7406\u8bba\u7684\u7ed3\u5408\u3002", "result": "\u5c55\u73b0\u4e86\u903b\u8f91\u3001\u81ea\u52a8\u673a\u7b49\u7406\u8bba\u5de5\u5177\u5728\u5206\u6790transformers\u80fd\u529b\u4e2d\u7684\u6709\u6548\u6027\uff0c\u5e76\u63d0\u51fa\u4ea4\u53c9\u9886\u57df\u7684\u82e5\u5e72\u5f00\u653e\u95ee\u9898\u3002", "conclusion": "\u903b\u8f91\u548c\u81ea\u52a8\u673a\u7406\u8bba\u5728\u7406\u89e3transformers\u80fd\u529b\u65b9\u9762\u53d1\u6325\u4e86\u6838\u5fc3\u4f5c\u7528\uff0c\u672c\u6587\u8fd8\u6307\u51fa\u5f53\u524d\u76f8\u5173\u9886\u57df\u8fd8\u5b58\u5728\u8bb8\u591a\u672a\u89e3\u51b3\u7684\u95ee\u9898\u3002"}}
{"id": "2509.24754", "categories": ["cs.FL", "math.DS", "F.4.3; G.2.1"], "pdf": "https://arxiv.org/pdf/2509.24754", "abs": "https://arxiv.org/abs/2509.24754", "authors": ["Marie-Pierre B\u00e9al", "Alexi Block Gorman"], "title": "One-sided Hom shifts", "comment": null, "summary": "We prove that it is decidable whether a one-sided shift of finite type is\nconjugate to a one-sided Hom-shift, and whether a tree-shift of finite type is\nconjugate to a Hom tree-shift. The proof uses Williams's theory for one-sided\nshifts", "AI": {"tldr": "\u672c\u6587\u89e3\u51b3\u4e86\u6709\u9650\u578b\u4e00\u4fa7\u79fb\u4f4d\u4e0e\u6811\u79fb\u4f4d\u662f\u5426\u4e0e\u76f8\u5e94Hom\u79fb\u4f4d\u5171\u8f6d\u7684\u5224\u5b9a\u6027\u95ee\u9898\uff0c\u5e76\u7ed9\u51fa\u76f8\u5e94\u51b3\u7b56\u65b9\u6cd5\u3002", "motivation": "\u5224\u5b9a\u67d0\u4e9b\u52a8\u529b\u7cfb\u7edf\u7ed3\u6784\u4e0a\u7684\u5171\u8f6d\u5173\u7cfb\u5c5e\u4e8e\u7b26\u53f7\u52a8\u529b\u7cfb\u7edf\u7684\u57fa\u7840\u95ee\u9898\uff0c\u4f46\u4e00\u822c\u60c5\u5f62\u4e0b\u96be\u4ee5\u89e3\u6790\uff0c\u56e0\u6b64\u7279\u5b9a\u7c7b\u578b\uff08\u5982\u6709\u9650\u578b\u79fb\u4f4d\u4e0eHom\u79fb\u4f4d\uff09\u4e4b\u95f4\u5224\u5b9a\u5176\u7ed3\u6784\u540c\u6784\u5177\u6709\u7406\u8bba\u4ef7\u503c\u4e0e\u5b9e\u9645\u610f\u4e49\u3002", "method": "\u5229\u7528Williams\u7684\u4e00\u4fa7\u79fb\u4f4d\u7406\u8bba\u8fdb\u884c\u8bc1\u660e\u3002", "result": "\u786e\u5b9a\u5224\u5b9a\u7b97\u6cd5\uff0c\u610f\u5473\u7740\u5bf9\u4e8e\u76f8\u5173\u79fb\u4f4d\u7cfb\u7edf\u7684\u7ed3\u6784\u7b49\u4ef7\u6027\u95ee\u9898\u5df2\u53ef\u6709\u6548\u8bc6\u522b\u3002", "conclusion": "\u6211\u4eec\u8bc1\u660e\u4e86\u4e24\u4e2a\u5224\u5b9a\u6027\u95ee\u9898\u53ef\u4ee5\u88ab\u89e3\u51b3\uff1a\u4e00\u4fa7\u7684\u6709\u9650\u578b\u79fb\u4f4d\u662f\u5426\u4e0e\u4e00\u4fa7\u7684Hom\u79fb\u4f4d\u5171\u8f6d\uff0c\u4ee5\u53ca\u6709\u9650\u578b\u6811\u79fb\u4f4d\u662f\u5426\u4e0eHom\u6811\u79fb\u4f4d\u5171\u8f6d\u3002"}}
{"id": "2509.22995", "categories": ["cs.LO", "cs.CC"], "pdf": "https://arxiv.org/pdf/2509.22995", "abs": "https://arxiv.org/abs/2509.22995", "authors": ["Yumiko Nishiyama"], "title": "Structural Separation and Semantic Incompatibility in the P vs. NP Problem: Computational Complexity Analysis with Construction Defining Functionality", "comment": null, "summary": "The Boolean satisfiability problem (SAT) holds a central place in\ncomputational complexity theory as the first shown NP-complete problem. Due to\nthis role, SAT is often used as the benchmark for polynomial-time reductions:\nif a problem can be reduced to SAT, it is at least as hard as SAT, and hence\nconsidered NP-complete. However, the CDF framework offers a structural\ninversion of this traditional view. Rather than treating SAT as merely a\nrepresentative of NP-completeness, we investigate whether the syntactic\nstructure of SAT itself -- especially in its 3SAT form -- is the source of\nsemantic explosion and computational intractability observed in NP problems. In\nother words, SAT is not just the yardstick of NP-completeness, but may be the\nstructural archetype that induces NP-type complexity. This reframing suggests\nthat the P vs NP question is deeply rooted not only in computational resource\nlimits, but in the generative principles of problem syntax, with 3SAT capturing\nthe recursive and non-local constructions that define the boundary between\ntractable and intractable problems.", "AI": {"tldr": "\u672c\u6587\u901a\u8fc7CDF\u6846\u67b6\u5206\u6790SAT\u95ee\u9898\uff0c\u63d0\u51fa\u5176\u7ed3\u6784\u7279\u6027\u53ef\u80fd\u662f\u5bfc\u81f4NP\u7c7b\u95ee\u9898\u96be\u89e3\u7684\u6839\u672c\u539f\u56e0\uff0c\u91cd\u65b0\u5b9a\u4e49\u4e86SAT\u5728\u590d\u6742\u6027\u7406\u8bba\u4e2d\u7684\u4f5c\u7528\uff0c\u5bf9P\u4e0eNP\u95ee\u9898\u7ed9\u51fa\u65b0\u7684\u7ed3\u6784\u6027\u7406\u89e3\u3002", "motivation": "\u4f20\u7edf\u4e0aSAT\u88ab\u89c6\u4e3aNP\u5b8c\u5907\u6027\u7684\u6807\u51c6\u4ee3\u8868\uff0c\u8bba\u6587\u5e0c\u671b\u901a\u8fc7\u53cd\u601dSAT\u7ed3\u6784\u672c\u8eab\uff0c\u63a2\u7d22\u5176\u662f\u5426\u662fNP\u590d\u6742\u6027\u4ea7\u751f\u7684\u7ed3\u6784\u6839\u6e90\uff0c\u800c\u4e0d\u53ea\u662f\u4e00\u4e2a\u5224\u5b9a\u6807\u51c6\u3002", "method": "\u91c7\u7528CDF\u6846\u67b6\u5bf9SAT\u95ee\u9898\u7ed3\u6784\u8fdb\u884c\u5206\u6790\uff0c\u91cd\u70b9\u7814\u7a763SAT\u5f62\u5f0f\u7684\u53e5\u6cd5\u7ed3\u6784\u4e0e\u8ba1\u7b97\u590d\u6742\u6027\u4e4b\u95f4\u7684\u5173\u7cfb\u3002", "result": "CDF\u6846\u67b6\u4e0b\u53d1\u73b03SAT\u7684\u9012\u5f52\u548c\u975e\u5c40\u90e8\u7ed3\u6784\u5f88\u53ef\u80fd\u5b9a\u4e49\u4e86\u53ef\u89e3\u548c\u4e0d\u53ef\u89e3\u95ee\u9898\u7684\u8fb9\u754c\uff0c\u56e0\u6b64SAT\u7684\u7ed3\u6784\u6027\u5bf9P vs NP\u95ee\u9898\u5177\u6709\u6839\u672c\u5f71\u54cd\u3002", "conclusion": "\u8bba\u6587\u63d0\u51fa\uff0c3SAT\u7684\u7ed3\u6784\u6027\u7279\u70b9\u53ef\u80fd\u662fNP\u95ee\u9898\u8ba1\u7b97\u4e0d\u53ef\u89e3\u6027\u7684\u672c\u6e90\uff0c\u5373SAT\u4e0d\u4ec5\u4ec5\u662fNP\u5b8c\u5907\u7684\u57fa\u51c6\uff0c\u66f4\u53ef\u80fd\u662f\u8bf1\u53d1NP\u590d\u6742\u6027\u7684\u7ed3\u6784\u6a21\u578b\u3002"}}
{"id": "2509.22982", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.22982", "abs": "https://arxiv.org/abs/2509.22982", "authors": ["David M Kahn", "Jan Hoffmann", "Thomas Reps", "Jessie Grosen"], "title": "Efficient Cost Bounds with Linear Maps", "comment": null, "summary": "The Automatic Amortized Resource Analysis (AARA) derives program-execution\ncost bounds using types. To do so, AARA often makes use of cost-free types,\nwhich are critical for the composition of types and cost bounds. However,\ninferring cost-free types using the current state-of-the-art algorithm is\nexpensive due to recursive dependence on additional cost-free types.\nFurthermore, that algorithm uses a heuristic only applicable to polynomial cost\nbounds, and not, e.g., exponential bounds. This paper presents a new approach\nto these problems by representing the cost-free types of a function in a new\nway: with a linear map, which can stand for infinitely many cost-free types.\nSuch maps enable an algebraic flavor of reasoning about cost bounds (including\nnon-polynomial bounds) via matrix inequalities. These inequalities can be\nsolved with off-the-shelf linear-programming tools for many programs, so that\ntypes can always be efficiently checked and often be efficiently inferred. An\nexperimental evaluation with a prototype implementation shows that-when it is\napplicable-the inference of linear maps is exponentially more efficient than\nthe state-of-the-art algorithm.", "AI": {"tldr": "\u901a\u8fc7\u7ebf\u6027\u6620\u5c04\u4e0e\u77e9\u9635\u4e0d\u7b49\u5f0f\uff0c\u672c\u6587\u9996\u6b21\u5b9e\u73b0\u5728\u591a\u79cd\u590d\u6742\u5ea6\u4e0b\u5bf9AARA\u7c7b\u578b\u9ad8\u6548\u5e76\u81ea\u52a8\u5316\u5730\u63a8\u65ad\uff0c\u5176\u65b9\u6cd5\u663e\u8457\u4f18\u4e8e\u73b0\u6709\u7b97\u6cd5\u3002", "motivation": "\u5f53\u524dAARA\u63a8\u65adcost-free\u7c7b\u578b\u7b97\u6cd5\u6548\u7387\u4f4e\uff0c\u4e14\u4ec5\u9002\u7528\u4e8e\u591a\u9879\u5f0f\u590d\u6742\u5ea6\uff0c\u6025\u9700\u66f4\u9ad8\u6548\u4e14\u80fd\u5904\u7406\u975e\u591a\u9879\u5f0f\u590d\u6742\u5ea6\u7684\u89e3\u51b3\u65b9\u6848\u3002", "method": "\u7528\u7ebf\u6027\u6620\u5c04\u66ff\u4ee3\u4f20\u7edf\u7684\u9012\u5f52\u65b9\u5f0f\u63cf\u8ff0cost-free\u7c7b\u578b\uff0c\u7136\u540e\u5229\u7528\u7ebf\u6027\u89c4\u5212\u5de5\u5177\u6c42\u89e3\u77e9\u9635\u4e0d\u7b49\u5f0f\uff0c\u4ece\u800c\u9ad8\u6548\u63a8\u65ad\u548c\u9a8c\u8bc1\u8d44\u6e90\u590d\u6742\u5ea6\u7c7b\u578b\u3002", "result": "\u539f\u578b\u5b9e\u73b0\u8868\u660e\u8be5\u65b9\u6cd5\u5728\u9002\u7528\u573a\u666f\u4e0b\u63a8\u65ad\u6548\u7387\u6bd4\u6700\u5148\u8fdb\u7b97\u6cd5\u9ad8\u51fa\u6307\u6570\u7ea7\u3002", "conclusion": "\u7528\u7ebf\u6027\u6620\u5c04\u8868\u793a\u51fd\u6570\u7684cost-free\u7c7b\u578b\uff0c\u5e76\u901a\u8fc7\u77e9\u9635\u4e0d\u7b49\u5f0f\u8fdb\u884c\u4ee3\u6570\u5316\u63a8\u7406\uff0c\u53ef\u4ee5\u66f4\u9ad8\u6548\u5730\u63a8\u65ad\u5e76\u6821\u9a8c\u7c7b\u578b\uff0c\u5c24\u5176\u5728\u5904\u7406\u975e\u591a\u9879\u5f0f\u590d\u6742\u5ea6\u7684\u60c5\u51b5\u4e0b\u66f4\u5177\u4f18\u52bf\u3002"}}
{"id": "2509.22699", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2509.22699", "abs": "https://arxiv.org/abs/2509.22699", "authors": ["Alessandra Urbinati", "Mirko Lai", "Simona Frenda", "Marco Antonio Stranisci"], "title": "Are you sure? Measuring models bias in content moderation through uncertainty", "comment": "accepted at Findings of ACL: EMNLP 2025", "summary": "Automatic content moderation is crucial to ensuring safety in social media.\nLanguage Model-based classifiers are being increasingly adopted for this task,\nbut it has been shown that they perpetuate racial and social biases. Even if\nseveral resources and benchmark corpora have been developed to challenge this\nissue, measuring the fairness of models in content moderation remains an open\nissue. In this work, we present an unsupervised approach that benchmarks models\non the basis of their uncertainty in classifying messages annotated by people\nbelonging to vulnerable groups. We use uncertainty, computed by means of the\nconformal prediction technique, as a proxy to analyze the bias of 11 models\nagainst women and non-white annotators and observe to what extent it diverges\nfrom metrics based on performance, such as the $F_1$ score. The results show\nthat some pre-trained models predict with high accuracy the labels coming from\nminority groups, even if the confidence in their prediction is low. Therefore,\nby measuring the confidence of models, we are able to see which groups of\nannotators are better represented in pre-trained models and lead the debiasing\nprocess of these models before their effective use.", "AI": {"tldr": "\u63d0\u51fa\u7528\u6a21\u578b\u7f6e\u4fe1\u5ea6\uff08\u4e0d\u786e\u5b9a\u6027\uff09\u4f5c\u4e3a\u8861\u91cf\u5185\u5bb9\u5ba1\u67e5\u6a21\u578b\u516c\u5e73\u6027\u7684\u65b0\u65b9\u6cd5\uff0c\u53d1\u73b0\u6a21\u578b\u5bf9\u5f31\u52bf\u7fa4\u4f53\u6807\u7b7e\u5373\u4f7f\u51c6\u786e\uff0c\u7f6e\u4fe1\u5ea6\u53ef\u80fd\u4e0d\u8db3\uff0c\u8fd9\u4e00\u5206\u6790\u6709\u52a9\u4e8e\u66f4\u597d\u5730\u53bb\u504f\u548c\u63d0\u5347\u516c\u5e73\u6027\u3002", "motivation": "\u81ea\u52a8\u5185\u5bb9\u5ba1\u67e5\u5bf9\u793e\u4ea4\u5a92\u4f53\u5b89\u5168\u81f3\u5173\u91cd\u8981\uff0c\u4f46\u8bed\u8a00\u6a21\u578b\u6613\u5728\u5185\u5bb9\u5ba1\u67e5\u4e2d\u5ef6\u7eed\u79cd\u65cf\u548c\u793e\u4f1a\u504f\u89c1\u3002\u73b0\u6709\u8d44\u6e90\u867d\u5c1d\u8bd5\u6311\u6218\u8be5\u95ee\u9898\uff0c\u4f46\u5982\u4f55\u8861\u91cf\u6a21\u578b\u516c\u5e73\u6027\u4ecd\u672a\u89e3\u51b3\u3002\u8be5\u7814\u7a76\u8bd5\u56fe\u63d0\u51fa\u66f4\u6709\u6548\u7684\u516c\u5e73\u6027\u8bc4\u4f30\u9014\u5f84\u3002", "method": "\u91c7\u7528\u65e0\u76d1\u7763\u65b9\u6cd5\uff0c\u4ee5\u5171\u5f62\u9884\u6d4b\u6280\u672f\u8ba1\u7b97\u6a21\u578b\u5bf9\u5c11\u6570\u7fa4\u4f53\uff08\u5973\u6027\u53ca\u975e\u767d\u4eba\uff09\u6ce8\u91ca\u6d88\u606f\u7684\u5206\u7c7b\u4e0d\u786e\u5b9a\u6027\uff08\u7f6e\u4fe1\u5ea6\uff09\uff0c\u5e76\u5206\u6790\u6a21\u578b\u7684\u504f\u89c1\u3002\u5c06\u8fd9\u79cd\u4e0d\u786e\u5b9a\u6027\u4f5c\u4e3a\u8861\u91cf\u516c\u5e73\u6027\u7684\u6307\u6807\uff0c\u4e0e\u4f20\u7edf\u7684\u6027\u80fd\u6307\u6807\uff08\u5982F1\u5206\u6570\uff09\u8fdb\u884c\u6bd4\u8f83\u3002", "result": "\u6709\u4e9b\u9884\u8bad\u7ec3\u6a21\u578b\u5bf9\u5c11\u6570\u7fa4\u4f53\u6807\u7b7e\u9884\u6d4b\u51c6\u786e\uff0c\u4f46\u7f6e\u4fe1\u5ea6\u5374\u5f88\u4f4e\u3002\u7ed3\u679c\u8868\u660e\uff0c\u901a\u8fc7\u7f6e\u4fe1\u5ea6\u8bc4\u4f30\uff0c\u53ef\u4ee5\u63ed\u793a\u6a21\u578b\u5728\u4e0d\u540c\u7fa4\u4f53\u4e0a\u7684\u4ee3\u8868\u4e0e\u504f\u89c1\uff0c\u6709\u5229\u4e8e\u540e\u7eed\u6a21\u578b\u53bb\u504f\u4e0e\u516c\u5e73\u4f18\u5316\u3002", "conclusion": "\u901a\u8fc7\u6d4b\u91cf\u6a21\u578b\u7684\u9884\u6d4b\u7f6e\u4fe1\u5ea6\uff0c\u53ef\u4ee5\u66f4\u597d\u5730\u4e86\u89e3\u54ea\u4e9b\u5f31\u52bf\u7fa4\u4f53\u5728\u9884\u8bad\u7ec3\u6a21\u578b\u4e2d\u7684\u4ee3\u8868\u6027\uff0c\u4ece\u800c\u5f15\u5bfc\u6a21\u578b\u53bb\u504f\u8fc7\u7a0b\uff0c\u4f7f\u5176\u5728\u5185\u5bb9\u5ba1\u67e5\u4efb\u52a1\u4e2d\u66f4\u516c\u5e73\u5730\u670d\u52a1\u4e8e\u4e0d\u540c\u7fa4\u4f53\u3002"}}
{"id": "2509.22908", "categories": ["cs.SE", "cs.LG", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.22908", "abs": "https://arxiv.org/abs/2509.22908", "authors": ["Sergiu Bursuc", "Theodore Ehrenborg", "Shaowei Lin", "Lacramioara Astefanoaei", "Ionel Emilian Chiosa", "Jure Kukovec", "Alok Singh", "Oliver Butterley", "Adem Bizid", "Quinn Dougherty", "Miranda Zhao", "Max Tan", "Max Tegmark"], "title": "A benchmark for vericoding: formally verified program synthesis", "comment": "25 pages, 1 figure; data available at\n  https://github.com/Beneficial-AI-Foundation/vericoding-benchmark", "summary": "We present and test the largest benchmark for vericoding, LLM-generation of\nformally verified code from formal specifications - in contrast to vibe coding,\nwhich generates potentially buggy code from a natural language description. Our\nbenchmark contains 12,504 formal specifications, with 3,029 in Dafny, 2,334 in\nVerus/Rust and 7,141 in Lean. Of these, 6,174 are new unseen problems. We find\nvericoding success rates of 27% in Lean, 44% in Verus/Rust and 82% in Dafny\nusing off-the-shelf LLMs. Adding natural-language descriptions does not\nsignificantly improve performance. We also find that LLM progress has improved\nprogress on pure Dafny verification from 68% to 96% over the past year. The\nbenchmark and vericoding results are shared at\nhttps://github.com/Beneficial-AI-Foundation/vericoding-benchmark", "AI": {"tldr": "\u8bba\u6587\u63d0\u51fa\u4e86\u6700\u5927\u89c4\u6a21\u7684vericoding\u57fa\u51c6\uff0c\u9a8c\u8bc1\u4e3b\u6d41LLM\u5728\u81ea\u52a8\u5f62\u5f0f\u5316\u4ee3\u7801\u751f\u6210\u4e0a\u7684\u80fd\u529b\uff0cDafny\u8868\u73b0\u6700\u4f73\uff0c\u5176\u4ed6\u4f53\u7cfb\u4ecd\u6709\u63d0\u5347\u7a7a\u95f4\uff0c\u516c\u5f00\u57fa\u51c6\u4fc3\u8fdb\u793e\u533a\u53d1\u5c55\u3002", "motivation": "\u8bba\u6587\u9488\u5bf9\u5f53\u524dLLM\u751f\u6210\u5f62\u5f0f\u5316\u9a8c\u8bc1\u4ee3\u7801\uff08vericoding\uff09\u7684\u9700\u6c42\uff0c\u63d0\u51fa\u548c\u6d4b\u8bd5\u8fc4\u4eca\u6700\u5927\u89c4\u6a21\u7684vericoding\u57fa\u51c6\uff0c\u7528\u4ee5\u533a\u522b\u4e8e\u751f\u6210\u53ef\u80fd\u542b\u6709bug\u7684\u4ee3\u7801\uff08vibe coding\uff09\u3002", "method": "\u6784\u5efa\u4e86\u5305\u542b12,504\u6761\u5f62\u5f0f\u5316\u89c4\u8303\u7684\u5927\u578b\u57fa\u51c6\u5e93\uff0c\u6db5\u76d6Dafny\u3001Verus/Rust\u3001Lean\u4e09\u79cd\u4f53\u7cfb\uff0c\u5e76\u5728\u4e3b\u6d41LLM\u4e0a\u8fdb\u884c\u5f62\u5f0f\u5316\u9a8c\u8bc1\u4ee3\u7801\u751f\u6210\u6d4b\u8bd5\u3002\u7edf\u8ba1\u4e0d\u540c\u8bed\u8a00\u4e0b\u7684\u6210\u529f\u7387\uff0c\u5e76\u63a2\u7a76\u81ea\u7136\u8bed\u8a00\u63cf\u8ff0\u5bf9\u7ed3\u679c\u7684\u5f71\u54cd\u3002", "result": "\u5728\u73b0\u6709LLM\u4e0b\uff0c\u4e0d\u540c\u4f53\u7cfb\u7684vericoding\u6210\u529f\u7387\u5206\u522b\u4e3aLean 27%\u3001Verus/Rust 44%\u3001Dafny 82%\uff1b\u81ea\u7136\u8bed\u8a00\u63cf\u8ff0\u5bf9\u6210\u529f\u7387\u63d0\u5347\u4e0d\u5927\u3002\u540c\u65f6Dafny\u7684\u9a8c\u8bc1\u7387\u5728\u4e00\u5e74\u5185\u753168%\u63d0\u5347\u81f396%\u3002\u5171\u6536\u5f556,174\u9053\u65b0\u95ee\u9898\u3002", "conclusion": "\u4e3b\u6d41LLM\u5df2\u80fd\u9ad8\u6548\u5b8c\u6210\u90e8\u5206\u5f62\u5f0f\u5316\u4ee3\u7801\u81ea\u52a8\u9a8c\u8bc1\uff0c\u4f46\u4e0d\u540c\u4f53\u7cfb\u8868\u73b0\u5dee\u5f02\u663e\u8457\uff0c\u81ea\u7136\u8bed\u8a00\u63cf\u8ff0\u63d0\u5347\u6709\u9650\u3002\u8bba\u8bc1\u4e86\u57fa\u51c6\u516c\u5f00\u5bf9\u63a8\u52a8\u9886\u57df\u8fdb\u6b65\u7684\u4ef7\u503c\u3002"}}
{"id": "2509.23739", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2509.23739", "abs": "https://arxiv.org/abs/2509.23739", "authors": ["Haniel Barbosa", "Christophe Ringeissen"], "title": "Proceedings Twentieth International Symposium on Logical and Semantic Frameworks with Applications", "comment": null, "summary": "This volume contains the proceedings of the 20th Workshop on Logical and\nSemantic Frameworks with Applications (LSFA 2025), which was held in Brasilia,\nthe capital of Brazil, from October 7 to October 8, 2025.\n  The aim of the LSFA series of workshops is bringing together theoreticians\nand practitioners to promote new techniques and results, from the theoretical\nside, and feedback on the implementation and use of such techniques and\nresults, from the practical side. LSFA includes areas such as proof and type\ntheory, equational deduction and rewriting systems, automated reasoning and\nconcurrency theory.", "AI": {"tldr": "LSFA 2025\u5728\u5df4\u897f\u5229\u4e9a\u53ec\u5f00\uff0c\u65e8\u5728\u7406\u8bba\u4e0e\u5b9e\u8df5\u7ed3\u5408\uff0c\u6db5\u76d6\u903b\u8f91\u548c\u8bed\u4e49\u6846\u67b6\u76f8\u5173\u591a\u9886\u57df\uff0c\u4fc3\u8fdb\u56fd\u9645\u4ea4\u6d41\u4e0e\u6280\u672f\u53d1\u5c55\u3002", "motivation": "\u8be5\u7814\u8ba8\u4f1a\u65e8\u5728\u63a8\u52a8\u903b\u8f91\u4e0e\u8bed\u4e49\u6846\u67b6\u9886\u57df\u7406\u8bba\u4e0e\u5b9e\u8df5\u7684\u7ed3\u5408\uff0c\u4fc3\u8fdb\u4ea4\u6d41\u4e0e\u5408\u4f5c\uff0c\u63d0\u5347\u7814\u7a76\u548c\u5e94\u7528\u6c34\u5e73\u3002", "method": "\u901a\u8fc7\u4f1a\u8bae\u8bba\u6587\u96c6\u5f62\u5f0f\uff0c\u6536\u5f55\u548c\u5c55\u793a\u4e86\u76f8\u5173\u9886\u57df\u7684\u6700\u65b0\u7406\u8bba\u6210\u679c\u4e0e\u5b9e\u9645\u5e94\u7528\u53cd\u9988\u3002", "result": "\u6210\u529f\u4e3e\u529e\u4e86\u7b2c20\u5c4a\u903b\u8f91\u4e0e\u8bed\u4e49\u6846\u67b6\u5e94\u7528\u7814\u8ba8\u4f1a\uff0c\u6c47\u96c6\u4e86\u8bc1\u660e\u4e0e\u7c7b\u578b\u7406\u8bba\u3001\u65b9\u7a0b\u63a8\u7406\u3001\u91cd\u5199\u7cfb\u7edf\u3001\u81ea\u52a8\u63a8\u7406\u548c\u5e76\u53d1\u7406\u8bba\u7b49\u9886\u57df\u7684\u6700\u65b0\u7814\u7a76\u3002", "conclusion": "\u672c\u8bba\u6587\u96c6\u901a\u8fc7\u4fc3\u8fdb\u7406\u8bba\u4e0e\u5b9e\u8df5\u7684\u4ea4\u6d41\uff0c\u63a8\u52a8\u4e86\u903b\u8f91\u548c\u8bed\u4e49\u6846\u67b6\u76f8\u5173\u9886\u57df\u7684\u53d1\u5c55\u3002"}}
{"id": "2509.23061", "categories": ["cs.PL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.23061", "abs": "https://arxiv.org/abs/2509.23061", "authors": ["Xu Xu", "Xin Li", "Xingwei Qu", "Jie Fu", "Binhang Yuan"], "title": "Local Success Does Not Compose: Benchmarking Large Language Models for Compositional Formal Verification", "comment": null, "summary": "We introduce DafnyCOMP, a benchmark for evaluating large language models\n(LLMs) on compositional specification generation in Dafny. Unlike prior\nbenchmarks that focus on single-function tasks, DafnyCOMP targets programs\ncomposed of multiple interacting functions with data dependencies, requiring\nreasoning across component boundaries. The benchmark consists of 300\nautomatically synthesized multi-function programs. We evaluate several\nstate-of-the-art LLM families and find that, while they perform well on\nsingle-function verification, their performance drops sharply on compositional\ntasks. Analysis reveals systematic failures in cross-functional reasoning,\nincluding fragile specifications, misalignment between implementations and\nproofs, and unstable reasoning. DafnyCOMP thus provides a diagnostic tool for\nmeasuring progress toward reliable, verifiable, and compositional code\ngeneration with LLMs.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86DafnyCOMP\u57fa\u51c6\uff0c\u4e13\u6ce8\u4e8e\u591a\u51fd\u6570\u7ec4\u5408\u89c4\u8303\u751f\u6210\u3002\u5b9e\u9a8c\u8868\u660e\uff0cLLM\u5728\u6b64\u7c7b\u4efb\u52a1\u4e0a\u8fdc\u900a\u4e8e\u5355\u51fd\u6570\u573a\u666f\uff0c\u5b58\u5728\u663e\u8457\u63a8\u7406\u74f6\u9888\u3002\u8be5\u57fa\u51c6\u6709\u52a9\u4e8e\u68c0\u6d4b\u548c\u63a8\u8fdbLLM\u5728\u9ad8\u9636\u4ee3\u7801\u7ec4\u5408\u53ca\u9a8c\u8bc1\u9886\u57df\u7684\u8fdb\u6b65\u3002", "motivation": "\u73b0\u6709\u7684\u8bc4\u6d4b\u57fa\u51c6\u4e3b\u8981\u5173\u6ce8\u4e8e\u5355\u4e00\u51fd\u6570\u4efb\u52a1\uff0c\u65e0\u6cd5\u5b8c\u6574\u8861\u91cf\u5927\u8bed\u8a00\u6a21\u578b\u5728\u591a\u51fd\u6570\u3001\u590d\u6742\u6570\u636e\u4f9d\u8d56\u548c\u8de8\u7ec4\u4ef6\u8fb9\u754c\u63a8\u7406\u4e0b\u7684\u8868\u73b0\u3002\u4e3a\u6b64\uff0c\u4f5c\u8005\u63d0\u51fa\u4e86\u65b0\u7684\u57fa\u51c6\u4ee5\u66f4\u597d\u8bca\u65ad\u548c\u8bc4\u4f30\u6a21\u578b\u5728\u7ec4\u5408\u6027\u89c4\u8303\u751f\u6210\u65b9\u9762\u7684\u80fd\u529b\u3002", "method": "\u63d0\u51fa\u4e86DafnyCOMP\u57fa\u51c6\uff0c\u5305\u62ec300\u4e2a\u81ea\u52a8\u5408\u6210\u7684\u591a\u51fd\u6570\u7a0b\u5e8f\u3002\u5229\u7528\u8be5\u57fa\u51c6\u8bc4\u4f30\u4e86\u591a\u79cd\u4e3b\u6d41LLM\u6a21\u578b\uff0c\u5728\u7ec4\u5408\u6027\u89c4\u8303\u751f\u6210\u4efb\u52a1\u4e0a\u8fdb\u884c\u7cfb\u7edf\u6027\u5206\u6790\u3002", "result": "\u7ed3\u679c\u663e\u793a\uff0c\u73b0\u6709LLM\u5728\u5355\u51fd\u6570\u9a8c\u8bc1\u4efb\u52a1\u4e0a\u8868\u73b0\u826f\u597d\uff0c\u4f46\u5728\u591a\u51fd\u6570\u590d\u6742\u7ec4\u5408\u4efb\u52a1\u4e0a\u7684\u8868\u73b0\u6025\u5267\u4e0b\u964d\uff0c\u5c24\u5176\u662f\u5728\u8de8\u51fd\u6570\u63a8\u7406\u65b9\u9762\u5b58\u5728\u7cfb\u7edf\u6027\u5931\u8d25\uff0c\u4f53\u73b0\u5728\u89c4\u8303\u8106\u5f31\u3001\u5b9e\u73b0\u4e0e\u8bc1\u660e\u4e0d\u4e00\u81f4\u7b49\u65b9\u9762\u3002", "conclusion": "DafnyCOMP\u57fa\u51c6\u80fd\u591f\u4f5c\u4e3a\u8bca\u65ad\u5de5\u5177\uff0c\u5408\u7406\u63ed\u793a\u5f53\u524dLLM\u5728\u7ec4\u5408\u6027\u4ee3\u7801\u751f\u6210\u65b9\u9762\u7684\u4e0d\u8db3\uff0c\u63a8\u52a8\u6a21\u578b\u5411\u9ad8\u53ef\u9760\u3001\u53ef\u9a8c\u8bc1\u3001\u53ef\u7ec4\u5408\u65b9\u5411\u53d1\u5c55\u3002"}}
{"id": "2509.22703", "categories": ["cs.CL", "cs.AI", "cs.CY"], "pdf": "https://arxiv.org/pdf/2509.22703", "abs": "https://arxiv.org/abs/2509.22703", "authors": ["Srikant Panda", "Amit Agarwal", "Hitesh Laxmichand Patel"], "title": "AccessEval: Benchmarking Disability Bias in Large Language Models", "comment": null, "summary": "Large Language Models (LLMs) are increasingly deployed across diverse domains\nbut often exhibit disparities in how they handle real-life queries. To\nsystematically investigate these effects within various disability contexts, we\nintroduce \\textbf{AccessEval (Accessibility Evaluation)}, a benchmark\nevaluating 21 closed- and open-source LLMs across 6 real-world domains and 9\ndisability types using paired Neutral and Disability-Aware Queries. We\nevaluated model outputs with metrics for sentiment, social perception, and\nfactual accuracy.\n  Our analysis reveals that responses to disability-aware queries tend to have\na more negative tone, increased stereotyping, and higher factual error compared\nto neutral queries. These effects show notable variation by domain and\ndisability type, with disabilities affecting hearing, speech, and mobility\ndisproportionately impacted. These disparities reflect persistent forms of\nableism embedded in model behavior.\n  By examining model performance in real-world decision-making contexts, we\nbetter illuminate how such biases can translate into tangible harms for\ndisabled users. This framing helps bridges the gap between technical evaluation\nand user impact, reinforcing importance of bias mitigation in day-to-day\napplications. Our dataset is publicly available at:\nhttps://huggingface.co/datasets/Srikant86/AccessEval", "AI": {"tldr": "AccessEval\u57fa\u51c6\u63ed\u793a\u4e86\u4e3b\u6d41\u5927\u8bed\u8a00\u6a21\u578b\u5728\u56de\u7b54\u6b8b\u969c\u76f8\u5173\u95ee\u9898\u65f6\u8868\u73b0\u51fa\u8d1f\u9762\u60c5\u611f\u3001\u523b\u677f\u5370\u8c61\u548c\u4e8b\u5b9e\u9519\u8bef\uff0c\u5f71\u54cd\u7279\u5b9a\u6b8b\u969c\u7fa4\u4f53\uff0c\u5f3a\u8c03\u5728\u6280\u672f\u5b9e\u9645\u5e94\u7528\u4e2d\u9700\u5173\u6ce8\u5e76\u7f13\u89e3\u6a21\u578b\u504f\u89c1\u3002\u6570\u636e\u96c6\u5df2\u5f00\u653e\u3002", "motivation": "\u5927\u8bed\u8a00\u6a21\u578b\uff08LLM\uff09\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u88ab\u5e7f\u6cdb\u90e8\u7f72\uff0c\u4f46\u5bf9\u73b0\u5b9e\u751f\u6d3b\u4e2d\u7684\u67e5\u8be2\u8868\u73b0\u51fa\u5dee\u5f02\uff0c\u5c24\u5176\u5728\u6b8b\u969c\u7fa4\u4f53\u7684\u60c5\u5883\u4e0b\u7f3a\u4e4f\u7cfb\u7edf\u6027\u8bc4\u4f30\u3002\u56e0\u6b64\uff0c\u4f5c\u8005\u5e0c\u671b\u7cfb\u7edf\u6027\u5206\u6790LLM\u5728\u4e0d\u540c\u6b8b\u969c\u7c7b\u578b\u548c\u9886\u57df\u4e2d\u7684\u8868\u73b0\u5dee\u5f02\u53ca\u6f5c\u5728\u504f\u89c1\u3002", "method": "\u4f5c\u8005\u63d0\u51fa\u4e86AccessEval\u8fd9\u4e00\u57fa\u51c6\uff0c\u4f7f\u7528\u4e2d\u6027\u548c\u6b8b\u969c\u610f\u8bc6\u67e5\u8be2\u5bf921\u79cd\u95ed\u6e90\u548c\u5f00\u6e90LLM\u8fdb\u884c\u8bc4\u6d4b\uff0c\u6db5\u76d66\u4e2a\u73b0\u5b9e\u9886\u57df\u548c9\u79cd\u6b8b\u969c\u7c7b\u578b\u3002\u8bc4\u4f30\u6307\u6807\u5305\u62ec\u60c5\u611f\u503e\u5411\u3001\u793e\u4f1a\u8ba4\u77e5\u3001\u4e8b\u5b9e\u51c6\u786e\u6027\u3002", "result": "\u5206\u6790\u53d1\u73b0\uff0c\u9488\u5bf9\u6b8b\u969c\u76f8\u5173\u67e5\u8be2\uff0cLLM\u56de\u5e94\u666e\u904d\u66f4\u4e3a\u8d1f\u9762\uff0c\u5b58\u5728\u66f4\u591a\u523b\u677f\u5370\u8c61\u548c\u4e8b\u5b9e\u9519\u8bef\uff0c\u7279\u522b\u5728\u542c\u529b\u3001\u8bed\u8a00\u548c\u884c\u52a8\u6b8b\u969c\u7528\u6237\u7fa4\u4f53\u5f71\u54cd\u66f4\u660e\u663e\u3002\u8fd9\u4e9b\u8d1f\u9762\u6548\u5e94\u56e0\u9886\u57df\u548c\u6b8b\u969c\u7c7b\u578b\u6709\u6240\u4e0d\u540c\uff0c\u53cd\u6620\u4e86\u6a21\u578b\u884c\u4e3a\u4e2d\u7684\u7cfb\u7edf\u6027\u6b8b\u969c\u6b67\u89c6\u3002", "conclusion": "\u4f5c\u8005\u901a\u8fc7\u73b0\u5b9e\u51b3\u7b56\u573a\u666f\u8003\u5bdfLLM\uff0c\u63ed\u793a\u6a21\u578b\u504f\u89c1\u4f1a\u5bf9\u6b8b\u969c\u7528\u6237\u9020\u6210\u5b9e\u9645\u4f24\u5bb3\uff0c\u5f3a\u8c03\u65e5\u5e38\u5e94\u7528\u4e2d\u6d88\u9664\u504f\u89c1\u7684\u91cd\u8981\u6027\u3002\u516c\u5f00\u4e86\u6570\u636e\u96c6\u4ee5\u652f\u6301\u8fdb\u4e00\u6b65\u7814\u7a76\u3002"}}
{"id": "2509.22978", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.22978", "abs": "https://arxiv.org/abs/2509.22978", "authors": ["Teeradaj Racharak", "Chaiyong Ragkhitwetsagul", "Chayanee Junplong", "Akara Supratak"], "title": "Towards Human-interpretable Explanation in Code Clone Detection using LLM-based Post Hoc Explainer", "comment": null, "summary": "Recent studies highlight various machine learning (ML)-based techniques for\ncode clone detection, which can be integrated into developer tools such as\nstatic code analysis. With the advancements brought by ML in code\nunderstanding, ML-based code clone detectors could accurately identify and\nclassify cloned pairs, especially semantic clones, but often operate as black\nboxes, providing little insight into the decision-making process. Post hoc\nexplainers, on the other hand, aim to interpret and explain the predictions of\nthese ML models after they are made, offering a way to understand the\nunderlying mechanisms driving the model's decisions. However, current post hoc\ntechniques require white-box access to the ML model or are computationally\nexpensive, indicating a need for advanced post hoc explainers. In this paper,\nwe propose a novel approach that leverages the in-context learning capabilities\nof large language models to elucidate the predictions made by the ML-based code\nclone detectors. We perform a study using ChatGPT-4 to explain the code clone\nresults inferred by GraphCodeBERT. We found that our approach is promising as a\npost hoc explainer by giving the correct explanations up to 98% and offering\ngood explanations 95% of the time. However, the explanations and the code line\nexamples given by the LLM are useful in some cases. We also found that lowering\nthe temperature to zero helps increase the accuracy of the explanation. Lastly,\nwe list the insights that can lead to further improvements in future work. This\nstudy paves the way for future studies in using LLMs as a post hoc explainer\nfor various software engineering tasks.", "AI": {"tldr": "\u672c\u7814\u7a76\u63d0\u51fa\u7528\u5927\u8bed\u8a00\u6a21\u578b\u4f5c\u4e3a\u4ee3\u7801\u514b\u9686\u68c0\u6d4b\u5668\u7684\u540e\u7f6e\u89e3\u91ca\u5668\uff0c\u4f7f\u7528ChatGPT-4\u5bf9GraphCodeBERT\u8f93\u51fa\u7ed3\u679c\u8fdb\u884c\u89e3\u91ca\uff0c\u53d6\u5f97\u9ad8\u51c6\u786e\u7387\u548c\u5b9e\u7528\u6027\uff0c\u5e76\u603b\u7ed3\u4e86\u53ef\u4f9b\u672a\u6765\u4f18\u5316\u7684\u542f\u793a\u3002", "motivation": "\u5f53\u524dML-based\u4ee3\u7801\u514b\u9686\u68c0\u6d4b\u5668\u867d\u80fd\u51c6\u786e\u8bc6\u522b\u8bed\u4e49\u514b\u9686\uff0c\u4f46\u51b3\u7b56\u8fc7\u7a0b\u4e0d\u900f\u660e\uff0c\u4e14\u73b0\u6709\u540e\u7f6e\u89e3\u91ca\u5de5\u5177\u4f9d\u8d56\u767d\u76d2\u8bbf\u95ee\u6216\u8ba1\u7b97\u6210\u672c\u9ad8\uff0c\u4e9f\u9700\u9ad8\u6548\u7684\u65b0\u578b\u540e\u7f6e\u89e3\u91ca\u65b9\u6cd5\u3002", "method": "\u7814\u7a76\u901a\u8fc7\u4f7f\u7528ChatGPT-4\u89e3\u91ca\u7531GraphCodeBERT\u68c0\u6d4b\u51fa\u7684\u4ee3\u7801\u514b\u9686\u7ed3\u679c\uff0c\u8bc4\u4f30LLM\u5728\u89e3\u91ca\u51c6\u786e\u6027\u548c\u5b9e\u7528\u6027\u4e0a\u7684\u8868\u73b0\u3002\u5b9e\u9a8c\u8fd8\u5206\u6790LLM\u53c2\u6570\uff08\u5982temperature\u503c\uff09\u7684\u8c03\u6574\u5bf9\u89e3\u91ca\u6548\u679c\u7684\u5f71\u54cd\u3002", "result": "\u63d0\u51fa\u7684LLM\u89e3\u91ca\u65b9\u6cd5\u51c6\u786e\u7387\u9ad8\u8fbe98%\uff0c\u89e3\u91ca\u8d28\u91cf\u8fbe\u523095%\u3002\u90e8\u5206\u60c5\u51b5\u4e0bLLM\u751f\u6210\u7684\u89e3\u91ca\u548c\u4ee3\u7801\u4f8b\u5b50\u975e\u5e38\u6709\u7528\uff0c\u8c03\u6574\u53c2\u6570\uff08\u5982temperature\uff09\u6709\u52a9\u4e8e\u63d0\u5347\u89e3\u91ca\u51c6\u786e\u6027\uff0c\u5e76\u63d0\u51fa\u672a\u6765\u6539\u8fdb\u65b9\u5411\u3002", "conclusion": "\u5229\u7528\u5927\u8bed\u8a00\u6a21\u578b\uff08LLM\uff09\u901a\u8fc7\u4e0a\u4e0b\u6587\u5b66\u4e60\u673a\u5236\u4e3a\u673a\u5668\u5b66\u4e60\u4ee3\u7801\u514b\u9686\u68c0\u6d4b\u5668\u63d0\u4f9b\u540e\u7f6e\u89e3\u91ca\u662f\u53ef\u884c\u4e14\u6709\u6548\u7684\u65b9\u6cd5\u3002\u7efc\u5408\u6027\u80fd\u8868\u73b0\u4f18\u5f02\uff0c\u80fd\u591f\u89e3\u91ca\u4ee3\u7801\u514b\u9686\u7ed3\u679c\uff0c\u5e76\u5bf9\u672a\u6765\u76f8\u5173\u7814\u7a76\u63d0\u4f9b\u6307\u5bfc\u3002"}}
{"id": "2509.24583", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2509.24583", "abs": "https://arxiv.org/abs/2509.24583", "authors": ["Jean Christoph Jung", "J\u0119drzej Ko\u0142odziejski"], "title": "The Complexity of Defining and Separating Fixpoint Formulae in Modal Logic", "comment": null, "summary": "Modal separability for modal fixpoint formulae is the problem to decide for\ntwo given modal fixpoint formulae $\\varphi,\\varphi'$ whether there is a modal\nformula $\\psi$ that separates them, in the sense that $\\varphi\\models\\psi$ and\n$\\psi\\models\\neg\\varphi'$. We study modal separability and its special case\nmodal definability over various classes of models, such as arbitrary models,\nfinite models, trees, and models of bounded outdegree. Our main results are\nthat modal separability is PSpace-complete over words, that is, models of\noutdegree $\\leq 1$, ExpTime-complete over unrestricted and over binary models,\nand TwoExpTime-complete over models of outdegree bounded by some $d\\geq 3$.\nInterestingly, this latter case behaves fundamentally different from the other\ncases also in that modal logic does not enjoy the Craig interpolation property\nover this class. Motivated by this we study also the induced interpolant\nexistence problem as a special case of modal separability, and show that it is\ncoNExpTime-complete and thus harder than validity in the logic. Besides\ndeciding separability, we also provide algorithms for the effective\nconstruction of separators. Finally, we consider in a case study the extension\nof modal fixpoint formulae by graded modalities and investigate separability by\nmodal formulae and graded modal formulae.", "AI": {"tldr": "\u8be5\u8bba\u6587\u7cfb\u7edf\u5206\u6790\u4e86\u6a21\u6001\u4e0d\u52a8\u70b9\u903b\u8f91\u516c\u5f0f\u7684\u53ef\u5206\u6027\u3001\u53ef\u63d2\u503c\u6027\u53ca\u5176\u590d\u6742\u5ea6\uff0c\u5e76\u5bf9\u5206\u79bb\u5668\u6784\u9020\u4e0e\u63a8\u5e7f\u505a\u4e86\u8be6\u7ec6\u8ba8\u8bba\uff0c\u5bf9\u76f8\u5173\u903b\u8f91\u548c\u81ea\u52a8\u5316\u63a8\u7406\u7406\u8bba\u5177\u6709\u91cd\u8981\u610f\u4e49\u3002", "motivation": "\u6a21\u6001\u4e0d\u52a8\u70b9\u903b\u8f91\u5728\u7406\u8bba\u8ba1\u7b97\u673a\u79d1\u5b66\u6709\u91cd\u8981\u5e94\u7528\uff0c\u4e86\u89e3\u6a21\u6001\u516c\u5f0f\u4e4b\u95f4\u662f\u5426\u53ef\u4ee5\u901a\u8fc7\u66f4\u7b80\u5355\u516c\u5f0f\u5206\u79bb\u53ca\u5176\u590d\u6742\u5ea6\uff0c\u6709\u52a9\u4e8e\u7406\u8bba\u7814\u7a76\u4e0e\u76f8\u5173\u81ea\u52a8\u5316\u5de5\u5177\u7684\u5f00\u53d1\u3002\u7279\u522b\u5730\uff0c\u4e0d\u540c\u6a21\u578b\u7ed3\u6784\u4e0b\u95ee\u9898\u6027\u8d28\u53ef\u80fd\u6709\u6839\u672c\u6027\u5dee\u5f02\uff0c\u503c\u5f97\u7cfb\u7edf\u7814\u7a76\u3002", "method": "\u57fa\u4e8e\u590d\u6742\u6027\u7406\u8bba\u548c\u6a21\u6001\u903b\u8f91\uff0c\u4f5c\u8005\u5728\u4e0d\u540c\u6a21\u578b\u7c7b\u522b\uff08\u5982\u6709\u754c\u51fa\u5ea6\u3001\u4efb\u610f\u6a21\u578b\u3001\u4e8c\u53c9\u6811\u3001\u5b57\u6a21\u578b\uff09\u4e0b\u901a\u8fc7\u7406\u8bba\u8bc1\u660e\u5206\u6790\u4e86\u6a21\u6001\u53ef\u5206\u6027\u4e0e\u53ef\u63d2\u503c\u6027\u95ee\u9898\u7684\u5224\u5b9a\u590d\u6742\u5ea6\u3002\u540c\u65f6\u63d0\u4f9b\u4e86\u6784\u9020\u5206\u79bb\u516c\u5f0f\u7684\u7b97\u6cd5\uff0c\u5e76\u901a\u8fc7\u6269\u5c55\u6848\u4f8b\u5206\u6790\u63a2\u8ba8\u4e86\u66f4\u4e00\u822c\u60c5\u5f62\u4e0b\u7684\u5206\u79bb\u95ee\u9898\u3002", "result": "\u4e3b\u8981\u7ed3\u679c\u4e3a\uff1a\uff081\uff09\u51fa\u5ea6\u22641\u7684\u6a21\u578b\uff08words\uff09\u4e0b\u5206\u79bb\u95ee\u9898\u4e3aPSpace-complete\uff1b\uff082\uff09\u4efb\u610f\u548c\u4e8c\u53c9\u6a21\u578b\u4e0b\u4e3aExpTime-complete\uff1b\uff083\uff09\u51fa\u5ea6\u6709\u7a77\u4e14\u22653\u65f6\u4e3aTwoExpTime-complete\uff0c\u5e76\u4e14\u5728\u8be5\u60c5\u5f62\u4e0bCraig\u63d2\u503c\u6027\u8d28\u5931\u6548\uff1b\uff084\uff09\u63d2\u503c\u5b58\u5728\u6027\u95ee\u9898\u4e3acoNExpTime-complete\uff0c\u6bd4\u666e\u901a\u6709\u6548\u6027\u5224\u5b9a\u66f4\u590d\u6742\uff1b\uff085\uff09\u7ed9\u51fa\u4e86\u5206\u79bb\u5668\u6709\u6548\u6784\u9020\u7b97\u6cd5\u53ca\u5e26\u7ea7\u6570\u7b97\u5b50\u7684\u63a8\u5e7f\u6848\u4f8b\u3002", "conclusion": "\u8bba\u6587\u5168\u9762\u7814\u7a76\u4e86\u6a21\u6001\u4e0d\u52a8\u70b9\u516c\u5f0f\u7684\u53ef\u5206\u6027\u53ca\u5176\u7279\u6b8a\u60c5\u5f62\u4e0b\u7684\u53ef\u5b9a\u4e49\u6027\uff0c\u5206\u522b\u7ed9\u51fa\u4e86\u4e0d\u540c\u6a21\u578b\u7c7b\u522b\u4e0b\u8be5\u95ee\u9898\u7684\u590d\u6742\u5ea6\uff0c\u5e76\u6307\u51fa\u90e8\u5206\u60c5\u5f62\u4e0bCraig\u63d2\u503c\u6027\u8d28\u7684\u5931\u6548\u53ca\u63d2\u503c\u5b58\u5728\u6027\u95ee\u9898\u7684\u590d\u6742\u5ea6\u66f4\u9ad8\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u8fd8\u7ed9\u51fa\u4e86\u7528\u4e8e\u6709\u6548\u6784\u9020\u5206\u79bb\u516c\u5f0f\u7684\u7b97\u6cd5\uff0c\u5e76\u63a2\u8ba8\u4e86\u63a8\u5e7f\u5230\u5e26\u6709\u7ea7\u6570\u6a21\u6001\u7b97\u5b50\u7684\u60c5\u5f62\u3002"}}
{"id": "2509.23229", "categories": ["cs.PL", "D.2.4; F.3.1"], "pdf": "https://arxiv.org/pdf/2509.23229", "abs": "https://arxiv.org/abs/2509.23229", "authors": ["Yawen Guan", "Cl\u00e9ment Pit-Claudel"], "title": "Fine-Grained Reasoning About Container-Internal Pointers with Logical Pinning", "comment": null, "summary": "Most separation logics hide container-internal pointers for modularity. This\nmakes it difficult to specify container APIs that temporarily expose those\npointers to the outside, and to verify programs that use these APIs. We present\nlogical pinning, a lightweight borrowing model for sequential programs that\nallows users to selectively track container-internal pointers at the logical\nlevel. Our model generalizes the magic-wand operator, making it easy to write\nand prove precise specifications, including pointer-stability properties.\nBecause it only changes how representation predicates and specifications are\nwritten, our approach is compatible with most separation logic variants. We\ndemonstrate the practicality of logical pinning by verifying small but\nrepresentative pointer-manipulating programs, and deriving more precise\nversions of common container specifications. In doing so, we show that our\napproach subsumes some well-known proof patterns, simplifies some complex\nproofs, and enables reasoning about program patterns not supported by\ntraditional specifications. All of our results are mechanized in the Rocq proof\nassistant, using the CFML library.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u5206\u79bb\u903b\u8f91\u6269\u5c55\u65b9\u6cd5\uff0c\u4f7f\u5bb9\u5668\u5185\u90e8\u6307\u9488\u7684\u4e34\u65f6\u66b4\u9732\u53ef\u4ee5\u88ab\u7cbe\u786e\u89c4\u8303\u548c\u9a8c\u8bc1\uff0c\u8be5\u65b9\u6cd5\u517c\u5bb9\u5f53\u524d\u4e3b\u6d41\u5206\u79bb\u903b\u8f91\uff0c\u7b80\u5316\u8bc1\u660e\u8fc7\u7a0b\u3001\u62d3\u5c55\u9002\u7528\u573a\u666f\uff0c\u5e76\u5df2\u5728\u5b9e\u9645\u5de5\u5177\u4e2d\u5b9e\u73b0\u3002", "motivation": "\u5927\u591a\u6570\u5206\u79bb\u903b\u8f91\u4e3a\u4e86\u6a21\u5757\u5316\uff0c\u4f1a\u9690\u85cf\u5bb9\u5668\u5185\u90e8\u6307\u9488\uff0c\u8fd9\u5bfc\u81f4\u5728API\u9700\u8981\u4e34\u65f6\u66b4\u9732\u8fd9\u4e9b\u6307\u9488\u65f6\u96be\u4ee5\u63cf\u8ff0\u548c\u9a8c\u8bc1\u4f7f\u7528\u8fd9\u4e9b\u63a5\u53e3\u7684\u7a0b\u5e8f\u3002\u4f5c\u8005\u5e0c\u671b\u89e3\u51b3\u8fd9\u4e2a\u75db\u70b9\uff0c\u5b9e\u73b0\u66f4\u7075\u6d3b\u548c\u7cbe\u786e\u7684\u5bb9\u5668\u63a5\u53e3\u89c4\u8303\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u903b\u8f91\u9501\u5b9a\uff08logical pinning\uff09\u65b9\u6cd5\uff0c\u662f\u8f7b\u91cf\u7ea7\u7684\u501f\u7528\u6a21\u578b\uff0c\u53ef\u4ee5\u5728\u903b\u8f91\u5c42\u9762\u9009\u62e9\u6027\u5730\u8ddf\u8e2a\u5bb9\u5668\u5185\u90e8\u6307\u9488\uff0c\u5e76\u5c06\u5176\u63a8\u5e7f\u5230magic-wand\u64cd\u4f5c\u7b26\uff0c\u4ece\u800c\u66f4\u5bb9\u6613\u7f16\u5199\u548c\u8bc1\u660e\u5c5e\u6027\u3002\u8be5\u65b9\u6cd5\u6539\u53d8\u4e86\u8868\u793a\u8c13\u8bcd\u548c\u89c4\u8303\u7684\u5199\u6cd5\uff0c\u4f46\u4e0e\u5927\u591a\u6570\u5206\u79bb\u903b\u8f91\u53d8\u79cd\u517c\u5bb9\u3002", "result": "\u5229\u7528\u8be5\u65b9\u6cd5\u9a8c\u8bc1\u4e86\u4e00\u4e9b\u5178\u578b\u7684\u6307\u9488\u64cd\u4f5c\u7a0b\u5e8f\uff0c\u5e76\u66f4\u7cbe\u786e\u5730\u63a8\u5bfc\u51fa\u5bb9\u5668\u89c4\u8303\u3002\u7ed3\u679c\u663e\u793a\uff1a\u903b\u8f91\u9501\u5b9a\u65b9\u6cd5\u53ef\u4ee5\u6db5\u76d6\u4e00\u4e9b\u8457\u540d\u7684\u8bc1\u660e\u6a21\u5f0f\u3001\u7b80\u5316\u90e8\u5206\u590d\u6742\u8bc1\u660e\uff0c\u8fd8\u80fd\u652f\u6301\u4f20\u7edf\u89c4\u8303\u4e0d\u652f\u6301\u7684\u7a0b\u5e8f\u6a21\u5f0f\u3002\u6240\u6709\u7ed3\u679c\u5747\u5728Rocq\u8bc1\u660e\u52a9\u624b\u548cCFML\u5e93\u4e2d\u5b9e\u73b0\u3002", "conclusion": "\u903b\u8f91\u9501\u5b9a\u4e3a\u5206\u79bb\u903b\u8f91\u4e2d\u7684\u5bb9\u5668\u6307\u9488\u66b4\u9732\u95ee\u9898\u63d0\u4f9b\u4e86\u901a\u7528\u4e14\u8f7b\u91cf\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u63d0\u5347\u4e86\u89c4\u8303\u7cbe\u5ea6\u548c\u53ef\u9a8c\u8bc1\u6027\uff0c\u540c\u65f6\u5177\u5907\u8f83\u5f3a\u7684\u5b9e\u8df5\u517c\u5bb9\u6027\u548c\u53ef\u6269\u5c55\u6027\u3002"}}
{"id": "2509.22713", "categories": ["cs.CL"], "pdf": "https://arxiv.org/pdf/2509.22713", "abs": "https://arxiv.org/abs/2509.22713", "authors": ["Kaishuai Xu", "Wenjun Hou", "Yi Cheng", "Wenjie Li"], "title": "RAR$^2$: Retrieval-Augmented Medical Reasoning via Thought-Driven Retrieval", "comment": "Accepted by EMNLP 2025 Findings", "summary": "Large Language Models (LLMs) have shown promising performance on diverse\nmedical benchmarks, highlighting their potential in supporting real-world\nclinical tasks. Retrieval-Augmented Generation (RAG) has emerged as a key\napproach for mitigating knowledge gaps and hallucinations by incorporating\nexternal medical information. However, RAG still struggles with complex medical\nquestions that require intensive reasoning, as surface-level input often fails\nto reflect the true knowledge needs of the task. Existing methods typically\nfocus on refining queries without explicitly modeling the reasoning process,\nlimiting their ability to retrieve and integrate clinically relevant knowledge.\nIn this work, we propose RAR$^2$, a joint learning framework that improves both\nReasoning-Augmented Retrieval and Retrieval-Augmented Reasoning. RAR$^2$\nconstructs a thought process to uncover implicit knowledge requirements and\nuses it to guide retrieval and answer generation. We build a training dataset\nof mixed preference pairs and apply Direct Preference Optimization (DPO) to\ntrain the model. Moreover, we design two test-time scaling strategies to\nexplore the boundaries of our framework. Experiments demonstrate the\neffectiveness of RAR$^2$ across several biomedical question answering datasets,\noutperforming RAG baselines with or without fine-tuning.", "AI": {"tldr": "\u4f5c\u8005\u63d0\u51fa\u4e86RAR$^2$\u6846\u67b6\uff0c\u5c06\u63a8\u7406\u4e0e\u68c0\u7d22\u4e92\u76f8\u589e\u5f3a\uff0c\u6709\u6548\u89e3\u51b3\u590d\u6742\u533b\u5b66\u95ee\u7b54\u4e2d\u7684\u77e5\u8bc6\u9700\u6c42\u548c\u63a8\u7406\u74f6\u9888\uff0c\u901a\u8fc7Direct Preference Optimization\u8fdb\u884c\u8bad\u7ec3\uff0c\u5728\u591a\u7ec4\u533b\u5b66\u95ee\u7b54\u6570\u636e\u96c6\u4e0a\u5747\u53d6\u5f97\u4e86\u6bd4RAG\u57fa\u7ebf\u66f4\u597d\u7684\u8868\u73b0\u3002", "motivation": "RAG\u867d\u7136\u80fd\u901a\u8fc7\u5916\u90e8\u77e5\u8bc6\u589e\u5f3a\u56de\u7b54\uff0c\u51cf\u5c11\u5e7b\u89c9\u548c\u77e5\u8bc6\u7a7a\u767d\uff0c\u4f46\u9762\u5bf9\u590d\u6742\u533b\u5b66\u95ee\u9898\u65f6\uff0c\u5355\u7eaf\u8f93\u5165\u4e0d\u8db3\u4ee5\u6ee1\u8db3\u5fb7\u6027\u5316\u77e5\u8bc6\u9700\u6c42\u3002\u73b0\u6709\u65b9\u6cd5\u591a\u96c6\u4e2d\u4e8e\u7cbe\u5316\u67e5\u8be2\uff0c\u7f3a\u4e4f\u5bf9\u63a8\u7406\u8fc7\u7a0b\u7684\u663e\u5f0f\u5efa\u6a21\uff0c\u9650\u5236\u4e86\u83b7\u53d6\u548c\u6574\u5408\u4e34\u5e8a\u76f8\u5173\u77e5\u8bc6\u7684\u80fd\u529b\u3002", "method": "\u63d0\u51faRAR$^2$\uff0c\u7ed3\u5408Reasoning-Augmented Retrieval\u548cRetrieval-Augmented Reasoning\u7684\u8054\u5408\u5b66\u4e60\u6846\u67b6\u3002\u5168\u6d41\u7a0b\u5305\u62ec\u6784\u5efa\u601d\u7ef4\u8fc7\u7a0b\u4ee5\u63ed\u793a\u9690\u6027\u77e5\u8bc6\u9700\u6c42\uff0c\u6307\u5bfc\u68c0\u7d22\u548c\u7b54\u6848\u751f\u6210\uff0c\u5e76\u901a\u8fc7\u6df7\u5408\u504f\u597d\u5bf9\u548cDirect Preference Optimization\u8fdb\u884c\u6a21\u578b\u8bad\u7ec3\uff0c\u8fd8\u8bbe\u8ba1\u4e86\u4e24\u79cd\u6d4b\u8bd5\u65f6\u6269\u5c55\u7b56\u7565\u3002", "result": "RAR$^2$\u80fd\u66f4\u597d\u5730\u53d1\u73b0\u548c\u6ee1\u8db3\u9690\u6027\u77e5\u8bc6\u9700\u6c42\uff0c\u5e76\u6709\u6548\u63d0\u5347\u533b\u5b66\u95ee\u7b54\u7684\u63a8\u7406\u4e0e\u68c0\u7d22\u80fd\u529b\uff0c\u5728\u591a\u4e2a\u6570\u636e\u96c6\u4e0a\u6548\u679c\u4f18\u5f02\uff0c\u4f18\u4e8e\u5e38\u89c4RAG\u65b9\u6cd5\u3002", "conclusion": "RAR$^2$\u6846\u67b6\u5728\u591a\u4e2a\u751f\u7269\u533b\u5b66\u95ee\u7b54\u6570\u636e\u96c6\u4e0a\u8868\u73b0\u4f18\u5f02\uff0c\u8d85\u8d8a\u4e86RAG\u57fa\u7ebf\u65b9\u6cd5\uff0c\u65e0\u8bba\u662f\u5426\u8fdb\u884c\u5fae\u8c03\u3002"}}
{"id": "2509.23261", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.23261", "abs": "https://arxiv.org/abs/2509.23261", "authors": ["Fei Gu", "Zi Liang", "Hongzong LI", "Jiahao MA"], "title": "The Matthew Effect of AI Programming Assistants: A Hidden Bias in Software Evolution", "comment": null, "summary": "AI-assisted programming is rapidly reshaping software development, with large\nlanguage models (LLMs) enabling new paradigms such as vibe coding and agentic\ncoding. While prior works have focused on prompt design and code generation\nquality, the broader impact of LLM-driven development on the iterative dynamics\nof software engineering remains underexplored. In this paper, we conduct\nlarge-scale experiments on thousands of algorithmic programming tasks and\nhundreds of framework selection tasks to systematically investigate how\nAI-assisted programming interacts with the software ecosystem. Our analysis\nreveals \\textbf{a striking Matthew effect: the more popular a programming\nlanguage or framework, the higher the success rate of LLM-generated code}. The\nphenomenon suggests that AI systems may reinforce existing popularity\nhierarchies, accelerating convergence around dominant tools while hindering\ndiversity and innovation. We provide a quantitative characterization of this\neffect and discuss its implications for the future evolution of programming\necosystems.", "AI": {"tldr": "AI\u8f85\u52a9\u7f16\u7a0b\u66f4\u503e\u5411\u4e8e\u652f\u6301\u70ed\u95e8\u8bed\u8a00\u548c\u6846\u67b6\uff0c\u8fd9\u5c06\u52a0\u5267\u4e3b\u6d41\u5de5\u5177\u7684\u96c6\u4e2d\uff0c\u964d\u4f4e\u7f16\u7a0b\u751f\u6001\u7684\u591a\u6837\u6027\u4e0e\u521b\u65b0\u7a7a\u95f4\u3002", "motivation": "\u73b0\u6709\u7814\u7a76\u591a\u5173\u6ce8\u4e8eAI\u8f85\u52a9\u7f16\u7a0b\u7684\u63d0\u793a\u8bbe\u8ba1\u548c\u4ee3\u7801\u751f\u6210\u8d28\u91cf\uff0c\u4f46AI\u5982\u4f55\u5f71\u54cd\u8f6f\u4ef6\u5de5\u7a0b\u8fed\u4ee3\u548c\u751f\u6001\u7cfb\u7edf\u5c1a\u672a\u6df1\u5165\u63a2\u8ba8\u3002\u672c\u7814\u7a76\u65e8\u5728\u63ed\u793aAI\u7f16\u7a0b\u4e0e\u8f6f\u4ef6\u751f\u6001\u4e4b\u95f4\u7684\u4e92\u52a8\uff0c\u5e76\u5206\u6790\u5176\u66f4\u5e7f\u6cdb\u5f71\u54cd\u3002", "method": "\u4f5c\u8005\u8fdb\u884c\u4e86\u5927\u89c4\u6a21\u5b9e\u9a8c\uff0c\u6db5\u76d6\u6570\u5343\u4e2a\u7b97\u6cd5\u7f16\u7a0b\u4efb\u52a1\u548c\u6570\u767e\u4e2a\u6846\u67b6\u9009\u62e9\u4efb\u52a1\uff0c\u7cfb\u7edf\u6027\u5206\u6790AI\u8f85\u52a9\u7f16\u7a0b\u4e0e\u8f6f\u4ef6\u751f\u6001\u7cfb\u7edf\u7684\u5173\u7cfb\u3002", "result": "AI\u751f\u6210\u4ee3\u7801\u5728\u6d41\u884c\u7684\u7f16\u7a0b\u8bed\u8a00\u548c\u6846\u67b6\u4e0b\u6210\u529f\u7387\u66f4\u9ad8\uff0c\u5448\u73b0\u660e\u663e\u7684\u9a6c\u592a\u6548\u5e94\uff0c\u5373\u70ed\u95e8\u6280\u672f\u8d8a\u53d7AI\u652f\u6301\uff0c\u8fdb\u4e00\u6b65\u5f3a\u5316\u4e3b\u6d41\u5730\u4f4d\uff0c\u53ef\u80fd\u6291\u5236\u751f\u6001\u591a\u6837\u6027\u548c\u521b\u65b0\u3002", "conclusion": "AI\u9a71\u52a8\u7684\u7f16\u7a0b\u65b9\u5f0f\u6709\u53ef\u80fd\u52a0\u901f\u4e3b\u6d41\u5de5\u5177\u7684\u96c6\u4e2d\u5316\u53d1\u5c55\uff0c\u5f71\u54cd\u672a\u6765\u7f16\u7a0b\u751f\u6001\u7cfb\u7edf\u7684\u591a\u6837\u6027\u548c\u521b\u65b0\u80fd\u529b\u3002\u8fd9\u4e00\u73b0\u8c61\u5e94\u5f15\u8d77\u4e1a\u754c\u548c\u7814\u7a76\u754c\u5173\u6ce8\uff0c\u907f\u514d\u6280\u672f\u5355\u4e00\u5316\u3002"}}
{"id": "2509.25023", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2509.25023", "abs": "https://arxiv.org/abs/2509.25023", "authors": ["Alexander Baumgartner", "Temur Kutsia"], "title": "Generalization of Variadic Structures with Binders: A Tool for Structural Code Comparison", "comment": null, "summary": "This paper introduces a novel anti-unification algorithm for the\ngeneralization of variadic structures with binders, designed as a flexible tool\nfor structural code comparison. By combining nominal techniques for handling\nvariable binding with support for variadic expressions (common in abstract\nsyntax trees and programming languages), the approach addresses key challenges\nsuch as overemphasis on bound variable names and difficulty handling insertions\nor deletions in code fragments. The algorithm distinguishes between atoms and\ntwo kinds of variables (term and hedge variables) to compute best\ngeneralizations that maximally preserve structural similarities while\nabstracting systematic differences. It also provides detailed information to\nreconstruct original expressions and quantify structural differences. This\ninformation can be useful in tasks like code clone detection, refactoring, and\nprogram analysis. By introducing a parametrizable rigidity function, the\ntechnique offers fine-grained control over similarity criteria and reduces\nnondeterminism, enabling flexible adaptation to practical scenarios where\ntrivial similarities should be discounted. Although demonstrated primarily in\nthe context of code similarity detection, this framework is broadly applicable\nwherever precise comparison of variadic and binder-rich representations is\nrequired.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e00\u79cd\u9488\u5bf9\u53ef\u53d8\u53c2\u7ed3\u6784\uff08\u5982AST\uff09\u5e76\u5e26\u6709\u7ed1\u5b9a\u7b26\u53f7\u7684\u65b0\u578b\u53cd\u7edf\u4e00\u7b97\u6cd5\uff0c\u80fd\u591f\u7cbe\u51c6\u6bd4\u8f83\u548c\u6cdb\u5316\u590d\u6742\u4ee3\u7801\u7ed3\u6784\uff0c\u5e76\u901a\u8fc7\u53c2\u6570\u5316\u65b9\u6cd5\u517c\u987e\u7075\u6d3b\u6027\u4e0e\u7cbe\u5ea6\uff0c\u9002\u7528\u4e8e\u4ee3\u7801\u514b\u9686\u68c0\u6d4b\u548c\u7ed3\u6784\u76f8\u4f3c\u6027\u5206\u6790\u7b49\u591a\u79cd\u573a\u666f\u3002", "motivation": "\u73b0\u6709\u7528\u4e8e\u4ee3\u7801\u7ed3\u6784\u6bd4\u8f83\u7684\u65b9\u6cd5\u5728\u5904\u7406\u7ed1\u5b9a\u53d8\u91cf\u548c\u53ef\u53d8\u53c2\u6570\u7ed3\u6784\uff08\u5982\u62bd\u8c61\u8bed\u6cd5\u6811\uff09\u65f6\u5b58\u5728\u5c40\u9650\uff0c\u5c24\u5176\u5bb9\u6613\u56e0\u53d8\u91cf\u540d\u6216\u4ee3\u7801\u788e\u7247\u7684\u63d2\u5165\u3001\u5220\u9664\u9020\u6210\u6bd4\u8f83\u548c\u6cdb\u5316\u56f0\u96be\u3002\u9700\u8981\u4e00\u79cd\u80fd\u591f\u66f4\u7075\u6d3b\u3001\u7cbe\u786e\u5904\u7406\u8fd9\u79cd\u7ed3\u6784\u7684\u6570\u636e\u6cdb\u5316\u4e0e\u6bd4\u8f83\u5de5\u5177\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u9896\u7684\u53cd\u7edf\u4e00\u7b97\u6cd5\uff0c\u4e13\u95e8\u9488\u5bf9\u5177\u6709\u7ed1\u5b9a\u7b26\u53f7\u7684\u53ef\u53d8\u53c2\u7ed3\u6784\u6cdb\u5316\u3002\u65b9\u6cd5\u7ed3\u5408\u4e86\u5904\u7406\u53d8\u91cf\u7ed1\u5b9a\u7684\u540d\u4e49\u6280\u672f\uff0c\u5e76\u652f\u6301\u5728\u62bd\u8c61\u8bed\u6cd5\u6811\u7b49\u7ed3\u6784\u4e2d\u5e38\u89c1\u7684\u53d8\u957f\u8868\u8fbe\u5f0f\u3002\u6b64\u5916\uff0c\u7b97\u6cd5\u533a\u5206\u539f\u5b50\u3001\u9879\u53d8\u91cf\u4e0e\u5e8f\u5217\u53d8\u91cf\uff0c\u5e76\u5f15\u5165\u53ef\u53c2\u6570\u5316\u7684\u521a\u6027\u51fd\u6570\uff0c\u5b9e\u73b0\u5bf9\u76f8\u4f3c\u6027\u8bc4\u5224\u6807\u51c6\u7684\u7ec6\u7c92\u5ea6\u8c03\u63a7\u3002", "result": "\u6240\u63d0\u51fa\u7684\u7b97\u6cd5\u80fd\u591f\u5728\u6700\u5927\u7a0b\u5ea6\u4fdd\u7559\u7ed3\u6784\u76f8\u4f3c\u6027\u7684\u540c\u65f6\uff0c\u62bd\u8c61\u51fa\u7cfb\u7edf\u6027\u5dee\u5f02\uff0c\u5e76\u80fd\u8be6\u7ec6\u91cf\u5316\u7ed3\u6784\u5dee\u5f02\uff0c\u4e3a\u8868\u8fbe\u5f0f\u91cd\u5efa\u548c\u6bd4\u8f83\u63d0\u4f9b\u652f\u6301\u3002\u5728\u4ee3\u7801\u76f8\u4f3c\u6027\u68c0\u6d4b\u3001\u4ee3\u7801\u514b\u9686\u8bc6\u522b\u3001\u91cd\u6784\u548c\u7a0b\u5e8f\u5206\u6790\u7b49\u4efb\u52a1\u4e2d\u8868\u73b0\u51fa\u826f\u597d\u9002\u5e94\u6027\u4e0e\u5b9e\u7528\u4ef7\u503c\u3002", "conclusion": "\u65b0\u7b97\u6cd5\u4e3a\u542b\u6709\u7ed1\u5b9a\u7b26\u53f7\u548c\u53ef\u53d8\u957f\u8868\u8fbe\u5f0f\u7684\u7ed3\u6784\u6bd4\u8f83\u5e26\u6765\u66f4\u7075\u6d3b\u548c\u7cbe\u786e\u7684\u65b9\u6848\uff0c\u663e\u8457\u63d0\u5347\u4e86\u5bf9\u4e8e\u7ed1\u5b9a\u53d8\u91cf\u548c\u7ed3\u6784\u5dee\u5f02\u7684\u5904\u7406\u80fd\u529b\uff0c\u5728\u591a\u79cd\u76f8\u5173\u9886\u57df\u5177\u5907\u5e7f\u6cdb\u5e94\u7528\u524d\u666f\u3002"}}
{"id": "2509.25114", "categories": ["cs.PL", "cs.SC", "math.AG"], "pdf": "https://arxiv.org/pdf/2509.25114", "abs": "https://arxiv.org/abs/2509.25114", "authors": ["Erdenebayar Bayarmagnai", "Fatemeh Mohammadi", "R\u00e9mi Pr\u00e9bet"], "title": "From Affine to Polynomial: Synthesizing Loops with Branches via Algebraic Geometry", "comment": null, "summary": "Ensuring software correctness remains a fundamental challenge in formal\nprogram verification. One promising approach relies on finding polynomial\ninvariants for loops. Polynomial invariants are properties of a program loop\nthat hold before and after each iteration. Generating such invariants is a\ncrucial task in loop analysis, but it is undecidable in the general case.\nRecently, an alternative approach to this problem has emerged, focusing on\nsynthesizing loops from invariants. However, existing methods only synthesize\naffine loops without guard conditions from polynomial invariants. In this\npaper, we address a more general problem, allowing loops to have polynomial\nupdate maps with a given structure, inequations in the guard condition, and\npolynomial invariants of arbitrary form.\n  We use algebraic geometry tools to design and implement an algorithm that\ncomputes a finite set of polynomial equations whose solutions correspond to all\nnondeterministic branching loops satisfying the given invariants. Furthermore,\nwe introduce a new class of invariants for which we present a significantly\nmore efficient algorithm. In other words, we reduce the problem of synthesizing\nloops to find solutions of multivariate polynomial systems with rational\nentries. This final step is handled in our software using an SMT solver.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u5229\u7528\u4ee3\u6570\u51e0\u4f55\u548cSMT\u6280\u672f\uff0c\u7531\u591a\u9879\u5f0f\u4e0d\u53d8\u91cf\u5408\u6210\u590d\u6742\u5faa\u73af\u7ed3\u6784\u7684\u901a\u7528\u65b9\u6cd5\uff0c\u7a81\u7834\u4e86\u73b0\u6709\u65b9\u6cd5\u5bf9\u5faa\u73af\u7c7b\u578b\u7684\u9650\u5236\uff0c\u5b9e\u73b0\u4e86\u66f4\u9ad8\u6548\u548c\u5e7f\u6cdb\u7684\u5408\u6210\u80fd\u529b\u3002", "motivation": "\u73b0\u6709\u65b9\u6cd5\u5728\u4ece\u4e0d\u53d8\u91cf\u5408\u6210\u5faa\u73af\u65f6\u5c40\u9650\u4e8e\u65e0\u5224\u522b\u6761\u4ef6\u7684\u4eff\u5c04\u5faa\u73af\uff0c\u800c\u5b9e\u9645\u5e94\u7528\u9700\u8981\u652f\u6301\u591a\u9879\u5f0f\u66f4\u65b0\u3001\u590d\u6742\u5224\u522b\u5f0f\u548c\u4efb\u610f\u5f62\u6001\u4e0d\u53d8\u91cf\uff0c\u56e0\u6b64\u4e9f\u9700\u66f4\u6cdb\u5316\u7684\u5408\u6210\u65b9\u6cd5\u3002", "method": "\u5229\u7528\u4ee3\u6570\u51e0\u4f55\u5de5\u5177\uff0c\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u4e86\u901a\u8fc7\u6c42\u89e3\u6709\u9650\u591a\u9879\u5f0f\u65b9\u7a0b\u7ec4\u5bfb\u627e\u6ee1\u8db3\u4e0d\u53d8\u91cf\u7684\u6240\u6709\u975e\u786e\u5b9a\u6027\u5206\u652f\u5faa\u73af\u7684\u7b97\u6cd5\uff0c\u5e76\u5f15\u5165\u4e86\u4e00\u4e2a\u65b0\u7684\u4e0d\u53d8\u91cf\u7c7b\u522b\u4ee5\u53ca\u66f4\u9ad8\u6548\u7684\u5408\u6210\u7b97\u6cd5\uff0c\u6700\u540e\u5229\u7528SMT\u6c42\u89e3\u5668\u5904\u7406\u6c42\u89e3\u73af\u8282\u3002", "result": "\u63d0\u51fa\u4e86\u4e00\u79cd\u80fd\u5904\u7406\u591a\u9879\u5f0f\u66f4\u65b0\u6620\u5c04\u3001\u590d\u6742guard\u6761\u4ef6\u548c\u4efb\u610f\u5f62\u5f0f\u4e0d\u53d8\u91cf\u7684\u5faa\u73af\u5408\u6210\u7b97\u6cd5\uff0c\u5e76\u5c55\u793a\u4e86\u5bf9\u67d0\u4e9b\u65b0\u578b\u4e0d\u53d8\u91cf\u66f4\u9ad8\u6548\u7684\u7279\u5b9a\u7b97\u6cd5\u3002\u76f8\u5173\u65b9\u6cd5\u5df2\u5b9e\u73b0\u4e3a\u8f6f\u4ef6\u5de5\u5177\uff0c\u80fd\u4ee5\u53ef\u884c\u65f6\u95f4\u627e\u5230\u6240\u6709\u6ee1\u8db3\u6761\u4ef6\u7684\u5faa\u73af\u7ed3\u6784\u3002", "conclusion": "\u901a\u8fc7\u5c06\u5faa\u73af\u5408\u6210\u95ee\u9898\u8f6c\u5316\u4e3a\u591a\u5143\u591a\u9879\u5f0f\u65b9\u7a0b\u7ec4\u6c42\u89e3\uff0c\u5e76\u5229\u7528SMT\u6c42\u89e3\u5668\u89e3\u51b3\u76f8\u5173\u95ee\u9898\uff0c\u5b9e\u73b0\u4e86\u4ece\u591a\u9879\u5f0f\u4e0d\u53d8\u91cf\u5408\u6210\u66f4\u4e00\u822c\u6027\u7684\u5faa\u73af\u7ed3\u6784\u3002"}}
{"id": "2509.22715", "categories": ["cs.CL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.22715", "abs": "https://arxiv.org/abs/2509.22715", "authors": ["Jiho Park", "Jongyoon Song", "Minjin Choi", "Kyuho Heo", "Taehun Huh", "Ji Won Kim"], "title": "TRUEBench: Can LLM Response Meet Real-world Constraints as Productivity Assistant?", "comment": "Accepted to EMNLP 2025 Findings", "summary": "Large language models (LLMs) are increasingly integral as productivity\nassistants, but existing benchmarks fall short in rigorously evaluating their\nreal-world instruction-following capabilities. Current benchmarks often (i)\nlack sufficient multilinguality, (ii) fail to capture the implicit constraints\ninherent in user requests, and (iii) overlook the complexities of multi-turn\ndialogue. To address these critical gaps and provide a more realistic\nassessment, we introduce TRUEBench (Trustworthy Real-world Usage Evaluation\nBenchmark)1, a novel benchmark specifically designed for LLM-based productivity\nassistants. TRUEBench distinguishes itself by featuring input prompts across 12\nlanguages, incorporating intra-instance multilingual instructions, employing\nrigorous evaluation criteria to capture both explicit and implicit constraints,\nand including complex multi-turn dialogue scenarios with both accumulating\nconstraints and context switches. Furthermore, to ensure reliability in\nevaluation, we refined constraints using an LLM validator. Extensive\nexperiments demonstrate that TRUEBench presents significantly greater\nchallenges than existing benchmarks; for instance, a strong model like OpenAI\no1 achieved only a 69.07% overall pass rate. TRUEBench offers a demanding and\nrealistic assessment of LLMs in practical productivity settings, highlighting\ntheir capabilities and limitations.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63d0\u51fa\u5e76\u516c\u5f00TRUEBench\u57fa\u51c6\uff0c\u5168\u9762\u8bc4\u4f30\u5927\u8bed\u8a00\u6a21\u578b\u5728\u591a\u8bed\u8a00\u3001\u591a\u8f6e\u5bf9\u8bdd\u53ca\u9690\u542b\u7ea6\u675f\u573a\u666f\u4e0b\u7684\u5b9e\u9645\u80fd\u529b\u3002\u5b9e\u9a8c\u8bc1\u660e\u4e3b\u6d41\u6a21\u578b\u5728\u8be5\u57fa\u51c6\u4e0a\u8868\u73b0\u6709\u9650\uff0cTRUEBench\u63ed\u793a\u51fa\u5b9e\u9645\u5e94\u7528\u573a\u666f\u4e2d\u6a21\u578b\u7684\u771f\u5b9e\u6c34\u5e73\u548c\u74f6\u9888\u3002", "motivation": "\u5f53\u524d\u5927\u8bed\u8a00\u6a21\u578b\u5728\u771f\u5b9e\u573a\u666f\u4e0b\u4f5c\u4e3a\u751f\u4ea7\u529b\u52a9\u624b\u6108\u53d1\u91cd\u8981\uff0c\u4f46\u73b0\u6709\u7684\u8bc4\u6d4b\u57fa\u51c6\u5728\u8bc4\u4f30\u5176\u771f\u5b9e\u6307\u4ee4\u9075\u5faa\u80fd\u529b\u65b9\u9762\u5b58\u5728\u4e0d\u8db3\u3002\u5177\u4f53\u8868\u73b0\u4e3a\u7f3a\u4e4f\u591a\u8bed\u8a00\u8986\u76d6\u3001\u672a\u80fd\u6355\u6349\u7528\u6237\u8bf7\u6c42\u4e2d\u7684\u9690\u542b\u7ea6\u675f\uff0c\u4ee5\u53ca\u5ffd\u89c6\u591a\u8f6e\u5bf9\u8bdd\u7684\u590d\u6742\u6027\u3002", "method": "\u63d0\u51faTRUEBench\u57fa\u51c6\uff0c\u5305\u542b12\u79cd\u8bed\u8a00\u7684\u8f93\u5165\u63d0\u793a\u3001\u5355\u5b9e\u4f8b\u591a\u8bed\u79cd\u6307\u4ee4\u3001\u4e25\u683c\u7684\u8bc4\u4f30\u6807\u51c6\uff08\u6db5\u76d6\u663e\u5f0f\u4e0e\u9690\u5f0f\u7ea6\u675f\uff09\u3001\u590d\u6742\u591a\u8f6e\u5bf9\u8bdd\uff08\u5305\u542b\u7d2f\u79ef\u7ea6\u675f\u53ca\u4e0a\u4e0b\u6587\u5207\u6362\uff09\u3002\u6b64\u5916\uff0c\u4f7f\u7528LLM\u9a8c\u8bc1\u5668\u4f18\u5316\u7ea6\u675f\uff0c\u786e\u4fdd\u8bc4\u4f30\u53ef\u9760\u6027\u3002", "result": "\u5b9e\u9a8c\u8868\u660e\uff0cTRUEBench\u6bd4\u73b0\u6709\u57fa\u51c6\u96be\u5ea6\u663e\u8457\u66f4\u9ad8\u3002\u4f8b\u5982\uff0c\u5f3a\u5927\u6a21\u578b\u5982OpenAI o1\u5728\u8be5\u57fa\u51c6\u4e0a\u7684\u901a\u8fc7\u7387\u4ec5\u4e3a69.07%\u3002", "conclusion": "TRUEBench\u4e3a\u751f\u4ea7\u529b\u573a\u666f\u4e0b\u7684\u5927\u8bed\u8a00\u6a21\u578b\u63d0\u4f9b\u4e86\u66f4\u5177\u6311\u6218\u6027\u548c\u73b0\u5b9e\u6027\u7684\u8bc4\u4f30\uff0c\u63ed\u793a\u4e86\u5176\u80fd\u529b\u548c\u5c40\u9650\u6027\uff0c\u5bf9\u771f\u5b9e\u5e94\u7528\u5177\u6709\u91cd\u8981\u53c2\u8003\u610f\u4e49\u3002"}}
{"id": "2509.23297", "categories": ["cs.SE", "cs.GR", "cs.HC"], "pdf": "https://arxiv.org/pdf/2509.23297", "abs": "https://arxiv.org/abs/2509.23297", "authors": ["Anthony Savidis", "Christos Vasilopoulos"], "title": "Code Arcades: 3d Visualization of Classes, Dependencies and Software Metrics", "comment": null, "summary": "Software visualization seeks to represent software artifacts graphical-ly in\ntwo or three dimensions, with the goal of enhancing comprehension, anal-ysis,\nmaintenance, and evolution of the source code. In this context, visualiza-tions\nemploy graphical forms such as dependency structures, treemaps, or time-lines\nthat incorporate repository histories. These visualizations allow software\nengineers to identify structural patterns, detect complexity hotspots, and\ninfer system behaviors that are difficult to perceive directly from source\ntext. By adopting metaphor-based approaches, visualization tools provide\nmacroscopic overviews while enabling focused inspection of specific program\nelements, thus offering an accessible means of understanding large-scale\nsystems. The contri-bution of our work lies in three areas. First, we introduce\na configurable group-ing mechanism that supports flexible organization of code\nelements based on arbitrary relationships. Second, we combine fine-grained and\ncoarse-grained software metrics to provide a multi-level perspective on system\nproperties. Third, we present an interactive visualization engine that allows\ndevelopers to dynamically adjust rendering attributes. Collectively, these\nadvances provide a more adaptable and insightful approach to source code\ncomprehension.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u5957\u96c6\u5408\u5206\u7ec4\u3001\u5ea6\u91cf\u53ca\u4ea4\u4e92\u7279\u6027\u7684\u53ef\u89c6\u5316\u5de5\u5177\uff0c\u66f4\u597d\u5730\u5e2e\u52a9\u5f00\u53d1\u8005\u7406\u89e3\u5927\u578b\u8f6f\u4ef6\u7cfb\u7edf\u3002", "motivation": "\u8f6f\u4ef6\u53ef\u89c6\u5316\u65e8\u5728\u63d0\u5347\u5f00\u53d1\u8005\u5bf9\u6e90\u4ee3\u7801\u7684\u7406\u89e3\u3001\u5206\u6790\u3001\u7ef4\u62a4\u548c\u6f14\u5316\u80fd\u529b\uff0c\u901a\u8fc7\u56fe\u5f62\u65b9\u5f0f\u5c55\u73b0\u8f6f\u4ef6\u7ed3\u6784\u548c\u6f14\u53d8\u5386\u53f2\uff0c\u89e3\u51b3\u4ece\u6587\u672c\u96be\u4ee5\u5bdf\u89c9\u7684\u7cfb\u7edf\u884c\u4e3a\u548c\u590d\u6742\u6027\u95ee\u9898\u3002", "method": "\u8be5\u5de5\u4f5c\u63d0\u51fa\u4e86\u4e09\u9879\u65b9\u6cd5\u5b66\u521b\u65b0\uff1a1) \u53ef\u914d\u7f6e\u7684\u5206\u7ec4\u673a\u5236\uff0c\u6839\u636e\u4efb\u610f\u5173\u7cfb\u7075\u6d3b\u7ec4\u7ec7\u4ee3\u7801\u5143\u7d20\uff1b2) \u7ed3\u5408\u7ec6\u7c92\u5ea6\u4e0e\u7c97\u7c92\u5ea6\u6307\u6807\uff0c\u4ece\u591a\u4e2a\u5c42\u7ea7\u5c55\u73b0\u7cfb\u7edf\u5c5e\u6027\uff1b3) \u4ea4\u4e92\u5f0f\u53ef\u89c6\u5316\u5f15\u64ce\uff0c\u652f\u6301\u5f00\u53d1\u8005\u52a8\u6001\u8c03\u6574\u53ef\u89c6\u5316\u6e32\u67d3\u53c2\u6570\u3002", "result": "\u63d0\u51fa\u7684\u673a\u5236\u548c\u5de5\u5177\u80fd\u591f\u63d0\u5347\u5927\u89c4\u6a21\u7cfb\u7edf\u7684\u4ee3\u7801\u7406\u89e3\u548c\u6d1e\u5bdf\uff0c\u589e\u5f3a\u4e86\u53ef\u89c6\u5316\u7684\u9002\u5e94\u6027\u548c\u4fe1\u606f\u4ef7\u503c\u3002", "conclusion": "\u7efc\u5408\u5404\u9879\u521b\u65b0\uff0c\u8be5\u7814\u7a76\u4e3a\u6e90\u4ee3\u7801\u7406\u89e3\u63d0\u4f9b\u4e86\u66f4\u7075\u6d3b\u3001\u6df1\u5165\u7684\u53ef\u89c6\u5316\u624b\u6bb5\uff0c\u6709\u52a9\u4e8e\u8f6f\u4ef6\u5de5\u7a0b\u5e08\u9ad8\u6548\u5206\u6790\u548c\u7ef4\u62a4\u590d\u6742\u7cfb\u7edf\u3002"}}
{"id": "2408.14345", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2408.14345", "abs": "https://arxiv.org/abs/2408.14345", "authors": ["Giuseppe Castagna", "Guillaume Duboc"], "title": "Guard Analysis and Safe Erasure Gradual Typing: a Type System for Elixir", "comment": null, "summary": "We formalize a new type system for Elixir, a dynamically typed functional\nprogramming language of growing popularity that runs on the Erlang virtual\nmachine. Our system combines gradual typing with semantic subtyping to enable\nprecise, sound, and practical static type analysis, without requiring any\nchanges to Elixir's compilation pipeline or runtime. Type soundness is ensured\nby leveraging runtime checks -- both implicit, from the Erlang VM, and\nexplicit, via developer-written guards.\n  Central to our approach are two key innovations: the notion of \"strong\nfunctions\", which can be assigned precise types even when applied to inputs\nthat may fall outside their intended domain; and a fine-grained analysis of\nguards that enables accurate type refinement for case expressions and guarded\nfunction definitions. While type information is erased before execution and not\nused by the compiler, our \"safe erasure\" gradual typing strategy maintains\nsoundness and expressiveness without compromising compatibility or performance.\nThis work lays the theoretical foundation for Elixir's new type system,\noutlines its integration into recent versions of the language, and demonstrates\nits effectiveness on large-scale industrial codebases.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86Elixir\u7684\u65b0\u7c7b\u578b\u7cfb\u7edf\uff0c\u65e0\u9700\u66f4\u6539\u7f16\u8bd1\u548c\u8fd0\u884c\u65f6\u67b6\u6784\uff0c\u7ed3\u5408\u6e10\u8fdb\u7c7b\u578b\u548c\u8bed\u4e49\u5b50\u7c7b\u578b\uff0c\u901a\u8fc7\u521b\u65b0\u673a\u5236\u5b9e\u73b0\u7c7b\u578b\u5065\u5168\u4e0e\u8868\u8fbe\u80fd\u529b\u5e76\u91cd\uff0c\u6548\u679c\u5df2\u5728\u5de5\u4e1a\u7ea7\u9879\u76ee\u4e2d\u9a8c\u8bc1\u3002", "motivation": "Elixir\u662f\u4e00\u79cd\u6d41\u884c\u4e14\u52a8\u6001\u7c7b\u578b\u7684\u51fd\u6570\u5f0f\u7f16\u7a0b\u8bed\u8a00\uff0c\u7f3a\u4e4f\u9759\u6001\u7c7b\u578b\u5206\u6790\u5de5\u5177\u3002\u672c\u8bba\u6587\u65e8\u5728\u89e3\u51b3\u5728\u4e0d\u6539\u53d8Elixir\u7f16\u8bd1\u6216\u8fd0\u884c\u73af\u5883\u7684\u524d\u63d0\u4e0b\uff0c\u63d0\u4f9b\u7cbe\u51c6\u3001\u5065\u5168\u4e14\u5b9e\u7528\u7684\u9759\u6001\u7c7b\u578b\u5206\u6790\u80fd\u529b\u3002", "method": "\u63d0\u51fa\u4e00\u79cd\u65b0\u7684\u7c7b\u578b\u7cfb\u7edf\uff0c\u5c06\u6e10\u8fdb\u7c7b\u578b\uff08gradual typing\uff09\u4e0e\u8bed\u4e49\u5b50\u7c7b\u578b\uff08semantic subtyping\uff09\u7ed3\u5408\uff0c\u4f9d\u9760Erlang VM\u7684\u9690\u5f0f\u68c0\u67e5\u548c\u5f00\u53d1\u8005\u81ea\u5b9a\u4e49\u5b88\u536b\uff08guards\uff09\u7684\u663e\u5f0f\u68c0\u67e5\u4fdd\u8bc1\u7c7b\u578b\u5065\u5168\u6027\u3002\u521b\u65b0\u70b9\u5305\u62ec\u201cstrong functions\u201d\u6982\u5ff5\u548c\u5bf9\u5b88\u536b\u7684\u7ec6\u7c92\u5ea6\u5206\u6790\uff0c\u5b9e\u73b0\u4e86case\u8868\u8fbe\u5f0f\u548c\u5b88\u536b\u51fd\u6570\u5b9a\u4e49\u7684\u7cbe\u786e\u7c7b\u578b\u7ec6\u5316\u3002", "result": "\u65b0\u7c7b\u578b\u7cfb\u7edf\u53ef\u4ee5\u88ab\u96c6\u6210\u5230Elixir\u7684\u65b0\u7248\u672c\u4e2d\uff0c\u5bf9\u5927\u578b\u5de5\u4e1a\u4ee3\u7801\u5e93\u8fdb\u884c\u4e86\u5b9e\u9a8c\u9a8c\u8bc1\uff0c\u663e\u793a\u6027\u80fd\u4e0e\u517c\u5bb9\u6027\u6ca1\u6709\u53d7\u5230\u5f71\u54cd\uff0c\u5e76\u5b9e\u73b0\u4e86\u7c7b\u578b\u5065\u5168\u6027\u4e0e\u8868\u8fbe\u80fd\u529b\u7684\u63d0\u5347\u3002", "conclusion": "\u672c\u8bba\u6587\u4e3aElixir\u6784\u5efa\u4e86\u7406\u8bba\u5b8c\u5584\u7684\u65b0\u7c7b\u578b\u7cfb\u7edf\uff0c\u5b9e\u73b0\u4e86\u5065\u5168\u3001\u517c\u5bb9\u3001\u5b9e\u7528\u4e14\u7cbe\u51c6\u7684\u9759\u6001\u7c7b\u578b\u5206\u6790\uff0c\u4e3a\u8be5\u8bed\u8a00\u7684\u7c7b\u578b\u5b89\u5168\u548c\u5927\u578b\u5f00\u53d1\u9879\u76ee\u7684\u53ef\u9760\u6027\u6253\u4e0b\u57fa\u7840\u3002"}}

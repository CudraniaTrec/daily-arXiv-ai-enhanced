<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 5]
- [cs.LO](#cs.LO) [Total: 1]
- [cs.CL](#cs.CL) [Total: 1]
- [cs.DM](#cs.DM) [Total: 1]
- [cs.FL](#cs.FL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Beyond Single LLMs: Enhanced Code Generation via Multi-Stage Performance-Guided LLM Orchestration](https://arxiv.org/abs/2510.01379)
*Huashan Chen,Zhenyu Qi,Haotang Li,Hong Chen,Jinfu Chen,Kebin Peng,In Kee Kim,Kyu Hyung Lee,Sen He*

Main category: cs.SE

TL;DR: 本文通过综合评测LLM，提出可动态选择最优模型的自动化代码生成框架，在代码正确性和运行性能上大幅优于现有单模型方法，具备良好扩展性和落地价值。


<details>
  <summary>Details</summary>
Motivation: 现有自动化代码生成以单一大语言模型（LLM）为主，但不同模型在多编程语言、算法领域及开发阶段表现差异明显，单模型方法无法充分利用各模型优势。

Method: 提出了一种多阶段、性能导向的编排框架PerfOrch，通过动态分配任务到最合适的LLM，并采用生成-修复-优化的工作流，结合阶段性验证与回滚机制。方法基于对17个领先LLM在五种编程语言上进行功能正确性和运行性能（如执行时间、内存和CPU效率）全面实证评估。

Result: PerfOrch无需微调，显著超过强基线模型，如GPT-4o的正确率分别为78.66%和49.11%，PerfOrch达到96.22%和91.37%。性能方面，58.76%的问题获得执行时间优化，各语言中位加速比为17.67%-27.66%。

Conclusion: 多模型编排优于单一模型，PerfOrch可按任务与阶段动态选用最佳LLM，确保更高代码正确性和运行效率，框架易扩展，适用于不断发展的自动化软件工程。

Abstract: While Large Language Models (LLMs) have become the predominant paradigm for
automated code generation, current single-model approaches fundamentally ignore
the heterogeneous computational strengths that different models exhibit across
programming languages, algorithmic domains, and development stages. This paper
challenges the single-model convention by introducing a multi-stage,
performance-guided orchestration framework that dynamically routes coding tasks
to the most suitable LLMs within a structured generate-fix-refine workflow. Our
approach is grounded in a comprehensive empirical study of 17 state-of-the-art
LLMs across five programming languages (Python, Java, C++, Go, and Rust) using
HumanEval-X benchmark. The study, which evaluates both functional correctness
and runtime performance metrics (execution time, mean/max memory utilization,
and CPU efficiency), reveals pronounced performance heterogeneity by language,
development stage, and problem category. Guided by these empirical insights, we
present PerfOrch, an LLM agent that orchestrates top-performing LLMs for each
task context through stage-wise validation and rollback mechanisms. Without
requiring model fine-tuning, PerfOrch achieves substantial improvements over
strong single-model baselines: average correctness rates of 96.22% and 91.37%
on HumanEval-X and EffiBench-X respectively, surpassing GPT-4o's 78.66% and
49.11%. Beyond correctness gains, the framework delivers consistent performance
optimizations, improving execution time for 58.76% of problems with median
speedups ranging from 17.67% to 27.66% across languages on two benchmarks. The
framework's plug-and-play architecture ensures practical scalability, allowing
new LLMs to be profiled and integrated seamlessly, thereby offering a paradigm
for production-grade automated software engineering that adapts to the rapidly
evolving generative AI landscape.

</details>


### [2] [Deciphering WONTFIX: A Mixed-Method Study on Why GitHub Issues Get Rejected](https://arxiv.org/abs/2510.01514)
*J. Alexander Curtis,Sharadha Kasiviswanathan,Nasir Eisty*

Main category: cs.SE

TL;DR: 本研究通过对GitHub热门仓库的混合方法分析，揭示了wontfix标签的使用频率、原因及其对社区氛围和项目管理的影响，为开源管理提供了重要参考。


<details>
  <summary>Details</summary>
Motivation: 尽管wontfix标签在GitHub中非常常见，但其对项目管理和社区动态的实际影响尚不明确，本研究意在揭示wontfix标签的使用情况及其背后原因。

Method: 采用混合方法，结合定量分析wontfix标签的使用频率和定性分析其背后动机，对3132个热门开源仓库进行数据收集、开放编码和主题分析。

Result: 约30%的GitHub项目对部分问题应用了wontfix标签，且主要出现在用户提交的Bug报告和功能请求中。研究总结出8种常见的标签原因，包括用户控制因素和维护者决策等主题。

Conclusion: wontfix标签是GitHub项目中重要的资源管理工具，能够有效指导维护者和贡献者的工作，但同时可能会影响社区参与度和项目管理透明度。理解标记wontfix的原因有助于优化协作和项目管理。

Abstract: Context: The ``wontfix'' label is a widely used yet narrowly understood tool
in GitHub repositories, indicating that an issue will not be pursued further.
Despite its prevalence, the impact of this label on project management and
community dynamics within open-source software development is not clearly
defined. Objective: This study examines the prevalence and reasons behind
issues being labeled as wontfix across various open-source repositories on
GitHub. Method: Employing a mixed-method approach, we analyze both quantitative
data to assess the prevalence of the wontfix label and qualitative data to
explore the reasoning that it was used. Data were collected from 3,132 of
GitHub's most-popular repositories. Later, we employ open coding and thematic
analysis to categorize the reasons behind wontfix labels, providing a
structured understanding of the issue management landscape. Results: Our
findings show that about 30% of projects on GitHub apply the wontfix label to
some issues. These issues most often occur on user-submitted issues for bug
reports and feature requests. The study identified eight common themes behind
labeling issues as wontfix, ranging from user-specific control factors to
maintainer-specific decisions. Conclusions: The wontfix label is a critical
tool for managing resources and guiding contributor efforts in GitHub projects.
However, it can also discourage community involvement and obscure the
transparency of project management. Understanding these reasons aids project
managers in making informed decisions and fostering efficient collaboration
within open-source communities.

</details>


### [3] [MIMIC: Integrating Diverse Personality Traits for Better Game Testing Using Large Language Model](https://arxiv.org/abs/2510.01635)
*Yifei Chen,Sarra Habchi,Lili Wei*

Main category: cs.SE

TL;DR: 这篇论文提出了一种集成玩家多样性个性的游戏测试智能体MIMIC，能模拟不同策略，提升测试广度和交互丰富性，在多个游戏中均优于传统方法。


<details>
  <summary>Details</summary>
Motivation: 现代电子游戏对传统自动化测试算法提出了巨大挑战，而游戏质量保障又极度依赖于密集测试。现有智能体大多忽视了玩家个性化的多样策略，导致测试覆盖不足。

Method: 提出了MIMIC框架，将不同的个性特征融入游戏智能体，使其在相似情境下能采用不同的游戏策略，从而模拟多样的玩家风格进行测试。

Result: MIMIC框架在多款游戏中实现了更高的测试覆盖率和更丰富的游戏交互。同时，在Minecraft上，其任务完成率和解法多样性都超过了现有最先进的测试智能体。

Conclusion: MIMIC能有效提升游戏测试的覆盖范围和边界案例发现能力，在自动化游戏测试领域具有显著潜力。

Abstract: Modern video games pose significant challenges for traditional automated
testing algorithms, yet intensive testing is crucial to ensure game quality. To
address these challenges, researchers designed gaming agents using
Reinforcement Learning, Imitation Learning, or Large Language Models. However,
these agents often neglect the diverse strategies employed by human players due
to their different personalities, resulting in repetitive solutions in similar
situations. Without mimicking varied gaming strategies, these agents struggle
to trigger diverse in-game interactions or uncover edge cases.
  In this paper, we present MIMIC, a novel framework that integrates diverse
personality traits into gaming agents, enabling them to adopt different gaming
strategies for similar situations. By mimicking different playstyles, MIMIC can
achieve higher test coverage and richer in-game interactions across different
games. It also outperforms state-of-the-art agents in Minecraft by achieving a
higher task completion rate and providing more diverse solutions. These results
highlight MIMIC's significant potential for effective game testing.

</details>


### [4] [FOSS-chain: using blockchain for Open Source Software license compliance](https://arxiv.org/abs/2510.01740)
*Kypros Iacovou,Georgia M. Kapitsaki,Evangelia Vanezi*

Main category: cs.SE

TL;DR: 本文提出了结合区块链技术与开源软件许可证管理的新平台FOSS-chain，实现了自动化合规流程并经初步用户实验验证其有效性。


<details>
  <summary>Details</summary>
Motivation: OSS在广泛应用的同时，不同开源软件的许可证兼容性问题复杂，容易导致法律纠纷。现有的衍生作品合规管理难以透明高效，急需新方法保障合规性。

Method: 提出并设计了FOSS-chain——一个将区块链与许可证管理相结合的平台。该系统利用区块链的不可篡改性和透明性，自动化检测软件衍生作品中的许可证兼容性，并涵盖14种主流开源许可证。通过小规模用户研究对平台原型进行了初步评估。

Result: 初步评估结果显示，FOSS-chain系统可有效自动化开源许可证合规流程，并具备在真实软件系统中推广应用的潜力。

Conclusion: 区块链技术能够提升开源软件许可证合规性管理的透明度和自动化程度，FOSS-chain平台在实际应用中展现出良好前景。

Abstract: Open Source Software (OSS) is widely used and carries licenses that indicate
the terms under which the software is provided for use, also specifying
modification and distribution rules. Ensuring that users are respecting OSS
license terms when creating derivative works is a complex process. Compliance
issues arising from incompatibilities among licenses may lead to legal
disputes. At the same time, the blockchain technology with immutable entries
offers a mechanism to provide transparency when it comes to licensing and
ensure software changes are recorded. In this work, we are introducing an
integration of blockchain and license management when creating derivative
works, in order to tackle the issue of OSS license compatibility. We have
designed, implemented and performed a preliminary evaluation of FOSS-chain, a
web platform that uses blockchain and automates the license compliance process,
covering 14 OSS licenses. We have evaluated the initial prototype version of
the FOSS-chain platform via a small scale user study. Our preliminary results
are promising, demonstrating the potential of the platform for adaptation on
realistic software systems.

</details>


### [5] [ARENA: A tool for measuring and analysing the energy efficiency of Android apps](https://arxiv.org/abs/2510.01754)
*Hina Anwar*

Main category: cs.SE

TL;DR: 本文提出并实现了ARENA插件，帮助开发者在IDE中高效完成安卓App硬件能耗测试、数据统计与可视化分析，解决了传统硬件测量繁琐难用的问题。


<details>
  <summary>Details</summary>
Motivation: 安卓应用的能耗分析依赖于精准的测量方法，但现有硬件测量方式过程复杂、耗时且缺乏易用的工具，对开发者和研究人员不够友好。

Method: 提出ARENA工具，将能耗测量流程集成到IntelliJ和Android Studio插件中，允许通过IDE连接硬件设备自动执行能耗测试、数据收集和统计分析，并实现数据可视化和报告。

Result: 开发了ARENA工具，成功实现开发者可在IDE内便捷地进行硬件级能耗测量、对比应用不同版本或多个应用的能耗，并完成数据处理与可视化分析。

Conclusion: ARENA简化了安卓应用硬件能耗测量过程，提高了测量效率和可复现性，为开发者和研究者提供了开源、易用的能耗分析支持工具。

Abstract: To build energy-efficient apps, there is a need to estimate and analyze their
energy consumption in typical usage scenarios. The energy consumption of
Android apps could be estimated via software-based and hardware-based
approaches. Software-based approaches, while easier to implement, are not as
accurate as hardware-based approaches. The process of measuring the energy
consumption of an Android app via a hardware-based approach typically involves
1) setting up a measurement environment, 2) executing the app under test on a
mobile device, 3) recording current/voltage data via a hardware device to
measure energy consumption, and 4) cleaning and aggregating data for analyses,
reports, and visualizations. Specialized scripts are written for selected
hardware and software components to ensure reliable energy measurements. The
energy measurement process is repeated many times and aggregated to remove
noise. These steps make the hardware-based energy measurement process
time-consuming and not easy to adapt or reproduce. There is a lack of
open-source tools available for developers and researchers to take reliable
energy measurements via hardware devices. In this paper, we present and
demonstrate ARENA, a support tool that enables developers and researchers to
connect to a physical measurement device without leaving the comfort of their
IDE. Developers could use ARENA during development to compare energy
consumption between different apps or versions of the same app. ARENA
calculates energy consumption on an Android smartphone by executing a test
scenario on the app under development. Further, ARENA helps aggregate,
statistically analyze, report, and visualize the data, allowing developers and
researchers to dig into the data directly or visually. We implemented ARENA as
an IntelliJ and Android Studio plugin.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [6] [Sequent Calculi for Data-Aware Modal Logics](https://arxiv.org/abs/2510.01868)
*Carlos Areces,Valentin Cassano,Danae Dutto,Raul Fervari*

Main category: cs.LO

TL;DR: 本文对数据感知模态逻辑HXpathD提出了完整的Gentzen式序列演算体系，实现了所有推理规则的可逆性和割消，为更深入地分析和扩展此类逻辑提供理论基础。


<details>
  <summary>Details</summary>
Motivation: 此前关于HXpathD的研究多集中在模型理论，本工作旨在推动该逻辑的证明理论基础发展，为数据感知模态逻辑和图结构数据查询语言的逻辑分析提供新工具。

Method: 通过从证明理论角度出发，提出并构建HXpathD的Gentzen风格序列演算，分析并验证其可逆性和割消特性。

Result: 实现了对HXpathD逻辑的可靠、完备且拥有良好证明性质（规则可逆、割消）的序列演算，为后续将证明理论方法扩展到更广泛的模态系统打下基础。

Conclusion: 本文建立了HXpathD的可靠且完备的Gentzen式序列演算，并证明了所有推理规则都是可逆的，同时该演算系统也满足割消性质。

Abstract: Data-aware modal logics offer a powerful formalism for reasoning about
semi-structured queries in languages such as DataGL, XPath, and GQL. In brief,
these logics can be viewed as modal systems capable of expressing both
reachability statements and data-aware properties, such as value comparisons.
One particularly expressive logic in this landscape is HXpathD, a hybrid modal
logic that captures not only the navigational core of XPath but also data
comparisons, node labels (keys), and key-based navigation operators. While
previous work on HXpathD has primarily focused on its model-theoretic
properties, in this paper we approach HXpathD from a proof-theoretic
perspective. Concretely, we present a sound and complete Gentzen-style sequent
calculus for HXpathD. Moreover, we show all rules in this calculus are
invertible, and that it enjoys cut elimination. Our work contributes to the
proof-theoretic foundations of data-aware modal logics, and enables a deeper
logical analysis of query languages over graph-structured data. Moreover, our
results lay the groundwork for extending proof-theoretic techniques to a
broader class of modal systems.

</details>


<div id='cs.CL'></div>

# cs.CL [[Back]](#toc)

### [7] [Uncovering Implicit Bias in Large Language Models with Concept Learning Dataset](https://arxiv.org/abs/2510.01219)
*Leroy Z. Wang*

Main category: cs.CL

TL;DR: 作者引入了用于概念学习的数据集，通过实验发现大语言模型在特定学习方式下存在隐含的量词偏见，说明上下文概念学习有助于发现模型中隐藏的偏见。


<details>
  <summary>Details</summary>
Motivation: 希望揭示大语言模型在特定任务中的隐含偏见，探索新的发现偏见的方法。

Method: 构建概念学习任务数据集，通过上下文概念学习实验分析大语言模型的隐含偏见，并与直接提示进行对比。

Result: 证明了上下文概念学习是一种有效发现语言模型隐藏偏见的工具，尤其在量词推理任务上更容易显现模型的向上单调性偏见。

Conclusion: 在上下文概念学习实验中，发现大语言模型具有向上单调性的量词偏见，这种偏见在不加入概念学习组件直接提示时不明显。

Abstract: We introduce a dataset of concept learning tasks that helps uncover implicit
biases in large language models. Using in-context concept learning experiments,
we found that language models may have a bias toward upward monotonicity in
quantifiers; such bias is less apparent when the model is tested by direct
prompting without concept learning components. This demonstrates that
in-context concept learning can be an effective way to discover hidden biases
in language models.

</details>


<div id='cs.DM'></div>

# cs.DM [[Back]](#toc)

### [8] [Computing Phylogenetic Diversity](https://arxiv.org/abs/2510.01849)
*Jannik Schestag*

Main category: cs.DM

TL;DR: 论文针对生物保护中系统发育多样性最大化的多种广义问题，进行了参数化复杂度分析，证明了GNAP、PDD等问题的计算复杂性，并为Time-PD等难题提出高效参数化算法，为实际生物多样性保护决策提供理论基础与算法工具。


<details>
  <summary>Details</summary>
Motivation: 传统的Max-PD问题虽可多项式时间解决，但其生物过程建模的广义问题通常表现出NP困难，实际保育决策需要更精准建模与有效算法。

Method: 采用参数化复杂度理论对问题进行建模分析，结合算法设计（如彩色编码等）用于特定问题的高效求解。

Result: 证明了广义诺亚方舟问题对物种数目参数是W[1]-hard，特定成本与概率参数下是XP；单位成本情况是NP-hard。提出了Time-PD的FPT算法。在有依赖关系的PDD问题中，证明了其对解规模与树高度参数是FPT。

Conclusion: 该论文确定并分析了保守生物多样性过程中涉及的多种最大化系统发育多样性（PD）问题的复杂性，提出了参数化复杂度分析与相应的高效算法。

Abstract: Phylogenetic Diversity(PD)is a well-regarded measure of the overall
biodiversity of a set of present-day species(taxa)that indicates its ecological
significance.In the Maximize Phylogenetic Diversity(Max-PD)problem one is asked
to find a small set of taxa in a phylogenetic tree for which this measure is
maximized.Max-PD is particularly relevant in conservation planning,where
limited resources necessitate prioritizing certain taxa to minimize
biodiversity loss.Although Max-PD can be solved in polynomial time
[Steel,SB,2005;Pardi&Goldman,PLoS,2005],its generalizations-which aim to model
biological processes and other aspects in conservation planning with greater
accuracy-often exhibit NP-hardness,making them computationally challenging.This
thesis explores a selection of these generalized problems within the framework
of parameterized complexity. In Generalized Noah's Ark Problem(GNAP),each taxon
only survives at a certain survival probability,which can be increased by
investing more money in the taxon.We show that GNAP is W[1]-hard with respect
to the number of taxa but is XP with respect to the number of different costs
and different survival probabilities. Additionally,we show that unit-cost-NAP,a
special case of GNAP,is NP-hard. In Time Sensitive Maximization of Phylogenetic
Diversity(Time-PD),different extinction times of taxa are considered after
which they can no longer be saved.For Time-PD,we present color-coding
algorithms that prove that Time-PD is fixed-parameter tractable(FPT)with
respect to the threshold of diversity and the acceptable loss of diversity. In
Optimizing PD with Dependencies(PDD),each saved taxon must be a source in the
ecological system or a predator of another saved species.These dependencies are
given in a food-web.We show that PDD is FPT when parameterized with the size of
the solution plus the height of the phylogenetic tree. Further,we consider
pa...

</details>


<div id='cs.FL'></div>

# cs.FL [[Back]](#toc)

### [9] [MightyPPL: Verification of MITL with Past and Pnueli Modalities](https://arxiv.org/abs/2510.01490)
*Hsi-Ming Ho,Shankara Narayanan Krishna,Khushraj Madnani,Rupak Majumdar,Paritosh Pandya*

Main category: cs.FL

TL;DR: 本文提出并实现了MightyPPL，将更强表达力的时间逻辑公式高效转化为时序自动机，实现了更全面和高效的验证，兼容多种后端工具，并通过实证评估展示其性能优势。


<details>
  <summary>Details</summary>
Motivation: 现有关于带时间约束的反应系统规范（MITL）的验证方法存在明显缺陷，要么只支持有限片段，要么验证不完整。

Method: 提出了MightyPPL工具，将含有过去和Pnueli模态的MITPPL公式基于点语义转化为时序自动机，并采用了新的符号化迁移编码和对称约简等性能优化。

Result: MightyPPL能生成与MITPPL公式语言等价的时序自动机，并兼容多个后端工具（Uppaal、TChecker、LTSmin），支持多核模型验证。通过多种案例和配置对工具链进行了性能评估。

Conclusion: MightyPPL显著提升了带时间约束规范逻辑的表达能力和验证效率，对理论和工程领域的时间系统验证具有重要意义。

Abstract: Metric Interval Temporal Logic (MITL) is a popular formalism for specifying
properties of reactive systems with timing constraints. Existing approaches to
using MITL in verification tasks, however, have notable drawbacks: they either
support only limited fragments of the logic or allow for only incomplete
verification. This paper introduces MightyPPL, a new tool for translating
formulae in Metric Interval Temporal Logic with Past and Pnueli modalities
(MITPPL) over the pointwise semantics into timed automata. MightyPPL enables
satisfiability and model checking of a much more expressive specification logic
over both finite and infinite words and incorporates a number of performance
optimisations, including a novel symbolic encoding of transitions and a
symmetry reduction technique that leads to an exponential improvement in the
number of reachable discrete states. For a given MITPPL formula, MightyPPL can
generate either a network of timed automata or a single timed automaton that is
language-equivalent and compatible with multiple verification back-ends,
including Uppaal, TChecker, and LTSmin, which supports multi-core model
checking. We evaluate the performance of the toolchain across various case
studies and configuration options.

</details>

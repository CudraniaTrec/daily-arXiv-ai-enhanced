{"id": "2508.00738", "categories": ["cs.SE", "cs.FL", "68N30", "D.2.4"], "pdf": "https://arxiv.org/pdf/2508.00738", "abs": "https://arxiv.org/abs/2508.00738", "authors": ["Bernhard Rumpe", "Max Stachon", "Sebastian St\u00fcber", "Valdes Voufo"], "title": "Tool-Assisted Conformance Checking to Reference Process Models", "comment": null, "summary": "Reference models convey best practices and standards. The reference\nframeworks necessitate conformance checks to ensure adherence to established\nguidelines and principles, which is crucial for maintaining quality and\nconsistency in various processes. This paper explores automated conformance\nchecks for concrete process models against reference models using causal\ndependency analysis of tasks and events. Existing notions of conformance\nchecking for process models focus on verifying process execution traces and\nlack the expressiveness and automation needed for semantic model comparison,\nleaving this question unresolved. We integrate our approach into a broader\nsemantic framework for defining reference model conformance. We outline an\nalgorithm for reference process model conformance checking, evaluate it through\na case study, and discuss its strengths and limitations. Our research provides\na tool-assisted solution enhancing accuracy and flexibility in process model\nconformance verification.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u56e0\u679c\u4f9d\u8d56\u5206\u6790\u7684\u6d41\u7a0b\u6a21\u578b\u81ea\u52a8\u5408\u89c4\u6027\u68c0\u67e5\u65b9\u6cd5\uff0c\u89e3\u51b3\u4e86\u73b0\u6709\u65b9\u6cd5\u7f3a\u4e4f\u8bed\u4e49\u5bf9\u6bd4\u4e0e\u81ea\u52a8\u5316\u7684\u95ee\u9898\uff0c\u7ecf\u6848\u4f8b\u5206\u6790\u9a8c\u8bc1\u4e86\u5176\u5b9e\u7528\u6027\uff0c\u5e76\u6307\u51fa\u4e86\u65b9\u6cd5\u7684\u4f18\u52bf\u548c\u5c40\u9650\u3002", "motivation": "\u53c2\u8003\u6a21\u578b\u80fd\u591f\u4f20\u9012\u6700\u4f73\u5b9e\u8df5\u548c\u6807\u51c6\uff0c\u4f46\u76ee\u524d\u9488\u5bf9\u6d41\u7a0b\u6a21\u578b\u7684\u5408\u89c4\u6027\u68c0\u67e5\u5927\u591a\u805a\u7126\u4e8e\u6d41\u7a0b\u6267\u884c\u8f68\u8ff9\uff0c\u7f3a\u4e4f\u8bed\u4e49\u5c42\u9762\u7684\u5bf9\u6bd4\u80fd\u529b\u548c\u81ea\u52a8\u5316\u624b\u6bb5\u3002\u56e0\u6b64\uff0c\u5982\u4f55\u6709\u6548\u81ea\u52a8\u5316\u5e76\u63d0\u5347\u6a21\u578b\u8bed\u4e49\u5bf9\u6bd4\u7684\u80fd\u529b\u6210\u4e3a\u4e00\u9879\u4e9f\u9700\u89e3\u51b3\u7684\u95ee\u9898\u3002", "method": "\u672c\u7814\u7a76\u63d0\u51fa\u57fa\u4e8e\u4efb\u52a1\u548c\u4e8b\u4ef6\u56e0\u679c\u4f9d\u8d56\u5206\u6790\u7684\u65b9\u6cd5\uff0c\u5b9e\u73b0\u5177\u4f53\u6d41\u7a0b\u6a21\u578b\u4e0e\u53c2\u8003\u6a21\u578b\u7684\u81ea\u52a8\u5316\u5408\u89c4\u6027\u68c0\u67e5\uff0c\u5e76\u5c06\u5176\u96c6\u6210\u5230\u66f4\u5e7f\u6cdb\u7684\u8bed\u4e49\u5408\u89c4\u6846\u67b6\u4e2d\u3002\u6587\u4e2d\u7ed9\u51fa\u4e86\u5177\u4f53\u7b97\u6cd5\uff0c\u5e76\u901a\u8fc7\u6848\u4f8b\u5206\u6790\u8fdb\u884c\u4e86\u8bc4\u4f30\u3002", "result": "\u6240\u63d0\u51fa\u7684\u65b9\u6cd5\u80fd\u591f\u589e\u5f3a\u6d41\u7a0b\u6a21\u578b\u5408\u89c4\u6027\u9a8c\u8bc1\u7684\u51c6\u786e\u6027\u548c\u7075\u6d3b\u6027\uff0c\u5e76\u63d0\u4f9b\u4e86\u5de5\u5177\u8f85\u52a9\u7684\u89e3\u51b3\u65b9\u6848\u3002\u6848\u4f8b\u7814\u7a76\u5c55\u793a\u4e86\u8be5\u65b9\u6cd5\u7684\u6709\u6548\u6027\uff0c\u540c\u65f6\u4e5f\u8ba8\u8bba\u4e86\u76f8\u5173\u4f18\u52bf\u4e0e\u5c40\u9650\u3002", "conclusion": "\u81ea\u52a8\u5316\u3001\u57fa\u4e8e\u56e0\u679c\u4f9d\u8d56\u5206\u6790\u7684\u6d41\u7a0b\u6a21\u578b\u5408\u89c4\u6027\u68c0\u67e5\u80fd\u6709\u6548\u63d0\u5347\u5bf9\u53c2\u8003\u6a21\u578b\u6807\u51c6\u7684\u9075\u4ece\u6027\uff0c\u65b9\u6cd5\u517c\u5177\u5b9e\u7528\u6027\u548c\u63a8\u5e7f\u4ef7\u503c\u3002"}}
{"id": "2508.00749", "categories": ["cs.SE", "cs.FL", "cs.SC", "68N30", "D.2.4"], "pdf": "https://arxiv.org/pdf/2508.00749", "abs": "https://arxiv.org/abs/2508.00749", "authors": ["Johanna Grahl", "Bernhard Rumpe", "Max Stachon", "Sebastian St\u00fcber"], "title": "Dynamic Symbolic Execution for Semantic Difference Analysis of Component and Connector Architectures", "comment": null, "summary": "In the context of model-driven development, ensuring the correctness and\nconsistency of evolving models is paramount. This paper investigates the\napplication of Dynamic Symbolic Execution (DSE) for semantic difference\nanalysis of component-and-connector architectures, specifically utilizing\nMontiArc models. We have enhanced the existing MontiArc-to-Java generator to\ngather both symbolic and concrete execution data at runtime, encompassing\ntransition conditions, visited states, and internal variables of automata. This\ndata facilitates the identification of significant execution traces that\nprovide critical insights into system behavior. We evaluate various execution\nstrategies based on the criteria of runtime efficiency, minimality, and\ncompleteness, establishing a framework for assessing the applicability of DSE\nin semantic difference analysis. Our findings indicate that while DSE shows\npromise for analyzing component and connector architectures, scalability\nremains a primary limitation, suggesting further research is needed to enhance\nits practical utility in larger systems.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u5e76\u5b9e\u73b0\u4e86\u57fa\u4e8eDSE\u7684MontiArc\u6a21\u578b\u8bed\u4e49\u5dee\u5f02\u5206\u6790\u65b9\u6cd5\uff0c\u80fd\u591f\u8bc6\u522b\u5173\u952e\u6267\u884c\u8f68\u8ff9\uff0c\u4f46\u5728\u5904\u7406\u5927\u578b\u7cfb\u7edf\u65f6\u9047\u5230\u53ef\u6269\u5c55\u6027\u95ee\u9898\uff0c\u9700\u540e\u7eed\u6539\u8fdb\u3002", "motivation": "\u5728\u6a21\u578b\u9a71\u52a8\u5f00\u53d1\u4e2d\uff0c\u6a21\u578b\u7684\u6b63\u786e\u6027\u548c\u4e00\u81f4\u6027\u81f3\u5173\u91cd\u8981\u3002\u6a21\u578b\u5728\u6f14\u5316\u8fc7\u7a0b\u4e2d\uff0c\u5982\u4f55\u9ad8\u6548\u4e14\u51c6\u786e\u5730\u5206\u6790\u5176\u8bed\u4e49\u5dee\u5f02\uff0c\u662f\u63d0\u5347\u7cfb\u7edf\u8d28\u91cf\u7684\u5173\u952e\u95ee\u9898\u3002", "method": "\u672c\u6587\u7814\u7a76\u4e86\u52a8\u6001\u7b26\u53f7\u6267\u884c\uff08DSE\uff09\u5728\u7ec4\u4ef6-\u8fde\u63a5\u5668\u67b6\u6784\u8bed\u4e49\u5dee\u5f02\u5206\u6790\u4e2d\u7684\u5e94\u7528\uff0c\u5177\u4f53\u4ee5MontiArc\u6a21\u578b\u4e3a\u4f8b\u3002\u4f5c\u8005\u589e\u5f3a\u4e86MontiArc\u5230Java\u7684\u4ee3\u7801\u751f\u6210\u5668\uff0c\u5728\u8fd0\u884c\u65f6\u6536\u96c6\u7b26\u53f7\u548c\u5177\u4f53\u6267\u884c\u6570\u636e\uff0c\u5305\u62ec\u81ea\u52a8\u673a\u7684\u8f6c\u6362\u6761\u4ef6\u3001\u5df2\u8bbf\u95ee\u72b6\u6001\u548c\u5185\u90e8\u53d8\u91cf\u3002\u57fa\u4e8e\u8fd9\u4e9b\u6570\u636e\uff0c\u5206\u6790\u91cd\u8981\u7684\u6267\u884c\u8f68\u8ff9\u3002\u8fd8\u63d0\u51fa\u4e86\u6548\u7387\u3001\u6700\u5c0f\u6027\u548c\u5b8c\u6574\u6027\u7b49\u8bc4\u4f30\u6807\u51c6\uff0c\u5bf9\u4e0d\u540c\u6267\u884c\u7b56\u7565\u8fdb\u884c\u6bd4\u8f83\u3002", "result": "\u5b9e\u9a8c\u8bc1\u660eDSE\u5728\u5206\u6790\u6b64\u7c7b\u67b6\u6784\u7684\u8bed\u4e49\u5dee\u5f02\u4e0a\u5177\u6709\u4e00\u5b9a\u6f5c\u529b\uff0c\u4f46\u4ecd\u53d7\u9650\u4e8e\u53ef\u6269\u5c55\u6027\u3002\u5bf9\u4e8e\u89c4\u6a21\u8f83\u5927\u7684\u7cfb\u7edf\uff0c\u5176\u5b9e\u9645\u5e94\u7528\u8fd8\u9700\u8fdb\u4e00\u6b65\u6280\u672f\u7a81\u7834\u3002", "conclusion": "DSE\u4e3a\u7ec4\u4ef6-\u8fde\u63a5\u5668\u67b6\u6784\u7684\u8bed\u4e49\u5dee\u5f02\u5206\u6790\u63d0\u4f9b\u4e86\u65b0\u7684\u9014\u5f84\uff0c\u4f46\u5176\u6269\u5c55\u5230\u5927\u578b\u7cfb\u7edf\u5c1a\u9762\u4e34\u6311\u6218\uff0c\u9700\u8981\u8fdb\u4e00\u6b65\u7814\u7a76\u6539\u8fdb\u5176\u53ef\u6269\u5c55\u6027\u548c\u5b9e\u7528\u6027\u3002"}}
{"id": "2508.00005", "categories": ["cs.PL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.00005", "abs": "https://arxiv.org/abs/2508.00005", "authors": ["Tilman Hinnerichs", "Bart Swinkels", "Jaap de Jong", "Reuben Gardos Reid", "Tudor Magirescu", "Neil Yorke-Smith", "Sebastijan Dumancic"], "title": "Modelling Program Spaces in Program Synthesis with Constraints", "comment": null, "summary": "A core challenge in program synthesis is taming the large space of possible\nprograms. Since program synthesis is essentially a combinatorial search, the\ncommunity has sought to leverage powerful combinatorial constraint solvers.\nHere, constraints are used to express the program semantics, but not as a\npotentially potent tool to remove unwanted programs. Recent inductive logic\nprogramming approaches introduce constraints on the program's syntax to be\nsynthesized. These syntactic constraints allow for checking and propagating a\nconstraint without executing the program, and thus for arbitrary operators. In\nthis work, we leverage syntactic constraints to model program spaces, defining\nnot just solutions that are feasible, but also ones that are likely useful. To\ndemonstrate this idea, we introduce BART, a solver that efficiently propagates\nand solves these constraints. We evaluate BART on program space enumeration\ntasks, finding that the constraints eliminate up to 99 percent of the program\nspace, and that modeling program spaces significantly reduces enumeration time.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u901a\u8fc7\u8bed\u6cd5\u7ea6\u675f\u4f18\u5316\u7a0b\u5e8f\u7efc\u5408\u7a7a\u95f4\uff0c\u5e76\u63a8\u51fa\u4e86BART\u6c42\u89e3\u5668\uff0c\u5b9e\u9a8c\u8868\u660e\u80fd\u7f29\u51cf99%\u7684\u5019\u9009\u7a7a\u95f4\u5e76\u52a0\u901f\u7a0b\u5e8f\u679a\u4e3e\u3002", "motivation": "\u7a0b\u5e8f\u7efc\u5408\u9762\u4e34\u7684\u6838\u5fc3\u6311\u6218\u662f\u5982\u4f55\u9ad8\u6548\u5730\u7b5b\u9009\u5e9e\u5927\u7684\u5019\u9009\u7a0b\u5e8f\u7a7a\u95f4\u3002\u867d\u7136\u7ec4\u5408\u7ea6\u675f\u6c42\u89e3\u5668\u5df2\u88ab\u7528\u6765\u8868\u8fbe\u7a0b\u5e8f\u8bed\u4e49\uff0c\u4f46\u5e76\u672a\u5145\u5206\u5229\u7528\u7ea6\u675f\u6765\u6392\u9664\u4e0d\u9700\u8981\u7684\u7a0b\u5e8f\u3002\u8fd1\u6765\u7684\u5f52\u7eb3\u903b\u8f91\u7f16\u7a0b\u65b9\u6cd5\u5f15\u5165\u4e86\u5bf9\u7a0b\u5e8f\u8bed\u6cd5\u7684\u7ea6\u675f\uff0c\u4f46\u8be5\u65b9\u5411\u4ecd\u6709\u8fdb\u4e00\u6b65\u5f00\u53d1\u7a7a\u95f4\u3002", "method": "\u672c\u6587\u901a\u8fc7\u8bed\u6cd5\u7ea6\u675f\u6765\u5efa\u6a21\u7a0b\u5e8f\u7a7a\u95f4\uff0c\u5229\u7528\u5bf9\u7ea6\u675f\u7684\u6709\u6548\u4f20\u64ad\u4e0e\u6c42\u89e3\uff0c\u4e0d\u4ec5\u5b9a\u4e49\u53ef\u884c\u7a0b\u5e8f\uff0c\u4e5f\u5b9a\u4e49\u6709\u6f5c\u529b\u7684\u5b9e\u7528\u7a0b\u5e8f\u3002\u4e3a\u6b64\uff0c\u4f5c\u8005\u63d0\u51fa\u4e86BART\u6c42\u89e3\u5668\uff0c\u80fd\u591f\u9ad8\u6548\u5904\u7406\u548c\u4f20\u64ad\u8fd9\u7c7b\u8bed\u6cd5\u7ea6\u675f\u3002", "result": "\u5728\u7a0b\u5e8f\u7a7a\u95f4\u679a\u4e3e\u4efb\u52a1\u4e0a\u7684\u5b9e\u9a8c\u8868\u660e\uff0cBART\u501f\u52a9\u7ea6\u675f\u80fd\u6392\u9664\u9ad8\u8fbe99%\u7684\u4e0d\u9700\u8981\u7684\u7a0b\u5e8f\u7a7a\u95f4\uff0c\u6781\u5927\u51cf\u5c11\u4e86\u679a\u4e3e\u7684\u65f6\u95f4\u3002", "conclusion": "\u901a\u8fc7\u9ad8\u6548\u5229\u7528\u8bed\u6cd5\u5c42\u9762\u7684\u7ea6\u675f\uff0c\u7a0b\u5e8f\u7efc\u5408\u4e2d\u7684\u89e3\u7a7a\u95f4\u5f97\u4ee5\u663e\u8457\u7f29\u51cf\uff0c\u63d0\u5347\u4e86\u679a\u4e3e\u6548\u7387\uff0c\u663e\u793a\u4e86BART\u7684\u4f18\u52bf\u3002"}}
{"id": "2508.00031", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.00031", "abs": "https://arxiv.org/abs/2508.00031", "authors": ["Junde Wu"], "title": "Git Context Controller: Manage the Context of LLM-based Agents like Git", "comment": "in updating", "summary": "Large language model (LLM) based agents have shown impressive capabilities by\ninterleaving internal reasoning with external tool use. However, as these\nagents are deployed in long-horizon workflows, such as coding for a big,\nlong-term project, context management becomes a critical bottleneck. We\nintroduce Git-Context-Controller (GCC), a structured context management\nframework inspired by software version control systems. GCC elevates context as\nversioned memory hierarchy like Git. It structures agent memory as a persistent\nfile system with explicit operations: COMMIT, BRANCH, MERGE, and CONTEXT,\nenabling milestone-based checkpointing, exploration of alternative plans, and\nstructured reflection. Our approach empowers agents to manage long-term goals,\nisolate architectural experiments, and recover or hand off memory across\nsessions and agents. Empirically, agents equipped with GCC achieve\nstate-of-the-art performance on the SWE-Bench-Lite benchmark, resolving 48.00\nof software bugs, outperforming 26 competitive systems. In a self-replication\ncase study, a GCC-augmented agent builds a new CLI agent from scratch,\nachieving 40.7 task resolution, compared to only 11.7 without GCC. The code is\nreleased at: https://github.com/theworldofagents/GCC", "AI": {"tldr": "\u672c\u6587\u63d0\u51faGit-Context-Controller(GCC)\uff0c\u4ee5\u8f6f\u4ef6\u7248\u672c\u7ba1\u7406\u7406\u5ff5\u5bf9\u5927\u6a21\u578b\u667a\u80fd\u4f53\u4e0a\u4e0b\u6587\u8fdb\u884c\u7ed3\u6784\u5316\u7ba1\u7406\uff0c\u663e\u8457\u63d0\u5347\u4e86\u5176\u5728\u590d\u6742\u4efb\u52a1\u4e2d\u7684\u8868\u73b0\u3002", "motivation": "\u968f\u7740\u5927\u8bed\u8a00\u6a21\u578b(LLM)\u4e3a\u57fa\u7840\u7684\u667a\u80fd\u4f53\u5728\u5982\u957f\u671f\u7f16\u7801\u9879\u76ee\u7b49\u957f\u6d41\u7a0b\u4efb\u52a1\u4e2d\u88ab\u5e94\u7528\uff0c\u5982\u4f55\u9ad8\u6548\u7ba1\u7406\u4e0a\u4e0b\u6587\u6210\u4e3a\u5236\u7ea6\u5176\u8868\u73b0\u7684\u5173\u952e\u74f6\u9888\u3002\u73b0\u6709\u65b9\u6cd5\u5728\u957f\u8ddd\u79bb\u4fe1\u606f\u5173\u8054\u548c\u60c5\u666f\u5207\u6362\u65b9\u9762\u4ecd\u663e\u4e0d\u8db3\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u53d7\u8f6f\u4ef6\u7248\u672c\u63a7\u5236\u7cfb\u7edf\u542f\u53d1\u7684\u7ed3\u6784\u5316\u4e0a\u4e0b\u6587\u7ba1\u7406\u6846\u67b6\u2014\u2014Git-Context-Controller(GCC)\u3002\u8be5\u65b9\u6cd5\u5c06\u4e0a\u4e0b\u6587\u7ba1\u7406\u63d0\u5347\u4e3a\u7c7b\u4f3cGit\u7684\u7248\u672c\u5316\u8bb0\u5fc6\u4f53\u7cfb\uff0c\u4ee5\u6301\u4e45\u5316\u6587\u4ef6\u7cfb\u7edf\u4e3a\u7ed3\u6784\uff0c\u901a\u8fc7COMMIT\u3001BRANCH\u3001MERGE\u548cCONTEXT\u7b49\u64cd\u4f5c\u5b9e\u73b0\u667a\u80fd\u4f53\u8bb0\u5fc6\u7684\u91cc\u7a0b\u7891\u5f0f\u68c0\u67e5\u70b9\u4fdd\u5b58\u3001\u5206\u652f\u63a2\u7d22\u4e0e\u53cd\u601d\u7ba1\u7406\u7b49\u80fd\u529b\u3002", "result": "\u5728SWE-Bench-Lite\u57fa\u51c6\u6d4b\u8bd5\u4e0a\uff0c\u88c5\u5907GCC\u540e\u7684\u667a\u80fd\u4f53\u4fee\u590d\u4e8648.00%\u7684\u8f6f\u4ef6\u7f3a\u9677\uff0c\u8d85\u8fc7\u4e8626\u4e2a\u7ade\u4e89\u7cfb\u7edf\u3002\u5728\u81ea\u6211\u590d\u5236\u6848\u4f8b\u4e2d\uff0c\u5e94\u7528GCC\u7684\u667a\u80fd\u4f53\u81ea\u96f6\u5f00\u53d1\u65b0CLI\u667a\u80fd\u4f53\uff0c\u4efb\u52a1\u5b8c\u6210\u738740.7%\uff0c\u8fdc\u9ad8\u4e8e\u672a\u52a0GCC\u65f6\u768411.7%\u3002", "conclusion": "GCC\u6781\u5927\u63d0\u5347\u4e86\u667a\u80fd\u4f53\u5728\u957f\u5468\u671f\u548c\u590d\u6742\u4efb\u52a1\u4e2d\u7684\u4e0a\u4e0b\u6587\u7ba1\u7406\u4e0e\u4efb\u52a1\u89e3\u51b3\u80fd\u529b\uff0c\u4e3a\u589e\u5f3a\u591aAgent\u534f\u4f5c\u548c\u77e5\u8bc6\u9057\u4f20\u63d0\u4f9b\u4e86\u6709\u529b\u5de5\u5177\uff0c\u5177\u6709\u5b9e\u9645\u5e94\u7528\u548c\u8fdb\u4e00\u6b65\u63a2\u7d22\u4ef7\u503c\u3002"}}
